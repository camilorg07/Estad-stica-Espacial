---
bibliography: referencias.bib
nocite: '@*'
---

::: {style="font-size: 1.5em; font-weight: bold; margin-bottom: 0.8em; margin-top: 0.5em;"}
Análisis Geoestadístico de Variables Meteorológicas y Ozono en el Estado de California a las 00:00 horas del primero Marzo de 2024
:::

# Análisis Univariado {#cap1}

## Planteamiento del problema

### Introducción

La calidad del aire influye directamente en la salud de las personas, en su bienestar y en el equilibrio del entorno. En California, este tema cobra especial relevancia: es uno de los estados más afectados por la contaminación atmosférica en Estados Unidos. Su alta densidad de población, el tráfico vehicular, la actividad industrial y fenómenos naturales como los incendios forestales hacen que muchas de sus ciudades enfrenten niveles preocupantes de contaminación.

El comportamiento de los contaminantes atmosféricos, como el ozono troposférico ($O_3$), depende en gran medida de las condiciones meteorológicas, entre ellas la temperatura, la velocidad del viento y la presión barométrica. Estas variables influyen en la dispersión y concentración de los contaminantes, generando patrones espaciales que pueden variar significativamente en función del tiempo y la ubicación. En este contexto, el análisis geoestadístico se presenta como una herramienta fundamental para identificar y modelar dichas dependencias espaciales, permitiendo estimar tendencias, ajustar modelos teóricos de variabilidad y construir mapas de predicción que aporten una comprensión más precisa de su comportamiento.

### Descripción de los datos

Los datos objeto de este estudio provienen de la [Agencia de Protección Ambiental (EPA)](https://www.epa.gov/) de los Estados Unidos y corresponden a registros horarios obtenidos de las estaciones de monitoreo durante el mes de marzo de 2024. En particular, se analizan las variables **Temperatura ambiente (Temp)**, **Ozono (**$O_3$**)**, **Velocidad del viento (WS)** y **Presión barométrica**.

#### Unidades

-   **Temperatura ambiente:** Medida en grados celsius (C°) con una intensidad horaria.

-   **Ozono:** Medida en partes por billón (ppb) con una intensidad horaria.

-   **Velocidad del viento:** Medida en metros por segundo (m/s) con una intensidad horaria.

-   **Presión barométrica:** Medida en milibares (mb) con una intensidad horaria.

### Objetivos

#### Objetivo general

Estudiar e identificar la tendencia y los patrones espaciales de las variables meteorológicas y del ozono troposférico ($O_3$) mediante el uso de herramientas de análisis geoestadístico, con el propósito de establecer modelos de predicción espacial que permitan caracterizar su comportamiento en el estado de California durante un periodo específico de tiempo de marzo de 2024.

#### Objetivos específicos

1.  Realizar un análisis de estacionariedad en media, estudiando para cada variable la estructura de la media, identificando la existencia de dependencia espacial y modelándola en consecuencia.

2.  Construir el semivariograma empírico a partir de los datos y ajustar un modelo teórico que describa la dependencia espacial de cada variable.

3.  Aplicar la técnica de Kriging para construir los mapas de predicción espacial y los mapas de incertidumbre asociados, con el fin de representar la distribución esperada de las variables y evaluar la precisión de las estimaciones.

## Análisis geoestadístico

En el análisis se consideran los datos de todas las variables registrados a las 00:00 horas del 1 de marzo de 2024.

```{r, warning=FALSE, message=F}

#Librerias necesarias ------------------------------------

set.seed(123)

library(dplyr)
library(geoR)
library(sp)
library(readxl)
library(tidyr)
library(sf)
library(ggplot2)
library(knitr)
library(plotly)
library(leaflet)
library(raster)
library(stars)
library(terra)

#Variale Temperatura --------------------------------------

Temp <- read_excel("GeoEst_Cali.xlsx", sheet = "Temperatura")
colnames(Temp)[-1] <- as.numeric(colnames(Temp)[-1])
EstacionesT <- read_excel("GeoEst_Cali.xlsx", sheet = "Estaciones")
EstacionesT <- EstacionesT %>% mutate(AQSID = as.numeric(AQSID))
EstacionesT <- EstacionesT %>% filter(AQSID %in% colnames(Temp)[-1])

#Variable Ozono ------------------------------------------

Ozono <- read_excel("GeoEst_Cali.xlsx", sheet = "Ozono")
colnames(Ozono)[-1] <- as.numeric(colnames(Ozono)[-1])
EstacionesOz <- read_excel("GeoEst_Cali.xlsx", sheet = "Estaciones")
EstacionesOz <- EstacionesOz %>% mutate(AQSID = as.numeric(AQSID))
EstacionesOz <- EstacionesOz %>% filter(AQSID %in% colnames(Ozono)[-1])

#Variable velocidad del viento ----------------------------

WS <- read_excel("GeoEst_Cali.xlsx", sheet = "WindSpeed")
colnames(WS)[-1] <- as.numeric(colnames(WS)[-1])
EstacionesWS <- read_excel("GeoEst_Cali.xlsx", sheet = "Estaciones")
EstacionesWS <- EstacionesWS %>% mutate(AQSID = as.numeric(AQSID))
EstacionesWS <- EstacionesWS %>% filter(AQSID %in% colnames(WS)[-1])

#Variable presión atmosférica -----------------------------

Presion <- read_excel("GeoEst_Cali.xlsx", sheet = "Presion")
colnames(Presion)[-1] <- as.numeric(colnames(Presion)[-1])
EstacionesPr <- read_excel("GeoEst_Cali.xlsx", sheet = "Estaciones")
EstacionesPr <- EstacionesPr %>% mutate(AQSID = as.numeric(AQSID))
EstacionesPr <- EstacionesPr %>% filter(AQSID %in% colnames(Presion)[-1])


#Para el mapa de California -------------------------------

sh_mundos<-st_read("admin00.shp",quiet=TRUE)
sh_mundos <- sh_mundos %>% filter(CNTRY_NAME=="United States")
sh_mundos <- sh_mundos %>% filter(ADMIN_NAME=="California")

CRS_UTM_NY = "+init=epsg:3310"

sh_mundos_wgs84 <- st_transform(sh_mundos, crs = 4326)

sh_mundos_utm <- st_transform(sh_mundos, crs = CRS("EPSG:3310"))

sh_mundos_sp_utm <- as(sh_mundos_utm, "Spatial")

sh_mundos_utm_simple <- st_union(sh_mundos_utm)
sh_mundos_sp_utm_simple <- as(sh_mundos_utm_simple, "Spatial")

#Grilla para hacer kriging ------------------------------

new <- sp::spsample(as(sh_mundos_utm, "Spatial"), n = 50000, type = "regular")

proj4string(new) <- CRS("EPSG:3310")
invisible(coordinates(new) ~ Este + Norte)
colnames(new@coords) <- c("Este", "Norte")

#Gráficos de dispersión ----------------------------------

simple_scatter_plot <- function(datos, variable1, variable2) {

    plot1 <- ggplot(as.data.frame(datos),
                    aes(x = .data[[variable1]], y = .data[[variable2]],
                               color = as.factor(1))) +
                    geom_point() +
                    scale_colour_viridis_d() +
                    labs(
                        x = variable1,
                        y = variable2
                        ) +
                    theme_light() +
                    theme(legend.position = "none")

    return(plot1)

}

#1. Funciones de correlación, covarianza y semivarianza: ------------------------

#1.1 Modelo exponencial ----

rho_exp <- function(h, phi){
  exp(-(h/phi)) #Correlacion espacial
}

cov_exp <- function(sigma, h, phi){
  sigma*rho_exp(h, phi) #Covarianza espacial
}

sv_exp <- function(nugget, sigma, h, phi){
  nugget + sigma - cov_exp(sigma, h, phi) #Semivarianza espacial
} 

#1.2 Modelo Gaussianio ----

rho_gauss <- function(h, phi){
  exp(-(h/phi)^2)
}

cov_gauss <- function(sigma, h, phi){
  sigma*rho_gauss(h, phi) #Covarianza espacial
}

sv_gauss <- function(nugget, sigma, h, phi){
  nugget + sigma - cov_gauss(sigma, h, phi) #Semivarianza espacial
}
#1.3 Modelo Gneting ----

cov_gneiting <- function(sigma, h, phi){
  s <- 1/phi
  x <- h *s
  cov <- ifelse(
    0 <= x & x <= 1,
    sigma*(1 + 8*x + 25*x^2 + 32*x^3) * (1 - x)^8,
    0
  )
  return(cov)
}

sv_gneiting <- function(nugget, sigma, h, phi){
  nugget + sigma - cov_gneiting(sigma, h, phi) #Semivarianza espacial
}

#1.4 Modelo Spherical ----

rho_spherical <- function(h, phi){
  ifelse(h<phi,
         1 - 1.5*(h/phi) + 0.5*(h/phi)^3,
         0)
}

cov_spherical <- function(sigma, h, phi){
  sigma*rho_spherical(h, phi) #Covarianza espacial
}

sv_spherical <- function(nugget, sigma, h, phi){
  nugget + sigma - cov_spherical(sigma, h, phi) #Semivarianza espacial
}

#1.5 Modelo Matern ----

rho_matern <- function(h, phi, kappa){
  (1/(2*gamma(kappa))) * (h/phi)^kappa * besselK((h/phi), kappa)
}

cov_matern <- function(sigma, h, phi, kappa){
  sigma*rho_matern(h, phi, kappa) #Covarianza espacial
}

sv_matern <- function(nugget, sigma, h, phi, kappa){
  nugget + sigma - cov_matern(sigma, h, phi, kappa) #Semivarianza espacial
}

#1.6 Modelo Coseno -----------------

cov_cos <- function(sigma, h, phi){
  sigma * cos(h/phi)
}

cos_sv <- function(nugget, sigma, h, phi){
  nugget +  sigma *(1 - cos(2*pi*h/phi))
}

#1.7 Modelo wave ------


rho_wave <- function(h, sigma, phi){
  ifelse(h == 0,
         1,
         (phi / h) * sin(h / phi))
}

sv_wave <- function(nugget, sigma, h, phi) {
  ifelse(h == 0,
         nugget,
         nugget + sigma - sigma * (phi / h) * sin(h / phi))
}

cov_wave <- function(h, sigma, phi, nugget) {
  ifelse(h == 0,
         sigma,
         sigma * (phi / h) * sin(h / phi))
}


#2. Función para estimar por WLS----

MSE_ponderados <- function(par, h, gamma,kappa=NA,w, model, n, pesos){
  nugget <- par[1]
  sigma <- par[2]
  phi <- par[3]
  
  gamma_hat <- switch(model,
                      "exponencial" = sv_exp(nugget, sigma, h, phi),
                      "gaussian"    = sv_gauss(nugget, sigma, h, phi),
                      "gneiting"    = sv_gneiting(nugget, sigma, h, phi),
                      "spherical"   = sv_spherical(nugget, sigma, h, phi),
                      "matern"      = sv_matern(nugget, sigma, h, phi, kappa),
                      "cos"         = cos_sv(nugget, sigma, h, phi)
  )
  
  w <- switch(pesos,
              "Cressie" = 1/(2*(2*gamma_hat)^2/n),
              "n" = 1/n,
              "h/n" = 1/(h/n),
              "I" = 1)
  
  sum(w*(gamma - gamma_hat)^2)
}


est_sev_WLS <- function(par, kappa = NA, model, h, gamma, n){
  sigma_0 <- par[1]
  phi_0 <- par[2]
  nugget_0 <- par[3]
  kappa_0 <- kappa
  
  # Selección de función
  sv <- switch(model,
               "exponencial" = sv_exp,
               "gaussian"    = sv_gauss,
               "spherical"   = sv_spherical,
               "gneiting"    = sv_gneiting,
               "matern"      = sv_matern,
               "cos" = cos_sv
  )
  
  args_sv <- names(formals(sv))
  
  args_list <- list(
    nugget = nugget_0,
    sigma  = sigma_0,
    h      = h,
    phi    = phi_0,
    kappa  = kappa_0
  )
  
  args_list <- args_list[names(args_list) %in% args_sv]
  
  sv_ini <- do.call(sv, args_list)
  
  formula_sv <- switch(model,
                       "gneiting" = gamma ~ sv(nugget, sigma, h),
                       "matern" = gamma ~ sv(nugget, sigma, h, phi, kappa),
                       gamma ~ sv(nugget, sigma, h, phi)
  )
  
  start_list <- switch(model,
                       "gneting" = list(nugget = nugget_0, sigma = sigma_0),
                       "matern" = list(nugget = nugget_0, sigma = sigma_0, phi = phi_0, kappa = kappa_0),
                       list(nugget = nugget_0, sigma = sigma_0, phi = phi_0)
  )
    
    #1. Ponderación de Bessel
    
    WW <- (2*(2*sv_ini)^2/n)
    
    Bessel <- nls(formula = formula_sv,
                  start = start_list,
                  weights = 1/WW,
                  lower = c(0, rep(1e-6, length(start_list)-1)),
                  control = nls.control(maxiter = 500, warnOnly = TRUE))
    
    ini_Bessel<-coef(Bessel)
    
    #1.1 Optim Bessel
    
    optim_bessel <- optim(
      par = coef(Bessel),
      fn = MSE_ponderados,
      h = h,
      gamma = gamma,
      pesos = "Cressie",
      model = model,
      n = n,
      method = "L-BFGS-B",
      lower = c(0, rep(1e-6, length(start_list)-1))
    )
    
    par_optim_Bess <- optim_bessel$par[c("nugget", "sigma", "phi")]
    
    #2. Ponderación 1/n
    
    W1 <- n
    
    n_pond <- nls(formula = formula_sv,
                  start = start_list,
                  weights = 1/W1,
                  lower = c(0, rep(1e-6, length(start_list)-1)),
                  control = nls.control(maxiter = 500, warnOnly = TRUE))
    
    ini_n<-coef(n_pond)
    
    #2.1 Optimización 1/n
    
    optim_n <- optim(
      par = coef(n_pond),
      fn = MSE_ponderados,
      h = h,
      gamma = gamma,
      pesos = "n",
      n = n,
      model = model,
      method = "L-BFGS-B",
      lower = c(0, rep(1e-6, length(start_list)-1))
    )    
    
    par_optim_n <- optim_n$par[c("nugget", "sigma", "phi")]
    
    
    #3. Ponderación h/n
    
    W2 <- h/n
    
    h_n_pond <- nls(formula = formula_sv,
                    start = start_list,
                    weights = 1/W2,
                    lower = c(0, rep(1e-6, length(start_list)-1)),
                    control = nls.control(maxiter = 500, warnOnly = TRUE))
    
    ini_h_n<-coef(h_n_pond)
    
    optim_h_n <- optim(
      par = coef(h_n_pond),
      fn = MSE_ponderados,
      h = h,
      gamma = gamma,
      pesos = "h/n",
      model = model,
      n = n,
      method = "L-BFGS-B",
      lower = c(0, rep(1e-6, length(start_list)-1))
    )    
    
    par_optim_h_n <- optim_h_n$par[c("nugget", "sigma", "phi")]
    

res <- list(Bessel = list(Iniciales = ini_Bessel,
                           Optimizados = par_optim_Bess),
            `1/n` = list(Iniciales = ini_n,
                          Optimizados = par_optim_n),
            `h/n` = list(Iniciales = ini_h_n,
                          Optimizados = par_optim_h_n))    
return(res)
}

MSE_sv <- function(gamma_hat, par, kappa, model, h){
  sigma_0 <- par[[2]]
  phi_0 <- par[[3]]
  nugget_0 <- par[[1]]
  kappa_0 <- kappa
  
  sv <- switch(model,
               "exponencial" = sv_exp,
               "gaussian"    = sv_gauss,
               "spherical"   = sv_spherical,
               "gneiting"    = sv_gneiting,
               "matern"      = sv_matern,
               "cos" = cos_sv,
               "wave" = sv_wave
  )
  
  args_sv <- names(formals(sv))
  
  args_list <- list(
    nugget = nugget_0,
    sigma  = sigma_0,
    h      = h,
    phi    = phi_0,
    kappa  = kappa_0
  )
  
  args_list <- args_list[names(args_list) %in% args_sv]
  
  sv_est <- do.call(sv, args_list)
  
  return(mean((sv_est-gamma_hat)^2))
}

#3. Función para etimar por máxima verosimilitud

loglik <- function(par, kappa=NA, z, dist_matrix, model){
  sigma_0 <- par[1]
  phi_0 <- par[2]
  nugget_0 <- par[3]
  kappa_0 <- kappa
  
  cov <- switch(model,
               "exponencial" = cov_exp,
               "gaussian"    = cov_gauss,
               "spherical"   = cov_spherical,
               "gneiting"    = cov_gneiting,
               "matern"      = cov_matern
  )
  
  args_cov <- names(formals(cov))
  
  args_list <- list(
    sigma  = sigma_0,
    nugget = nugget_0,
    h      = dist_matrix,
    phi    = phi_0,
    kappa  = kappa_0
  )
  
  args_list <- args_list[names(args_list) %in% args_cov]
  
  Sigma <- do.call(cov, args_list) 
  diag(Sigma) = diag(Sigma) + nugget_0
  
  # Descomposición de Cholesky (más estable que solve o det)
  inv_Sigma <- solve(Sigma)
  det <- log(det(Sigma))
  
  # Log-verosimilitud del modelo Gaussiano
  z <- z 
  n <- length(z)
  ll <- -0.5 * (n * log(2 * pi) + det + crossprod(z, inv_Sigma %*% z))  # Log-verosimilitud (negativa porque optim minimiza)
  return(-ll)
}

```

### Variable Ozono

En el siguiente mapa se presenta la distribución territorial de las estaciones de **Ozono**, así mismo como sus valores muestrales:

```{r, message=F, warning=F}

y_oz <- Ozono[1,] #Tomar una fecha
y_oz <- cbind(colnames(y_oz),t(y_oz[1,]))
y_oz <- y_oz[-1,]
y_oz <- as.data.frame(y_oz)
y_oz <- na.omit(y_oz)
y_oz$V1 <- as.numeric(y_oz$V1)
y_oz <- inner_join(y_oz, EstacionesOz, by=c("V1"="AQSID"))
datosOZ <- y_oz[,c(13,14,2)] #DatosOz es la base con coordenadas + variable
colnames(datosOZ)=c("Este","Norte","Ozono")
datosOZ$Ozono <- as.numeric(datosOZ$Ozono)

datosOZ_sf <- st_as_sf(datosOZ, coords = c("Este", "Norte"), crs = 3310)

datosO_sf_wgs84 <- st_transform(datosOZ_sf, crs = 4326)

palO <- colorNumeric(palette = "viridis", domain = datosO_sf_wgs84$Ozono)

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = "black", weight = 2) %>%
  addCircleMarkers(data = datosO_sf_wgs84,
                   fillColor = ~palO(Ozono),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("Ozono:", Ozono, "°C")) %>%
  addLegend(pal = palO, values = datosO_sf_wgs84$Ozono, title = "Ozono (ppb)")

```

Los datos observados son trabajados en el formato *geodata* mediante el uso de la función `as.geodata()` del paquete `GeoR`. El resumen de las coordenadas y la variable Ozono se presenta tabularmente en seguida:

```{r, message=F, warning=F}
ozone <- as.geodata(datosOZ) 
pander::pander(summary(ozone))
```

#### Análisis de Estacionariedad en Media

Ahora, se procede a revisar el comportamiento de la media de la variable con respecto a las coordenadas *Este* y *Norte*. Para entender de mejor manera la distribución de la variable ozono se presentan la matriz de correlación muestral y los siguientes gráficos:

::: panel-tabset
##### Matriz

```{r}
pander::pander(cor(datosOZ))
```

##### Gráficos de dispersión

```{r}
pO1 <- simple_scatter_plot(datosOZ, "Este", "Ozono")
pO2 <- simple_scatter_plot(datosOZ, "Norte", "Ozono")

cowplot::plot_grid(pO1,pO2)

```

##### GeoR

```{r}
plot(ozone, qt.col = c("purple",
                          "pink",
                          "green",
                          "yellow"),
     scatter3d=T)
```
:::

En el gráfico se observa una relación polinomial de la variable Ozono con respecto a las coordenadas en Norte, mientras que con respecto a las coordenadas en Este se observa una correlación lineal. Se prueba con varios modelos hasta encontrar aquel que mitigue el efecto espacial de mejor manera.

##### Ajuste del Modelo

El modelo que mejor atrapa el efecto de la media es:

$$Ozono = \beta_0+\beta_1 \times Norte^2 + \beta_2 \times Norte^3 + \beta_3 \times Este$$

```{r}
fitO <- lm(Ozono~I(Norte^2)+I(Norte^3)+Este, data = datosOZ) 
pander::pander(summary(fitO))
```

Se observa que todos los coeficientes del modelo resultan estadísticamente significativos. Además, aunque el valor de $R^2$ (0.42) no es particularmente alto, es lo suficientemente representativo como para considerar que el ajuste del modelo fue adecuado y aporta información relevante sobre el fenómeno analizado.

::: panel-tabset
###### Gráficos de dispersión

```{r}
datosOZ$Residuos <- fitO$residuals

pO1 <- simple_scatter_plot(datosOZ, "Este", "Residuos")
pO2 <- simple_scatter_plot(datosOZ, "Norte", "Residuos")

cowplot::plot_grid(pO1,pO2)

```

###### GeoR

```{r}
plot(ozone, qt.col = c("purple",
                          "pink",
                          "green",
                          "yellow"),
     scatter3d=T, trend = ~ poly(Norte,3))
```
:::

En los gráficos de dispersión, usando `ggplot` y `geoR`, se aprecia también una notable mitigación del efecto de las coordenadas sobre la variable **ozono**, lo que sugiere que la estructura espacial de la media fue modelada de manera adecuada..

#### Estudio del Semivariograma

##### Estimación Empírica del Semivariograma

A continuación, se presenta la estimación del semivariograma obtenida con la función `variog()`. Para asegurar la fiabilidad de los resultados, se especifican los argumentos `estimator.type = "modulus"` y `pairs.min=50`, con el fin de utilizar un estimador robusto y garantizar un número mínimo adecuado de pares en cada intervalo de distancia.

```{r, message=FALSE, results='hide'}
vg_O <- variog(ozone,estimator.type = "modulus", pairs.min=50) #Sin tendencia espacial

vg1_O <- variog(ozone, trend = ~I(Norte^2)+I(Norte^3)+Este, estimator.type = "modulus", pairs.min=50)
```

::: panel-tabset
###### Con tendencia

```{r}
plot(vg_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Sin remover tendencia",
     col.main = "#36648B", cex.main =1.3)
```

###### Removiendo Tendencia

```{r}
plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Removiendo tendencia",
     col.main = "#36648B", cex.main =1.3)
```
:::

Se observa que la estimación de la varianza de la variable incrementos es más estable y presenta valores más bajos al remover la tendencia, lo que indica que en este caso el semivariograma refleja de manera más adecuada la verdadera estructura espacial del fenómeno.

##### Estimación del Modelo Teórico de Semivariograma

Para obtener unos valores iniciales de los modelos teóricos se usa la función `EyeFit()` de la librería `GeoR`.

Los modelos obtenidos ajustando por `EyeFit()`, son:

> cov.model sigmasq phi tausq kappa kappa2 practicalRange
>
> 1 matern 17.0 440676.0 5 0.5 NA 1320147
>
> 2 gneiting 17.5 803585.6 9 NA NA 1371348
>
> 3 exponential 10 6e5 10 NA NA 1320147

::: panel-tabset
###### Matern

```{r}
#| message: false
#| warning: false
#| results: 'hide'

variog_O <- data.frame(h = vg1_O$u, gamma_hat = vg1_O$v,
                       n = vg1_O$n)

sigma_0_mO <- 12.0
phi_0_mO <- 224249.7
nugget_0_mO <- 2.00 
kappa_0_mO <- 0.2

ini1_mat_O <- c(sigma_0_mO, phi_0_mO)
fitvar1_mat_O <- variofit(vg1_O,
                    cov.model = "matern",
                    ini1_mat_O,
                    fix.nugget = F,
                    nugget = nugget_0_mO,
                    kappa = kappa_0_mO,
                    wei = "equal")

fitvar2_mat_O <- variofit(vg1_O,
                    cov.model = "matern",
                    ini1_mat_O,
                    fix.nugget = F,
                    nugget = nugget_0_mO,
                    kappa = kappa_0_mO,
                    wei = "npairs")

fitvar3_mat_O <- variofit(vg1_O,
                    cov.model = "matern",
                    ini1_mat_O,
                    fix.nugget = F,
                    nugget = nugget_0_mO,
                    kappa = kappa_0_mO,
                    wei = "cressie")

fitvar4_mat_O <- likfit(ozone,
                  coords = ozone$coords,
                  data = ozone$data,
                  trend = ~ I(Norte^2) + I(Norte^3) + Este,
                  ini.cov.pars = ini1_mat_O,
                  fix.nugget = F,
                  nugget = nugget_0_mO,
                  kappa = kappa_0_mO,
                  cov.model = "matern",
                  lik.method = "ML")


plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_mat_O, col="#FF4040", lwd=1.5)
lines(fitvar2_mat_O, col="#4169E1", lwd=1.5)
lines(fitvar3_mat_O, col="#008B00", lwd=1.5)
lines(fitvar4_mat_O, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)
```

```{r}
par1Om <- c(fitvar1_mat_O$nugget, fitvar1_mat_O$cov.pars[1], fitvar1_mat_O$cov.pars[2], fitvar1_mat_O$kappa)
par2Om <- c(fitvar2_mat_O$nugget, fitvar2_mat_O$cov.pars[1], fitvar2_mat_O$cov.pars[2],fitvar2_mat_O$kappa)
par3Om <- c(fitvar3_mat_O$nugget, fitvar3_mat_O$cov.pars[1], fitvar3_mat_O$cov.pars[2],fitvar3_mat_O$kappa)
par4Om <- c(fitvar4_mat_O$nugget, fitvar4_mat_O$cov.pars[1], fitvar4_mat_O$cov.pars[2],fitvar4_mat_O$kappa)

resumen_O_m <- cbind(
  c("MCO", "1/n", "Cressie","MLE"),
  rbind(
    par1Om,
    par2Om,
    par3Om,
    par4Om
  ),
  MSE = c(
    mean((par1Om[1]+par1Om[2]-cov.spatial(variog_O$h, cov.model = "matern", cov.pars = par1Om[c(2,3)], kappa = par1Om[4])-variog_O$gamma_hat)^2),
    mean((par2Om[1]+par2Om[2]-cov.spatial(variog_O$h, cov.model = "matern", cov.pars = par2Om[c(2,3)], kappa = par2Om[4])-variog_O$gamma_hat)^2),
    mean((par3Om[1]+par3Om[2]-cov.spatial(variog_O$h, cov.model = "matern", cov.pars = par3Om[c(2,3)], kappa = par3Om[4])-variog_O$gamma_hat)^2),
     mean((par4Om[1]+par4Om[2]-cov.spatial(variog_O$h, cov.model = "matern", cov.pars = par4Om[c(2,3)], kappa = par4Om[4])-variog_O$gamma_hat)^2)
  )
)

resumen_O_m <- as.data.frame(resumen_O_m)
resumen_O_m[ , -1] <- lapply(resumen_O_m[ , -1], function(x) round(as.numeric(x), 3))
kable(resumen_O_m, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "Kappa", "MSE"),
      escape = F, row.names = F)
```

###### Gneiting

```{r}
#| message: false
#| warning: false
#| results: 'hide'


sigma_0_gO <- 17.5
phi_0_gO <- 803585.6
nugget_0_gO <- 9

ini1_g_O <- c(sigma_0_gO, phi_0_gO)
fitvar1_g_O <- variofit(vg1_O,
                    cov.model = "gneiting",
                    ini1_g_O,
                    fix.nugget = F,
                    nugget = nugget_0_gO,
                    wei = "equal")

fitvar2_g_O <- variofit(vg1_O,
                    cov.model = "gneiting",
                    ini1_g_O,
                    fix.nugget = F,
                    nugget = nugget_0_gO,
                    wei = "npairs")

fitvar3_g_O <- variofit(vg1_O,
                    cov.model = "gneiting",
                    ini1_g_O,
                    fix.nugget = F,
                    nugget = nugget_0_gO,
                    wei = "cressie")

fitvar4_g_O <- likfit(ozone,
                  coords = ozone$coords,
                  data = ozone$data,
                  trend = ~ I(Norte^2) + I(Norte^3) + Este,
                  ini.cov.pars = ini1_g_O,
                  fix.nugget = F,
                  nugget = nugget_0_gO,
                  cov.model = "gneiting",
                  lik.method = "ML")


plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_g_O, col="#FF4040", lwd=1.5)
lines(fitvar2_g_O, col="#4169E1", lwd=1.5)
lines(fitvar3_g_O, col="#008B00", lwd=1.5)
lines(fitvar4_g_O, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)
```

```{r}
par1Og <- c(fitvar1_g_O$nugget, fitvar1_g_O$cov.pars[1], fitvar1_g_O$cov.pars[2])
par2Og <- c(fitvar2_g_O$nugget, fitvar2_g_O$cov.pars[1], fitvar2_g_O$cov.pars[2])
par3Og <- c(fitvar1_g_O$nugget, fitvar3_g_O$cov.pars[1], fitvar3_g_O$cov.pars[2])
par4Og <- c(fitvar4_g_O$nugget, fitvar4_g_O$cov.pars[1], fitvar4_g_O$cov.pars[2])

resumen_O_g <- cbind(
  c("MCO", "1/n", "Cressie","MLE"),
  rbind(
    par1Og,
    par2Og,
    par3Og,
    par4Og
  ),
  MSE = c(
    mean((par1Og[1]+par1Og[2]-cov.spatial(variog_O$h, cov.model = "gneiting", cov.pars = par1Og[c(2,3)])-variog_O$gamma_hat)^2),
    mean((par2Og[1]+par2Og[2]-cov.spatial(variog_O$h, cov.model = "gneiting", cov.pars = par2Og[c(2,3)])-variog_O$gamma_hat)^2),
    mean((par3Og[1]+par3Og[2]-cov.spatial(variog_O$h, cov.model = "gneiting", cov.pars = par3Og[c(2,3)])-variog_O$gamma_hat)^2),
     mean((par4Og[1]+par4Og[2]-cov.spatial(variog_O$h, cov.model = "gneiting", cov.pars = par4Og[c(2,3)])-variog_O$gamma_hat)^2)
  )
)

resumen_O_g <- as.data.frame(resumen_O_g)
resumen_O_g[ , -1] <- lapply(resumen_O_g[ , -1], function(x) round(as.numeric(x), 3))
kable(resumen_O_g, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)
```

###### Exponencial

```{r}
#| message: false
#| warning: false
#| results: 'hide'

sigma_0_lO <- 10
phi_0_lO <- 6e5
nugget_0_lO <- 10

ini1_l_O <- c(sigma_0_lO, phi_0_lO)
fitvar1_l_O <- variofit(vg1_O,
                    cov.model = "exponential",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "equal")

fitvar2_l_O <- variofit(vg1_O,
                    cov.model = "exponential",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "npairs")

fitvar3_l_O <- variofit(vg1_O,
                    cov.model = "exponential",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "cressie")

fitvar4_l_O <- likfit(ozone,
                  coords = ozone$coords,
                  data = ozone$data,
                  trend = ~ I(Norte^2) + I(Norte^3) + Este,
                  ini.cov.pars = ini1_l_O,
                  fix.nugget = F,
                  nugget = nugget_0_lO,
                  cov.model = "exponential",
                  lik.method = "ML")


plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_l_O, col="#FF4040", lwd=1.5)
lines(fitvar2_l_O, col="#4169E1", lwd=1.5)
lines(fitvar3_l_O, col="#008B00", lwd=1.5)
lines(fitvar4_l_O, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

```

```{r}
par1Oexp <- c(fitvar1_l_O$nugget, fitvar1_l_O$cov.pars[1], fitvar1_l_O$cov.pars[2])
par2Oexp <- c(fitvar2_l_O$nugget, fitvar2_l_O$cov.pars[1], fitvar2_l_O$cov.pars[2])
par3Oexp <- c(fitvar1_l_O$nugget, fitvar3_l_O$cov.pars[1], fitvar3_l_O$cov.pars[2])
par4Oexp <- c(fitvar4_l_O$nugget, fitvar4_l_O$cov.pars[1], fitvar4_l_O$cov.pars[2])

resumen_O_exp <- cbind(
  c("MCO", "1/n", "Cressie","MLE"),
  rbind(
    par1Oexp,
    par2Oexp,
    par3Oexp,
    par4Oexp
  ),
  MSE = c(
    mean((par1Oexp[1]+par1Oexp[2]-cov.spatial(variog_O$h, cov.model = "exponential", cov.pars = par1Oexp[c(2,3)])-variog_O$gamma_hat)^2),
    mean((par2Oexp[1]+par2Oexp[2]-cov.spatial(variog_O$h, cov.model = "exponential", cov.pars = par2Oexp[c(2,3)])-variog_O$gamma_hat)^2),
    mean((par3Oexp[1]+par3Oexp[2]-cov.spatial(variog_O$h, cov.model = "exponential", cov.pars = par3Oexp[c(2,3)])-variog_O$gamma_hat)^2),
     mean((par4Oexp[1]+par4Oexp[2]-cov.spatial(variog_O$h, cov.model = "exponential", cov.pars = par4Oexp[c(2,3)])-variog_O$gamma_hat)^2)
  )
)

resumen_O_exp <- as.data.frame(resumen_O_exp)
resumen_O_exp[ , -1] <- lapply(resumen_O_exp[ , -1], function(x) round(as.numeric(x), 3))
kable(resumen_O_exp, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)
```
:::

Se observa que los modelos **Exponencial** y **Gneiting** presentan un menor error cuadrático medio, sin embargo, ambos modelos presentan un *nugget* considerablemente alto en relación a la magnitud de la semivarianza observada. Por esta razón se opta por utilizar el modelo **Matern** para realizar la predicción.

#### Kriging

El modelo **Matern**, con los parámetros obtenidos por **MCO**, que se usará para realizar Kriging es el siguiente:

```{r, echo=FALSE}
plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Modelo Matern para Ozono",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_mat_O, col="#FF4040", lwd=1.5)

```

Para realizar la predicción, se genera una muestra aleatoria de puntos dentro del polígono que delimita el estado de California mediante la función `spsample()` del paquete `sp`. Sobre estos puntos se estiman los valores esperados aplicando el método de **Kriging de vecinos cercanos**, con el fin de mejorar la precisión de las estimaciones al considerar las grandes distancias características del territorio californiano. El procedimiento se implementa mediante la función `krige()` de `gstat`, especifícando la opción `nmin=20` y utilizando la función `predict()` de base de `R`.

```{r, message=F, warning=F, results='hide'}

#Se ajusta el mejor modelo -------------------------------

best_model_O <- gstat::vgm(psill = fitvar1_mat_O$cov.pars[1],
                           model = "Mat",
                           range = fitvar1_mat_O$cov.pars[2],
                           nugget = fitvar1_mat_O$nugget,
                           kappa = fitvar1_mat_O$kappa
                           
)

# Se crea un objeto en gstat ------------------------------

coordinates(datosOZ) <- ~Este + Norte
proj4string(datosOZ) <- CRS("EPSG:3310")

g_obj<-gstat::gstat(id="Ozono",
             formula = Ozono ~ I(Norte^2) + I(Norte^3) + Este,
             model = best_model_O,
             data = datosOZ)

#Kriging ------------------------------------------------

invisible(predic <- predict(g_obj, newdata = new, nmin = 20))


#Mapas de predicción -------------------------------------

gridded(predic) <- TRUE

#1. Mapa de Kriging --------------------------------------

predic_raster_utm <- raster(predic, layer = "Ozono.pred")

crs(predic_raster_utm) <- "+init=epsg:3310"

predic_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        predic_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

min_pred <- raster::cellStats(predic_raster_wgs84, stat='min')
max_pred <- raster::cellStats(predic_raster_wgs84, stat='max')

pred_range <- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))

step_pred <- (max_pred-min_pred)/ 6

bins <- round(seq(min_pred, max_pred, by=step_pred),0)

pal_pred <- colorBin(
  palette = "viridis", # La paleta de colores
  domain = pred_range,
  bins = bins,
  na.color = "transparent"
)

mapa_kriging_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    predic_raster_wgs84, 
    colors = pal_pred, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
    addCircleMarkers(data = datosO_sf_wgs84,
                   fillColor = ~palO(Ozono),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("Ozn:", Ozono, "ppb")) %>% 
  
  addLegend(
    pal = pal_pred, 
    values = pred_range,
    title = "Predicción Oz ppb",
    position = "topright"
  ) %>%
  
  addLegend(pal = palO,
            values = datosO_sf_wgs84$Ozono,
            title = "Ozono Observado",
    position = "topleft"
  ) 

#2 Mapa Varianza------------------------------------------

var_raster_utm <- raster(predic, layer = "Ozono.var")

crs(var_raster_utm) <- "+init=epsg:3310"

var_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        var_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

max_var <- raster::cellStats(var_raster_wgs84, stat='max')
step_var <- max_var / 6

binsv <- round(seq(0, max_var, by=step_var),2)

var_range <- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))
pal_var <- colorBin(
  palette = "Spectral", # La paleta de colores
  domain = var_range,
  bins = binsv,
  na.color = "transparent"
)

mapa_var_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    var_raster_wgs84,
    colors = pal_var, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_var, 
    values = var_range,
    title = "Varianza",
    position = "topright"
  ) 

#3. Mapa Cv ----------------------------------------------

cv_raster_utm <- sqrt(var_raster_utm) / abs(predic_raster_utm)

mapa_mayor_a_uno <- cv_raster_utm > 1
cv_raster_utm[mapa_mayor_a_uno] <- 1

crs(cv_raster_utm) <- "+init=epsg:3310"

cv_terra <- terra::rast(cv_raster_utm)
sh_terra <- terra::vect(sh_mundos_sp_utm_simple)

masked_cv_terra <- terra::mask(cv_terra, sh_terra)

cv_raster_wgs84_terra <- terra::project(
    masked_cv_terra, 
    y = "epsg:4326", 
    method = "bilinear" # Similar a projectRaster
)

cv_raster_wgs84 <- raster::raster(cv_raster_wgs84_terra)

max_cv <- raster::cellStats(cv_raster_wgs84, stat='max')
step_cv <- max_cv / 10

bincv <- seq(0,max_cv, by=step_cv)

cv_range <- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))

pal_cv <- colorBin(
  palette = "RdYlGn", # Rojo-Amarillo-Verde
  domain = cv_range,
  na.color = "transparent",
  bins = bincv,
  reverse = TRUE
)

mapa_cv_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    cv_raster_wgs84,
    colors = pal_cv, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_cv, 
    values = cv_range,
    title = "Coeficiente de Variación",
    position = "topright"
  )

```

En el siguiente panel se presentan 3 mapas que resumen el proceso de predicción:

::: panel-tabset
##### Predicción

```{r}
mapa_kriging_leaflet
```

##### Varianza

```{r}
mapa_var_leaflet
```

##### Coeficiente de variación

```{r}
mapa_cv_leaflet
```
:::

Los resultados del Kriging indican que la calidad del aire tiende a ser más deficiente en el sur de California y en el Valle Central, donde se observan las concentraciones predichas más altas de ozono. Dado que estas regiones cuentan con una alta densidad de estaciones de monitoreo, se cuenta con una mayor confiabilidad y precisión en las estimaciones del modelo (reflejada en valores bajos de varianza o coeficiente de variación). En contraste, las predicciones sobre la concentración de ozono presentan mayor incertidumbre (varianza o CV elevados) en las zonas rurales y fronterizas del norte y este del estado, debido a la menor disponibilidad de estaciones de observación en esas áreas.

A pesar de que los coeficientes de variación presentan valores muy bajos, todos inferiores al 11%, es importante interpretar estos resultados con cautela. Aunque se aplicó un **Kriging de vecinos cercanos** para mitigar el efecto de las grandes distancias entre puntos, es posible que aún persista cierto nivel de ruido o variabilidad residual asociado a la extensión geográfica del área californiana.

### Variable Temperatura

En el siguiente mapa se presenta la distribución territorial de las estaciones de **Temperatura**, así mismo como sus valores muestrales:

```{r, message=F, warning=F}
y_T <- Temp[1,] #Tomar una fecha
y_T <- cbind(colnames(y_T),t(y_T[1,]))
y_T <- y_T[-1,]
y_T <- as.data.frame(y_T)
y_T <- na.omit(y_T)
y_T <- y_T[-which.min(y_T$V2),]
y_T$V1 <- as.numeric(y_T$V1)
y_T <- inner_join(y_T, EstacionesT, by=c("V1"="AQSID"))
datosT <- y_T[,c(13,14,2)]
colnames(datosT)=c("Este","Norte","Temperatura")
datosT$Temperatura <- as.numeric(datosT$Temperatura)

datosT_sf <- st_as_sf(datosT, coords = c("Este", "Norte"), crs = 3310)

datosT_sf_wgs84 <- st_transform(datosT_sf, crs = 4326)

pal <- colorNumeric(palette = "viridis", domain = datosT_sf_wgs84$Temperatura)

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = "black", weight = 2) %>%
  addCircleMarkers(data = datosT_sf_wgs84,
                   fillColor = ~pal(Temperatura),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("Temp:", Temperatura, "°C")) %>%
  addLegend(pal = pal, values = datosT_sf_wgs84$Temperatura, title = "Temperatura (°C)")

```

Los datos observados son trabajados en el formato *geodata* mediante el uso de la función `as.geodata()` del paquete `GeoR`. El resumen de las coordenadas y la variable Ozono se presenta tabularmente en seguida:

```{r, message=FALSE, warning=FALSE}
temp <- as.geodata(datosT) 
pander::pander(summary(temp))
```

#### Análisis de Estacionariedad en Media

Ahora, se procede a revisar el comportamiento de la media de la variable con respecto a las coordenadas *Este* y *Norte*. Para entender de mejor manera la distribución de la variable ozono se presentan la matriz de correlación muestral y los siguientes gráficos:

::: panel-tabset
##### Matriz

```{r}
pander::pander(cor(datosT))
```

##### Gráficos de dispersión

```{r}
pT1 <- simple_scatter_plot(datosT, "Este", "Temperatura")
pT2 <- simple_scatter_plot(datosT, "Norte", "Temperatura")

cowplot::plot_grid(pT1,pT2)
```

##### GeoR

```{r}
plot(temp, qt.col = c("purple",
                    "pink",
                    "green",
                    "yellow"),
     scatter3d=T)
```
:::

En la matriz de correlaciones se observa una asociación notable entre la **temperatura** con la coordenada Norte. No obstante, esta relación no se aprecia de forma claramente lineal en el gráfico de dispersión, por lo que se opta por ajustar un polinomio con el fin de corregir la tendencia y capturar mejor la variación espacial de la variable.

##### Ajuste del Modelo

El modelo que mejor atrapa el efecto de la media es:

$$
Temperatura = \beta_0 + \beta_1 \times Norte + \beta_2 \times Norte^2
$$

```{r}
fitT <- lm(Temperatura~Norte+I(Norte^2), data = datosT) 
pander::pander(summary(fitT))
```

Todos los coeficientes del modelo son significativos. Sin embargo, el $R^2$ es relativamente bajo, por lo que se considera necesario verificar gráficamente si la tendencia espacial fue efectivamente mitigada.

::: panel-tabset
###### Gráficos de dispersión

```{r}
datosT$Residuos <- fitT$residuals

pT1 <- simple_scatter_plot(datosT, "Este", "Residuos")
pT2 <- simple_scatter_plot(datosT, "Norte", "Residuos")

cowplot::plot_grid(pT1,pT2)

```

###### GeoR

```{r}
plot(temp, qt.col = c("purple",
                    "pink",
                    "green",
                    "yellow"),
     scatter3d=T, trend=~Norte+I(Norte^2))
```
:::

Los gráficos evidencian que la tendencia existente entre la variable y la coordenada Norte ha sido mitigada, lo que indica que se ha logrado un ajuste adecuado del modelo.

#### Estudio del Semivariograma

##### Estimación Empírica del Semivariograma

A continuación, se presenta la estimación del semivariograma obtenida con la función `variog()`. Para asegurar la fiabilidad de los resultados, se especifican los argumentos `estimator.type = "modulus"` y `pairs.min=50`, con el fin de utilizar un estimador robusto y garantizar un número mínimo adecuado de pares en cada intervalo de distancia.

```{r, results='hide'}
vg_T <- variog(temp, estimator.type = "modulus", pairs.min=50) #Sin tendencia espacial

vg1_T <- variog(temp, trend = ~Norte+I(Norte^2),
                estimator.type = "modulus", pairs.min=50)

```

::: panel-tabset
###### Con tendencia

```{r}
plot(vg_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Sin remover tendencia",
     col.main = "#36648B", cex.main =1.3)
```

###### Removiendo tendencia

```{r}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Removiendo tendencia",
     col.main = "#36648B", cex.main =1.3)
```
:::

Cuando no se remueve la tendencia, la semivarianza alcanza valores más altos y presenta una forma aparentemente más regular, aunque dicha regularidad está influenciada por la tendencia global de los datos. En cambio, al eliminar la tendencia, los valores de semivarianza disminuyen y el patrón pierde suavidad, pero el variograma refleja con mayor fidelidad la verdadera dependencia espacial.

##### Estimación del Modelo Teórico de Semivariograma

Para obtener unos valores iniciales de los modelos teóricos se usa la función `EyeFit()` de la librería `GeoR`.

Los modelos obtenidos ajustando por `EyeFit()`, son:

> cov.model sigmasq phi tausq kappa kappa2 practicalRange
>
> 1 exponential 10.74 109166.3 2.07 NA NA 327033.0
>
> 2 gaussian 10.00 80000.0 2.07 NA NA 138465.5
>
> 3 spherical 10.00 157832.8 2.07 NA NA 157832.8

```{r, warning=FALSE, message=FALSE}

dist_matrix_T <- as.matrix(dist(temp$coords))

variog_T <- data.frame(h = vg1_T$u, gamma_hat = vg1_T$v,
                       n = vg1_T$n)

range_sv_T <- seq(1,max(variog_T$h), by=1000)

# Modelo exponencial ----

sigma_0_eT <- 10.74
phi_0_eT <- 109166.3
nugget_0_eT <- 2.07

par_eT <- c(sigma_0_eT, phi_0_eT, nugget_0_eT)

res_e_T <- est_sev_WLS(par=par_eT, kappa = NA,
                       model="exponencial",
                       h=variog_T$h,
                       gamma = variog_T$gamma_hat,
                       n = variog_T$n)

MLE_eT <- optim(fn = loglik,
             par = par_eT,
             kappa=NA,
             z = datosT$Residuos, 
             dist_matrix=dist_matrix_T,
             model = "exponencial",
             method = "L-BFGS-B",
             lower = c(0, 0, 0))

estsv_exp_Bess_T <- do.call(sv_exp, c(as.list(res_e_T$Bessel$Optimizados), list(h = range_sv_T)))
estsv_exp_n_T <- do.call(sv_exp, c(as.list(res_e_T$`1/n`$Optimizados), list(h = range_sv_T)))
estsv_exp_h_n_T <- do.call(sv_exp, c(as.list(res_e_T$`h/n`$Optimizados), list(h = range_sv_T)))
estsv_exp_MLE_T <- do.call(sv_exp, c(list(nugget = MLE_eT$par[3], phi = MLE_eT$par[2] , sigma = MLE_eT$par[1],h = range_sv_T)))

# Modelo Gaussiano ----

sigma_0_gT <- 10.00    
phi_0_gT <- 80000.0
nugget_0_gT <- 2.07

par_gT <- c(sigma_0_gT, phi_0_gT, nugget_0_gT)

res_g_T <- est_sev_WLS(par=par_gT, kappa = NA,
                       model="gaussian",
                       h=variog_T$h,
                       gamma = variog_T$gamma_hat,
                       n = variog_T$n)

estsv_g_Bess_T <- do.call(sv_gauss, c(as.list(res_g_T$Bessel$Optimizados), list(h = range_sv_T)))
estsv_g_n_T <- do.call(sv_gauss, c(as.list(res_g_T$`1/n`$Optimizados), list(h = range_sv_T)))
estsv_g_h_n_T <- do.call(sv_gauss, c(as.list(res_g_T$`h/n`$Optimizados), list(h = range_sv_T)))

# Modelo esférico

sigma_0_esT <- 10.00   
phi_0_esT <- 157832.8
nugget_0_esT <- 2.07

par_esT <- c(sigma_0_esT, phi_0_esT, nugget_0_esT)

res_es_T <- est_sev_WLS(par=par_esT, kappa = NA,
                       model="spherical",
                       h=variog_T$h,
                       gamma = variog_T$gamma_hat,
                       n = variog_T$n)

MLE_esT <- optim(fn = loglik,
             par = par_esT,
             kappa=NA,
             z = datosT$Residuos, 
             dist_matrix=dist_matrix_T,
             model = "spherical",
             method = "L-BFGS-B",
             lower = c(0, 0, 0))


estsv_es_Bess_T <- do.call(sv_spherical, c(as.list(res_es_T$Bessel$Optimizados), list(h = range_sv_T)))
estsv_es_n_T <- do.call(sv_spherical, c(as.list(res_es_T$`1/n`$Optimizados), list(h = range_sv_T)))
estsv_es_h_n_T <- do.call(sv_spherical, c(as.list(res_es_T$`h/n`$Optimizados), list(h = range_sv_T)))
estsv_es_MLE_T <- do.call(sv_spherical, c(list(nugget = MLE_esT$par[3], phi = MLE_esT$par[2] , sigma = MLE_esT$par[1],h = range_sv_T)))

```

:::::: panel-tabset
###### Exponencial

::: panel-tabset
####### Optim

```{r}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (optim)",
     col.main = "#36648B", cex.main =1.3)
lines(range_sv_T, estsv_exp_Bess_T, col="#FF4040", lwd=1.5)
lines(range_sv_T, estsv_exp_n_T, col="#4169E1", lwd=1.5)
lines(range_sv_T, estsv_exp_h_n_T, col="#008B00", lwd=1.5)
lines(range_sv_T, estsv_exp_MLE_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("Cressie", "1/n", "n/h", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

resumen_exp_T <- cbind(
  c("Cressie", "1/n", "n/h", "MLE"),
  rbind(
    t(res_e_T$Bessel$Optimizados),
    t(res_e_T$`1/n`$Optimizados),
    t(res_e_T$`h/n`$Optimizados),
    MLE_eT$par[c(3,1,2)]
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, res_e_T$Bessel$Optimizados, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_e_T$`1/n`$Optimizados, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_e_T$`h/n`$Optimizados, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, list(nugget = MLE_eT$par[3], phi = MLE_eT$par[2] , sigma = MLE_eT$par[1]), NA, model = "exponencial", variog_T$h)
  )
)

resumen_exp_T <- as.data.frame(resumen_exp_T)
resumen_exp_T[ , -1] <- lapply(resumen_exp_T[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_exp_T, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)
```

####### GeoR

```{r}
#| message: false
#| warning: false
#| results: 'hide'
ini1_exp_T <- c(sigma_0_eT, phi_0_eT)
fitvar1_exp_T <- variofit(vg1_T,
                    cov.model = "exponential",
                    ini1_exp_T,
                    fix.nugget = F,
                    nugget = nugget_0_eT,
                    wei = "equal")

fitvar2_exp_T <- variofit(vg1_T,
                    cov.model = "exponential",
                    ini1_exp_T,
                    fix.nugget = F,
                    nugget = nugget_0_eT,
                    wei = "npairs")

fitvar3_exp_T <- variofit(vg1_T,
                    cov.model = "exponential",
                    ini1_exp_T,
                    fix.nugget =F,
                    nugget = nugget_0_eT,
                    wei = "cressie")

fitvar4_exp_T <- likfit(temp,
                  coords = temp$coords,
                  data = temp$data,
                  trend = ~ poly(Norte, 2, raw = FALSE),
                  ini.cov.pars = ini1_exp_T,
                  fix.nugget = F,
                  nugget = nugget_0_eT,
                  cov.model = "exponential",
                  lik.method = "ML")


plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_exp_T, col="#FF4040", lwd=1.5)
lines(fitvar2_exp_T, col="#4169E1", lwd=1.5)
lines(fitvar3_exp_T, col="#008B00", lwd=1.5)
lines(fitvar4_exp_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

```

```{r}

par1Texp <- c(fitvar1_exp_T$nugget, fitvar1_exp_T$cov.pars[1], fitvar1_exp_T$cov.pars[2])
par2Texp <- c(fitvar2_exp_T$nugget, fitvar2_exp_T$cov.pars[1], fitvar2_exp_T$cov.pars[2])
par3Texp <- c(fitvar3_exp_T$nugget, fitvar3_exp_T$cov.pars[1], fitvar3_exp_T$cov.pars[2])
par4Texp <- c(fitvar4_exp_T$nugget, fitvar4_exp_T$cov.pars[1], fitvar4_exp_T$cov.pars[2])

resumen_exp_T2 <- cbind(
  c("MCO", "1/n", "Cressie","MLE"),
  rbind(
    par1Texp,
    par2Texp,
    par3Texp,
    par4Texp
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, par1Texp, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par2Texp, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par3Texp, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par4Texp, NA, model = "exponencial", variog_T$h)
  )
)

resumen_exp_T2 <- as.data.frame(resumen_exp_T2)
resumen_exp_T2[ , -1] <- lapply(resumen_exp_T2[ , -1], function(x) round(as.numeric(x), 3))
kable(resumen_exp_T2, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)

```
:::

###### Gaussiano

::: panel-tabset
####### Optim

```{r}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (optim)",
     col.main = "#36648B", cex.main =1.3)
lines(range_sv_T, estsv_g_Bess_T, col="#FF4040", lwd=1.5)
lines(range_sv_T, estsv_g_n_T, col="#4169E1", lwd=1.5)
lines(range_sv_T, estsv_g_h_n_T, col="#008B00", lwd=1.5)
legend("topleft",
       c("Cressie", "1/n", "n/h"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00"),
       cex=1,
       seg.len = .5)

resumen_g_T <- cbind(
  c("Cressie", "1/n", "n/h"),
  rbind(
    t(res_g_T$Bessel$Optimizados),
    t(res_g_T$`1/n`$Optimizados),
    t(res_g_T$`h/n`$Optimizados)
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, res_g_T$Bessel$Optimizados, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_g_T$`1/n`$Optimizados, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_g_T$`h/n`$Optimizados, NA, model = "gaussian", variog_T$h)
  )
)

resumen_g_T <- as.data.frame(resumen_g_T)
resumen_g_T[ , -1] <- lapply(resumen_g_T[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_g_T, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F)

```

####### GeoR

```{r}
#| message: false
#| warning: false
#| results: 'hide'
#| 
ini1_g_T <- c(sigma_0_gT, phi_0_gT)
fitvar1_g_T <- variofit(vg1_T,
                    cov.model = "gaussian",
                    ini1_g_T,
                    fix.nugget = F,
                    nugget = nugget_0_gT,
                    wei = "equal")

fitvar2_g_T <- variofit(vg1_T,
                    cov.model = "gaussian",
                    ini1_g_T,
                    fix.nugget = F,
                    nugget = nugget_0_gT,
                    wei = "npairs")

fitvar3_g_T <- variofit(vg1_T,
                    cov.model = "gaussian",
                    ini1_g_T,
                    fix.nugget = F,
                    nugget = nugget_0_gT,
                    wei = "cressie")

fitvar4_g_T <- likfit(temp,
                  coords = temp$coords,
                  data = temp$data,
                  trend = ~ poly(Norte, 2, raw = FALSE),
                  ini.cov.pars = ini1_g_T,
                  fix.nugget = F,
                  nugget = nugget_0_gT,
                  cov.model = "gaussian",
                  lik.method = "ML")


plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_g_T, col="#FF4040", lwd=1.5)
lines(fitvar2_g_T, col="#4169E1", lwd=1.5)
lines(fitvar3_g_T, col="#008B00", lwd=1.5)
lines(fitvar4_g_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)
```

```{r}
par1Tg <- c(fitvar1_g_T$nugget, fitvar1_g_T$cov.pars[1], fitvar1_g_T$cov.pars[2])
par2Tg <- c(fitvar2_g_T$nugget, fitvar2_g_T$cov.pars[1], fitvar2_g_T$cov.pars[2])
par3Tg <- c(fitvar3_g_T$nugget, fitvar3_g_T$cov.pars[1], fitvar3_g_T$cov.pars[2])
par4Tg <- c(fitvar4_g_T$nugget, fitvar4_g_T$cov.pars[1], fitvar4_g_T$cov.pars[2])

resumen_g_T2 <- cbind(
  c("MCO", "1/n", "Cressie","MLE"),
  rbind(
    par1Tg,
    par2Tg,
    par3Tg,
    par4Tg
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, par1Tg, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par2Tg, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par3Tg, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par4Tg, NA, model = "gaussian", variog_T$h)
  )
)

resumen_g_T2 <- as.data.frame(resumen_g_T2)
resumen_g_T2[ , -1] <- lapply(resumen_g_T2[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_g_T2, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)
```
:::

###### Esférico

::: panel-tabset
####### Optim

```{r}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (optim)",
     col.main = "#36648B", cex.main =1.3)
lines(range_sv_T, estsv_es_Bess_T, col="#FF4040", lwd=1.5)
lines(range_sv_T, estsv_es_n_T, col="#4169E1", lwd=1.5)
lines(range_sv_T, estsv_es_h_n_T, col="#008B00", lwd=1.5)
lines(range_sv_T, estsv_es_MLE_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("Cressie", "1/n", "n/h", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

resumen_es_T <- cbind(
  c("Cressie", "1/n", "n/h","MLE"),
  rbind(
    t(res_es_T$Bessel$Optimizados),
    t(res_es_T$`1/n`$Optimizados),
    t(res_es_T$`h/n`$Optimizados),
    MLE_esT$par[c(3,1,2)]
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, res_es_T$Bessel$Optimizados, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_es_T$`1/n`$Optimizados, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_es_T$`h/n`$Optimizados, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, list(nugget = MLE_esT$par[3], phi = MLE_esT$par[2] , sigma = MLE_esT$par[1]), NA, model = "spherical", variog_T$h)
  )
)

resumen_es_T <- as.data.frame(resumen_es_T)
resumen_es_T[ , -1] <- lapply(resumen_es_T[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_es_T, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F)
```

####### GeoR

```{r}
#| message: false
#| warning: false
#| results: 'hide'
#| 
ini1_es_T <- c(sigma_0_esT, phi_0_esT)
fitvar1_es_T <- variofit(vg1_T,
                    cov.model = "spherical",
                    ini1_es_T,
                    fix.nugget = F,
                    nugget = nugget_0_esT,
                    wei = "equal")

fitvar2_es_T <- variofit(vg1_T,
                    cov.model = "spherical",
                    ini1_es_T,
                    fix.nugget = F,
                    nugget = nugget_0_esT,
                    wei = "npairs")

fitvar3_es_T <- variofit(vg1_T,
                    cov.model = "spherical",
                    ini1_es_T,
                    fix.nugget = F,
                    nugget = nugget_0_esT,
                    wei = "cressie")

fitvar4_es_T <- likfit(temp,
                  coords = temp$coords,
                  data = temp$data,
                  trend = ~ poly(Norte, 2, raw = FALSE),
                  ini.cov.pars = ini1_es_T,
                  fix.nugget = F,
                  nugget = nugget_0_esT,
                  cov.model = "spherical",
                  lik.method = "ML")


plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_es_T, col="#FF4040", lwd=1.5)
lines(fitvar2_es_T, col="#4169E1", lwd=1.5)
lines(fitvar3_es_T, col="#008B00", lwd=1.5)
lines(fitvar4_es_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)



```

```{r}

par1Tes <- c(fitvar1_es_T$nugget, fitvar1_es_T$cov.pars[1], fitvar1_es_T$cov.pars[2])
par2Tes <- c(fitvar2_es_T$nugget, fitvar2_es_T$cov.pars[1], fitvar2_es_T$cov.pars[2])
par3Tes <- c(fitvar3_es_T$nugget, fitvar3_es_T$cov.pars[1], fitvar3_es_T$cov.pars[2])
par4Tes <- c(fitvar4_es_T$nugget, fitvar4_es_T$cov.pars[1], fitvar4_es_T$cov.pars[2])

resumen_es_T2 <- cbind(
  c("MCO", "1/n", "Cressie","MLE"),
  rbind(
    par1Tes,
    par2Tes,
    par3Tes,
    par4Tes
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, par1Tes, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par2Tes, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par3Tes, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par4Tes, NA, model = "spherical", variog_T$h)
  )
)

resumen_es_T2 <- as.data.frame(resumen_es_T2)
resumen_es_T2[ , -1] <- lapply(resumen_es_T2[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_es_T2, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)

```
:::
::::::

El modelo con menor MSE corresponde al modelo **Gaussiano**. No obstante, debido a la inestabilidad numérica observada durante el proceso de predicción, se opta por emplear el modelo **Esférico** ajustado mediante mínimos cuadrados ponderados con la ponderación $h/n$, el cual representa la segunda mejor alternativa en términos del MSE.

#### Kriging

El modelo **Esférico**, con los parámetros obtenidos por **WLS** usando la ponderación $h/n$, que se usará para realizar Kriging es el siguiente:

```{r, echo=FALSE}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Modelo Esférico para Temperatura",
     col.main = "#36648B", cex.main =1.3)
lines(range_sv_T, estsv_es_h_n_T, col="#008B00", lwd=1.5)

```

Para realizar la predicción, se genera una muestra aleatoria de puntos dentro del polígono que delimita el estado de California mediante la función `spsample()` del paquete `sp`. Sobre estos puntos se estiman los valores esperados aplicando el método de **Kriging de vecinos cercanos**, con el fin de mejorar la precisión de las estimaciones al considerar las grandes distancias características del territorio californiano. El procedimiento se implementa mediante la función `krige()` de `gstat`, especifícando la opción `nmin=20` y utilizando la función `predict()` de base de `R`.

```{r, message=F, warning=F, results='hide'}

#Se escoge el mejor modelo --------------------------------

best_model_T <- gstat::vgm(psill = res_es_T$`h/n`$Optimizados[2],
                           model = "Sph",
                           range = res_es_T$`h/n`$Optimizados[3],
                           nugget = res_es_T$`h/n`$Optimizados[1]
)

#Se crea un objeto en gstat -------------------------------

coordinates(datosT) <- ~Este + Norte
proj4string(datosT) <- CRS("EPSG:3310")

g_obj<-gstat::gstat(id="Temperatura",
             formula = Temperatura ~ Norte + I(Norte^2),
             model = best_model_T,
             data = datosT)

#Kriging -------------------------------------------------

suppressMessages(predic <- predict(g_obj, newdata = new, nmin = 20))

#Mapas de predicción --------------------------------------

gridded(predic) <- TRUE

#1. Mapa de Kriging ---------------------------------------

predic_raster_utm <- raster(predic, layer = "Temperatura.pred")

crs(predic_raster_utm) <- "+init=epsg:3310"

predic_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        predic_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

min_pred <- raster::cellStats(predic_raster_wgs84, stat='min')
max_pred <- raster::cellStats(predic_raster_wgs84, stat='max')

pred_range <- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))

step_pred <- (max_pred-min_pred)/ 6

bins <- round(seq(min_pred, max_pred, by=step_pred),0)

pal_pred <- colorBin(
  palette = "viridis", # La paleta de colores
  domain = pred_range,
  bins = bins,
  na.color = "transparent"
)

mapa_kriging_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    predic_raster_wgs84,
    colors = pal_pred, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
    addCircleMarkers(data = datosT_sf_wgs84,
                   fillColor = ~pal(Temperatura),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("Temp:", Temperatura, "°C")) %>% 
  addLegend(
    pal = pal_pred, 
    values = pred_range,
    title = "Predicción T (°C)",
    position = "topright"
  ) %>%
  addLegend(pal = pal,
            values = datosT_sf_wgs84$Temperatura,
            title = "Temperatura Observada",
    position = "topleft"
  ) 

#2 Mapa Varianza------------------------------------------

var_raster_utm <- raster(predic, layer = "Temperatura.var")

crs(var_raster_utm) <- "+init=epsg:3310"

var_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        var_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

max_var <- raster::cellStats(var_raster_wgs84, stat='max')
step_var <- max_var / 6

binsv <- round(seq(0, max_var, by=step_var),2)

var_range <- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))
pal_var <- colorBin(
  palette = "Spectral", # La paleta de colores
  domain = var_range,
  bins = binsv,
  na.color = "transparent"
)

mapa_var_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    var_raster_wgs84, 
    colors = pal_var, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_var, 
    values = var_range,
    title = "Varianza",
    position = "topright"
  ) 

#3. Mapa Cv ----------------------------------------------

cv_raster_utm <- sqrt(var_raster_utm) / abs(predic_raster_utm)

mapa_mayor_a_uno <- cv_raster_utm > 1
cv_raster_utm[mapa_mayor_a_uno] <- 1

crs(cv_raster_utm) <- "+init=epsg:3310"

cv_terra <- terra::rast(cv_raster_utm)

masked_cv_terra <- terra::mask(cv_terra, sh_terra)

cv_raster_wgs84_terra <- terra::project(
    masked_cv_terra, 
    y = "epsg:4326", 
    method = "bilinear" # Similar a projectRaster
)

cv_raster_wgs84 <- raster::raster(cv_raster_wgs84_terra)

max_cv <- raster::cellStats(cv_raster_wgs84, stat='max')
step_cv <- max_cv / 10

bincv <- seq(0,max_cv, by=step_cv)

cv_range <- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))

pal_cv <- colorBin(
  palette = "RdYlGn", # Rojo-Amarillo-Verde
  domain = cv_range,
  na.color = "transparent",
  bins = bincv,
  reverse = TRUE 
)

mapa_cv_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    cv_raster_wgs84, 
    colors = pal_cv, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  
  addLegend(
    pal = pal_cv, 
    values = cv_range,
    title = "Coeficiente de Variación",
    position = "topright"
  )

```

En el siguiente panel se presentan 3 mapas que resumen el proceso de predicción:

::: panel-tabset
##### Predicción

```{r}
mapa_kriging_leaflet
```

##### Varianza

```{r}
mapa_var_leaflet
```

##### Coeficiente de variación

```{r}
mapa_cv_leaflet
```
:::

Los mapas de kriging para la temperatura muestran que las zonas más cálidas y con predicciones más confiables se concentran en el sur de California y en el Valle Central. En contraste, las regiones con mayor incertidumbre (alta varianza y coeficiente de variación) se ubican principalmente en el extremo norte y a lo largo de las fronteras del estado.

Esta menor fiabilidad en el norte se debe a la escasa presencia de estaciones de monitoreo en esas extensas áreas. El modelo de semivarianza empleado **(Esférico)** presenta un rango de influencia de aproximadamente 175 km, lo que implica que las mediciones dejan de ser útiles para la predicción más allá de esa distancia. Aunque se aplicó un **Kriging de vecinos cercanos** para mitigar el efecto de estas grandes distancias, persiste un nivel considerable de incertidumbre en las zonas con baja densidad de observaciones

### Variable Velocidad del viento

En el siguiente mapa se presenta la distribución territorial de las estaciones de **Velocidad del Viento**, así mismo como sus valores muestrales:

```{r, message=F, warning=F}

y_WS <- WS[1,] #Tomar una fecha
y_WS <- cbind(colnames(y_WS),t(y_WS[1,]))
y_WS <- y_WS[-1,]
y_WS <- as.data.frame(y_WS)
y_WS <- na.omit(y_WS)
y_WS$V1 <- as.numeric(y_WS$V1)
y_WS <- inner_join(y_WS, EstacionesWS, by=c("V1"="AQSID"))
datosWS <- y_WS[,c(13,14,2)]
colnames(datosWS)=c("Este","Norte","WindSpeed")
datosWS$WindSpeed <- as.numeric(datosWS$WindSpeed)

datosWS_sf <- st_as_sf(datosWS, coords = c("Este", "Norte"), crs = 3310)

datosWS_sf_wgs84 <- st_transform(datosWS_sf, crs = 4326)

palWS <- colorNumeric(palette = "viridis", domain = datosWS_sf_wgs84$WindSpeed)

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = "black", weight = 2) %>%
  addCircleMarkers(data = datosWS_sf_wgs84,
                   fillColor = ~palWS(WindSpeed),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("WindSpeed:", WindSpeed, "m/s")) %>%
  addLegend(pal = palWS, values = datosWS_sf_wgs84$WindSpeed, title = "WindSpeed (m/s)")

```

Los datos observados son trabajados en el formato *geodata* mediante el uso de la función `as.geodata()` del paquete `GeoR`. El resumen de las coordenadas y la variable Ozono se presenta tabularmente en seguida:

```{r, warning=FALSE, message=FALSE}
ws <- as.geodata(datosWS)
pander::pander(summary(ws))
```

#### Análisis de Estacionariedad en Media

Ahora, se procede a revisar el comportamiento de la media de la variable con respecto a las coordenadas *Este* y *Norte*. Para entender de mejor manera la distribución de la variable ozono se presentan la matriz de correlación muestral y los siguientes gráficos:

::: panel-tabset
##### Matriz

```{r}
pander::pander(cor(datosWS))
```

##### Gráficos de dispersión

```{r}
pWS1 <- simple_scatter_plot(datosWS, "Este", "WindSpeed")
pWS2 <- simple_scatter_plot(datosWS, "Norte", "WindSpeed")

cowplot::plot_grid(pWS1,pWS2)

```

##### GeoR

```{r}
plot(ws, qt.col = c("purple",
                          "pink",
                          "green",
                          "yellow"),
     scatter3d=T)
```
:::

En la matriz de correlaciones no se aprecia una asociación fuerte ni evidente entre la **velocidad del viento** y las coordenadas espaciales. Sin embargo, los gráficos sugieren una posible relación, aunque débil, por lo que se explorarán distintos modelos hasta identificar aquel que describa mejor la tendencia observada.

##### Ajuste del Modelo

El modelo que mejor atrapa el efecto de la media es:

$$WindSpeed = \beta_0 + \beta_1 \times Este + \beta_2 \times Norte + \beta_3 \times Este \times Norte$$

```{r}
fitWS <- lm(WindSpeed~Este*Norte, data = datosWS) 
pander::pander(summary(fitWS))

```

Se observa que todos los coeficientes del modelo resultan estadísticamente significativos, y que el ajuste presenta un $R^2$ de 0.48, lo cual indica un nivel de explicación adecuado de la variabilidad de la velocidad del viento.

::: panel-tabset
###### Gráficos de dispersión

```{r}
datosWS$Residuos <- fitWS$residuals

pWS1 <- simple_scatter_plot(datosWS, "Este", "Residuos")
pWS2 <- simple_scatter_plot(datosWS, "Norte", "Residuos")

cowplot::plot_grid(pWS1,pWS2)

```

###### GeoR

```{r}
plot(temp, qt.col = c("purple",
                      "pink",
                      "green",
                      "yellow"),
     scatter3d=T, trend=~Norte*Este)
```
:::

En los gráficos se observa que el patrón asociado a las coordenadas se ha atenuado considerablemente, lo que sugiere que el modelo se ajustó de manera adecuada.

#### Estudio del Semivariograma

A continuación, se presenta la estimación del semivariograma obtenida con la función `variog()`. Para asegurar la fiabilidad de los resultados, se especifican los argumentos `estimator.type = "modulus"` y `pairs.min=50`, con el fin de utilizar un estimador robusto y garantizar un número mínimo adecuado de pares en cada intervalo de distancia.

##### Estimación Empírica del Semivariograma

```{r, message=FALSE, results='hide'}
vgO_WS <- variog(ws,estimator.type = "modulus", pairs.min=50) 

vg1_WS <- variog(ws, trend = ~Norte*Este,
                estimator.type = "modulus", pairs.min=50)
```

::: panel-tabset
###### Con tendencia

```{r}
plot(vgO_WS,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Sin remover tendencia",
     col.main = "#36648B", cex.main =1.3)
```

###### Removiendo Tendencia

```{r}
plot(vg1_WS,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Removiendo tendencia",
     col.main = "#36648B", cex.main =1.3)
```
:::

Se observa que la estimación de la varianza de la variable incrementos presenta valores más bajos al remover la tendencia, lo que indica que en este caso el semivariograma refleja de manera más adecuada la verdadera estructura espacial del fenómeno.

##### Estimación del Modelo Teórico de Semivariograma

Para obtener unos valores iniciales de los modelos teóricos se usa la función `EyeFit()` de la librería `GeoR`. Por su parte, para el modelo coseno se realizo una estimación a ojo mediante la construcción de una función `sv_cos()` basada en la literatura.

Los modelos obtenidos ajustando por `EyeFit()` y `sv_cos()`, son:

> cov.model sigmasq phi tausq kappa kappa2 practicalRange
>
> 1 cos 1.5 .6e5 1.5 NA NA NA
>
> 2 wave 3.5 .6e5 1.5 NA NA NA

La estimación de los parámetros del modelo **Wave** se hizo haciendo uso de las funciones `nls()` y `optim()` de `R`.

```{r}
#| message: false
#| warning: false
#| results: 'hide'

variog_WS <- data.frame(h = vg1_WS$u, gamma_hat = vg1_WS$v,
                       n = vg1_WS$n)

range_sv_WS <- seq(1,max(variog_WS$h), by=1000)

#Modelo Coseno---------------------------------------------

sigma_0_cosWS <- 1.5
phi_0_cosWS <- .6e5
nugget_0_cosWS <- 1.5

#MCO -------
I_pond_WS <- nls(formula = gamma_hat ~cos_sv(nugget, sigma, h, phi),
              start = c(nugget = nugget_0_cosWS, sigma = sigma_0_cosWS, phi = phi_0_cosWS),
              lower = rep(1e-6,3),
              data = variog_WS,
              control = nls.control(maxiter = 500, warnOnly = TRUE))

optim_I_WS <- optim(
  par = coef(I_pond_WS),
  fn = MSE_ponderados,
  h = variog_WS$h,
  gamma = variog_WS$gamma_hat,
  pesos = "I",
  model = "cos",
  n = n,
  method = "L-BFGS-B",
  lower = rep(1e-6,3)
)

par_optim_I_WS <- optim_I_WS$par[c("nugget", "sigma", "phi")]

estsv_cos_I_WS <- do.call(cos_sv, c(as.list(par_optim_I_WS), list(h = range_sv_WS)))


#WLS -------

par_cosWS <- c(sigma_0_cosWS, phi_0_cosWS, nugget_0_cosWS)

res_cos_WS <- est_sev_WLS(par=par_cosWS, kappa = NA,
                       model="cos",
                       h=variog_WS$h,
                       gamma = variog_WS$gamma_hat,
                       n = variog_WS$n)

estsv_cos_Bess_WS <- do.call(cos_sv, c(as.list(res_cos_WS$Bessel$Optimizados), list(h = range_sv_WS)))
estsv_cos_n_WS <- do.call(cos_sv, c(as.list(res_cos_WS$`1/n`$Optimizados), list(h = range_sv_WS)))
estsv_cos_h_n_WS <- do.call(cos_sv, c(as.list(res_cos_WS$`h/n`$Optimizados), list(h = range_sv_WS)))

#Modelo Wave ---------------------------------------------

nugget_0_wvWS <- 1.5

par_wvWS <- c(3.5,.6e5)

fitvar1_cos_WS <- variofit(vg1_WS,
                    cov.model = "wave",
                    par_wvWS,
                    fix.nugget = F,
                    nugget = nugget_0_wvWS,
                    wei = "equal")
fitvar2_cos_WS <- variofit(vg1_WS,
                    cov.model = "wave",
                    par_wvWS,
                    fix.nugget = F,
                    nugget = nugget_0_wvWS,
                    wei = "npairs")

fitvar3_cos_WS <- variofit(vg1_WS,
                    cov.model = "wave",
                    par_wvWS,
                    fix.nugget = F,
                    nugget = nugget_0_wvWS,
                    wei = "cressie")

fitvar4_cos_WS <- likfit(ws,
                       coords = ws$coords,
                       data = ws$data,
                       trend = ~ Este*Norte,
                       ini.cov.pars = par_wvWS,
                       fix.nugget = F,
                       nugget = nugget_0_wvWS,
                       cov.model = "wave",
                       lik.method = "ML")
```

::: panel-tabset
###### Coseno (Optim)

```{r}
plot(vg1_WS,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (optim)",
     col.main = "#36648B", cex.main =1.3)
lines(range_sv_WS, estsv_cos_Bess_WS, col="#FF4040", lwd=1.5)
lines(range_sv_WS, estsv_cos_n_WS, col="#4169E1", lwd=1.5)
lines(range_sv_WS, estsv_cos_h_n_WS, col="#008B00", lwd=1.5)
lines(range_sv_WS, estsv_cos_I_WS, col="#FFA500", lwd=1.5)
legend("topleft",
       c("Cressie", "1/n", "n/h", "MCO"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

resumen_cos_SV <- cbind(
  c("Cressie", "1/n", "n/h", "MCO"),
  rbind(
    t(res_cos_WS$Bessel$Optimizados),
    t(res_cos_WS$`1/n`$Optimizados),
    t(res_cos_WS$`h/n`$Optimizados),
    par_optim_I_WS
  ),
  MSE = c(
    MSE_sv(variog_WS$gamma_hat, res_cos_WS$Bessel$Optimizados, NA, model = "cos", variog_WS$h),
    MSE_sv(variog_WS$gamma_hat, res_cos_WS$`1/n`$Optimizados, NA, model = "cos", variog_WS$h),
    MSE_sv(variog_WS$gamma_hat, res_cos_WS$`h/n`$Optimizados, NA, model = "cos", variog_WS$h),
    MSE_sv(variog_WS$gamma_hat, par_optim_I_WS, NA, model = "cos", variog_WS$h)
  )
)

resumen_cos_SV <- as.data.frame(resumen_cos_SV)
resumen_cos_SV[ , -1] <- lapply(resumen_cos_SV[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_cos_SV, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)
```

###### Wave (GeoR)

```{r, message=FALSE, warning=FALSE}

plot(vg1_WS,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)

lines(fitvar1_cos_WS, col="#FF4040", lwd=1.5)
lines(fitvar2_cos_WS, col="#4169E1", lwd=1.5)
lines(fitvar3_cos_WS, col="#008B00", lwd=1.5)
lines(fitvar4_cos_WS, col="#FFA500", lwd=1.5)

legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

```

```{r}
par1WScos <- c(fitvar1_cos_WS$nugget, fitvar1_cos_WS$cov.pars[1], fitvar1_cos_WS$cov.pars[2])
par2WScos <- c(fitvar2_cos_WS$nugget, fitvar2_cos_WS$cov.pars[1], fitvar2_cos_WS$cov.pars[2])
par3WScos <- c(fitvar3_cos_WS$nugget, fitvar3_cos_WS$cov.pars[1], fitvar3_cos_WS$cov.pars[2])
par4WScos <- c(fitvar4_cos_WS$nugget, fitvar4_cos_WS$cov.pars[1], fitvar4_cos_WS$cov.pars[2])

resumen_wv_WS <- cbind(
  c("MCO", "1/n", "Cressie","MLE"),
  rbind(
    par1WScos,
    par2WScos,
    par3WScos,
    par4WScos
  ),
  MSE = c(
    MSE_sv(variog_WS$gamma_hat, par1WScos, NA, model = "wave", variog_WS$h),
    MSE_sv(variog_WS$gamma_hat, par2WScos, NA, model = "wave", variog_WS$h),
    MSE_sv(variog_WS$gamma_hat, par3WScos, NA, model = "wave", variog_WS$h),
    MSE_sv(variog_WS$gamma_hat, par4WScos, NA, model = "wave", variog_WS$h)
  )
)

resumen_wv_WS <- as.data.frame(resumen_wv_WS)
resumen_wv_WS[ , -1] <- lapply(resumen_wv_WS[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_wv_WS, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)

```
:::

Al comparar los valores del MSE, se determinó que el modelo más adecuado es el **Wave**, ajustado mediante el método de **WSL** con ponderación basada en el número de pares por distancia en el semivariograma.

#### Kriging

El modelo **Wave**, con los parámetros obtenidos por **WLS** usando la ponderación $1/n$, que se usará para realizar Kriging es el siguiente:

```{r, echo=FALSE}
plot(vg1_WS,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Modelo wave para WindSpeed",
     col.main = 4, cex.main =1.3)
lines(fitvar2_cos_WS, col="#4169E1", lwd=1.5)
```

Para realizar la predicción, se genera una muestra aleatoria de puntos dentro del polígono que delimita el estado de California mediante la función `spsample()` del paquete `sp`. Sobre estos puntos se estiman los valores esperados aplicando el método de **Kriging de vecinos cercanos**, con el fin de mejorar la precisión de las estimaciones al considerar las grandes distancias características del territorio californiano. El procedimiento se implementa mediante la función `krige()` de `gstat`, especifícando la opción `nmin=20` y utilizando la función `predict()` de base de `R`.

```{r, message=F, warning=F, results='hide'}

#Se escoge el mejor modelo --------------------------------

best_model_WS <- gstat::vgm(psill = par2WScos[2],
                           model = "Wav",
                           range = par2WScos[3],
                           nugget = par2WScos[1]
)

#Se crea un objeto en gstat -------------------------------

coordinates(datosWS) <- ~Este + Norte
proj4string(datosWS) <- CRS("EPSG:3310")

g_obj<-gstat::gstat(id="WindSpeed",
             formula = WindSpeed ~ Norte*Este,
             model = best_model_WS,
             data = datosWS)

#Kriging -------------------------------------------------

suppressMessages(predic <- predict(g_obj, newdata = new, nmin = 20))

#Mapas de predicción --------------------------------------

gridded(predic) <- TRUE

#1. Mapa de Kriging ---------------------------------------

predic_raster_utm <- raster(predic, layer = "WindSpeed.pred")

crs(predic_raster_utm) <- "+init=epsg:3310"

predic_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        predic_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

min_pred <- raster::cellStats(predic_raster_wgs84, stat='min')
max_pred <- raster::cellStats(predic_raster_wgs84, stat='max')

pred_range <- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))

step_pred <- (max_pred-min_pred)/ 6

bins <- round(seq(min_pred, max_pred, by=step_pred),0)

pal_pred <- colorBin(
  palette = "viridis", # La paleta de colores
  domain = pred_range,
  bins = bins,
  na.color = "transparent"
)

mapa_kriging_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    predic_raster_wgs84,
    colors = pal_pred, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
    addCircleMarkers(data = datosWS_sf_wgs84,
                   fillColor = ~palWS(WindSpeed),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("WS:", WindSpeed, "m/s")) %>% 
  addLegend(
    pal = pal_pred, 
    values = pred_range,
    title = "Predicción WS (m/s)",
    position = "topright"
  ) %>%
  addLegend(pal = palWS,
            values = datosWS_sf_wgs84$WindSpeed,
            title = "WS Observada",
    position = "topleft"
  ) 

#2 Mapa Varianza------------------------------------------

var_raster_utm <- raster(predic, layer = "WindSpeed.var")

crs(var_raster_utm) <- "+init=epsg:3310"

var_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        var_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

max_var <- raster::cellStats(var_raster_wgs84, stat='max')
step_var <- max_var / 6

binsv <- round(seq(0, max_var, by=step_var),2)

var_range <- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))
pal_var <- colorBin(
  palette = "Spectral", # La paleta de colores
  domain = var_range,
  bins = binsv,
  na.color = "transparent"
)

mapa_var_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    var_raster_wgs84, 
    colors = pal_var, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_var, 
    values = var_range,
    title = "Varianza",
    position = "topright"
  ) 

#3. Mapa Cv ----------------------------------------------

predic$cv <- sqrt(predic$WindSpeed.var) / pmax(abs(predic$WindSpeed.pred), 1e-6)

predic$cv[predic$cv > 1] <- 1

cv_raster_utm <- raster(predic, layer = "cv")

crs(cv_raster_utm) <- "+init=epsg:3310"

cv_terra <- terra::rast(cv_raster_utm)

masked_cv_terra <- terra::mask(cv_terra, sh_terra)

cv_raster_wgs84_terra <- terra::project(
    masked_cv_terra, 
    y = "epsg:4326", 
    method = "bilinear" # Similar a projectRaster
)

cv_raster_wgs84 <- raster::raster(cv_raster_wgs84_terra)

max_cv <- raster::cellStats(cv_raster_wgs84, stat='max')
step_cv <- max_cv / 10

bincv <- seq(0,max_cv, by=step_cv)

cv_range <- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))


pal_cv <- colorBin(
  palette = "RdYlGn", # Rojo-Amarillo-Verde
  domain = cv_range,
  na.color = "transparent",
  bins = bincv,
  reverse = TRUE 
)

mapa_cv_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    cv_raster_wgs84, 
    colors = pal_cv, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  
  addLegend(
    pal = pal_cv, 
    values = cv_range,
    title = "Coeficiente de Variación",
    position = "topright"
  )

```

En el siguiente panel se presentan 3 mapas que resumen el proceso de predicción:

::: panel-tabset
##### Predicción

```{r}
mapa_kriging_leaflet
```

##### Varianza

```{r}
mapa_var_leaflet
```

##### Coeficiente de variación

```{r}
mapa_cv_leaflet
```
:::

La velocidad del viento es más elevada en el Valle Central y en el interior sur de California, y, en general, las predicciones en la mitad sur del estado muestran buena precisión (bajo coeficiente de variación). La incertidumbre más alta se concentra en el extremo norte, debido a la escasez de datos. El modelo **Wave** se utiliza para capturar la naturaleza variable del viento; sin embargo, la varianza sigue siendo elevada en zonas con baja densidad de estaciones y en algunas áreas muestreadas donde el viento probablemente es más turbulento o errático, lo que dificulta la interpolación. Para mitigar el efecto de las grandes distancias entre estaciones, se aplicó un **Kriging de vecinos cercanos**, lo que mejora la fiabilidad de las predicciones en puntos aislados.

### Variable Presión Barométrica

En el siguiente mapa se presenta la distribución territorial de las estaciones de **Presión Barométrica**, así mismo como sus valores muestrales:

```{r, message=F, warning=F}

y_Pr <- Presion[1,] #Tomar una fecha
y_Pr <- cbind(colnames(y_Pr),t(y_Pr[1,]))
y_Pr <- y_Pr[-1,]
y_Pr <- as.data.frame(y_Pr)
y_Pr <- na.omit(y_Pr)
y_Pr$V1 <- as.numeric(y_Pr$V1)
y_Pr <- y_Pr[-which.min(y_Pr$V2),]
y_Pr <- y_Pr[-which.min(y_Pr$V2),]
y_Pr <- inner_join(y_Pr, EstacionesPr, by=c("V1"="AQSID"))
datosPr <- y_Pr[,c(13,14,2)]
colnames(datosPr)=c("Este","Norte","Presion")
datosPr$Presion <- as.numeric(datosPr$Presion)

datosPr_sf <- st_as_sf(datosPr, coords = c("Este", "Norte"), crs = 3310)

datosPr_sf_wgs84 <- st_transform(datosPr_sf, crs = 4326)

palPr <- colorNumeric(palette = "viridis", domain = datosPr_sf_wgs84$Presion)

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = "black", weight = 2) %>%
  addCircleMarkers(data = datosPr_sf_wgs84,
                   fillColor = ~palPr(Presion),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("Presion:", Presion, "mb")) %>%
  addLegend(pal = palPr, values = datosPr_sf_wgs84$Presion, title = "Presión Barométrica mb")

```

Los datos observados son trabajados en el formato *geodata* mediante el uso de la función `as.geodata()` del paquete `GeoR`. El resumen de las coordenadas y la variable Ozono se presenta tabularmente en seguida:

```{r, message=FALSE, warning=FALSE}
presion <- as.geodata(datosPr)
pander::pander(summary(presion))
```

#### Análisis de Estacionariedad en Media

Ahora, se procede a revisar el comportamiento de la media de la variable con respecto a las coordenadas *Este* y *Norte*. Para entender de mejor manera la distribución de la variable ozono se presentan la matriz de correlación muestral y los siguientes gráficos:

::: panel-tabset
##### Matriz

```{r}
pander::pander(cor(datosPr))
```

##### Gráficos de dispersión

```{r}
pPr1 <- simple_scatter_plot(datosPr, "Este", "Presion")
pPr2 <- simple_scatter_plot(datosPr, "Norte", "Presion")

cowplot::plot_grid(pPr1,pPr2)

```

##### GeoR

```{r}
plot(presion, qt.col = c("purple",
                          "pink",
                          "green",
                          "yellow"),
     scatter3d=T)
```
:::

En la matriz de correlaciones se aprecia una ligera asociación de la **presión** con la coordenada Este. No obstante, en los gráficos se observa una tendencia más evidente que involucra ambas coordenadas.

##### Ajuste del Modelo

El modelo que mejor atrapa el efecto de la media es:

$$Presion = \beta_0 + \beta_1 \times Este + \beta_2 \times Norte $$

```{r}
fitPr <- lm(Presion~Este+Norte, data=datosPr)
pander::pander(summary(fitPr))

```

Todos los coeficientes del modelo resultan estadísticamente significativos, y el valor de $R^2$ (0.65) indica que el ajuste captura de manera adecuada la variabilidad de la presión, sugiriendo que el modelo es apropiado.

::: panel-tabset
###### Gráficos de dispersión

```{r}
datosPr$Residuos <- fitPr$residuals

pPr1 <- simple_scatter_plot(datosPr, "Este", "Residuos")
pPr2 <- simple_scatter_plot(datosPr, "Norte", "Residuos")

cowplot::plot_grid(pPr1,pPr2)

```

###### GeoR

```{r}
plot(presion, qt.col = c("purple",
                      "pink",
                      "green",
                      "yellow"),
     scatter3d=T, trend=~Norte+Este)
```
:::

Los gráficos de dispersión corroboran los resultados del ajuste del modelo, mostrando que la tendencia respecto a las coordenadas espaciales se ha mitigado de buena manera.

#### Estudio del Semivariograma

A continuación, se presenta la estimación del semivariograma obtenida con la función `variog()`. Para asegurar la fiabilidad de los resultados, se especifican los argumentos `estimator.type = "modulus"` y `pairs.min=50`, con el fin de utilizar un estimador robusto y garantizar un número mínimo adecuado de pares en cada intervalo de distancia.

```{r, message=FALSE, results='hide'}
vgO_Pr <- variog(presion,estimator.type = "modulus", pairs.min=50) 

vg1_Pr <- variog(presion, trend = ~Norte+Este,
                estimator.type = "modulus", pairs.min=50)
```

::: panel-tabset
##### Con tendencia

```{r}
plot(vgO_Pr,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Sin remover tendencia",
     col.main = "#36648B", cex.main =1.3)
```

##### Removiendo Tendencia

```{r}
plot(vg1_Pr,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Removiendo tendencia",
     col.main = "#36648B", cex.main =1.3)
```
:::

##### Estimación del Modelo Teórico de Semivariograma

Para obtener unos valores iniciales de los modelos teóricos se usa la función `EyeFit()` de la librería `GeoR`.

El modelo obtenido ajustando por `EyeFit()`, son:

> cov.model sigmasq phi tausq kappa kappa2 practicalRange
>
> 1 exponential 1056.47 126360.8 132.06 NA NA 378543.2

###### Exponencial

```{r, message=FALSE, warning=FALSE, results='hide'}

variog_Pr <- data.frame(h = vg1_Pr$u, gamma_hat = vg1_Pr$v,
                       n = vg1_Pr$n)

nugget_0_ePr <- 132.06

par_ePr <- c(1056.47,126360.8)

fitvar1_exp_Pr <- variofit(vg1_Pr,
                    cov.model = "exponential",
                    par_ePr,
                    fix.nugget = F,
                    nugget = nugget_0_ePr,
                    wei = "equal")

fitvar2_exp_Pr <- variofit(vg1_Pr,
                    cov.model = "exponential",
                    par_ePr,
                    fix.nugget = F,
                    nugget = nugget_0_ePr,
                    wei = "npairs")

fitvar3_exp_Pr <- variofit(vg1_Pr,
                    cov.model = "exponential",
                    par_ePr,
                    fix.nugget = F,
                    nugget = nugget_0_ePr,
                    wei = "cressie")

fitvar4_exp_Pr <- likfit(presion,
                       coords = presion$coords,
                       data = presion$data,
                       trend = ~ Este+Norte,
                       ini.cov.pars = par_ePr,
                       fix.nugget = F,
                       nugget = nugget_0_ePr,
                       cov.model = "exponential",
                       lik.method = "ML")

plot(vg1_Pr,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_exp_Pr, col="#FF4040", lwd=1.5)
lines(fitvar2_exp_Pr, col="#4169E1", lwd=1.5)
lines(fitvar3_exp_Pr, col="#008B00", lwd=1.5)
lines(fitvar4_exp_Pr, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

```

```{r}
par1Prexp <- c(fitvar1_exp_Pr$nugget, fitvar1_exp_Pr$cov.pars[1], fitvar1_exp_Pr$cov.pars[2])
par2Prexp <- c(fitvar2_exp_Pr$nugget, fitvar2_exp_Pr$cov.pars[1], fitvar2_exp_Pr$cov.pars[2])
par3Prexp <- c(fitvar3_exp_Pr$nugget, fitvar3_exp_Pr$cov.pars[1], fitvar3_exp_Pr$cov.pars[2])
par4Prexp <- c(fitvar4_exp_Pr$nugget, fitvar4_exp_Pr$cov.pars[1], fitvar4_exp_Pr$cov.pars[2])

resumen_exp_Pr <- cbind(
  c("MCO", "1/n", "Cressie","MLE"),
  rbind(
    par1Prexp,
    par2Prexp,
    par3Prexp,
    par4Prexp
  ),
  MSE = c(
    MSE_sv(variog_Pr$gamma_hat, par1Prexp, NA, model = "exponencial", variog_Pr$h),
    MSE_sv(variog_Pr$gamma_hat, par2Prexp, NA, model = "exponencial", variog_Pr$h),
    MSE_sv(variog_Pr$gamma_hat, par3Prexp, NA, model = "exponencial", variog_Pr$h),
    MSE_sv(variog_Pr$gamma_hat, par4Prexp, NA, model = "exponencial", variog_Pr$h)
  )
)

resumen_exp_Pr <- as.data.frame(resumen_exp_Pr)
resumen_exp_Pr[ , -1] <- lapply(resumen_exp_Pr[ , -1], function(x) round(as.numeric(x), 3))
kable(resumen_exp_Pr, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)
```

#### Kriging

El modelo **Exponencial**, con los parámetros obtenidos por **MCO**, que se usará para realizar Kriging es el siguiente:

```{r}
plot(vg1_Pr,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Modelo exponencial para Presión",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_exp_Pr, col="#FF4040", lwd=1.5)


```

Para realizar la predicción, se genera una muestra aleatoria de puntos dentro del polígono que delimita el estado de California mediante la función `spsample()` del paquete `sp`. Sobre estos puntos se estiman los valores esperados aplicando el método de **Kriging de vecinos cercanos**, con el fin de mejorar la precisión de las estimaciones al considerar las grandes distancias características del territorio californiano. El procedimiento se implementa mediante la función `krige()` de `gstat`, especifícando la opción `nmin=20` y utilizando la función `predict()` de base de `R`.

```{r, message=F, warning=F, results='hide'}

#Se ajusta el mejor modelo -------------------------------

best_model_Pr <- gstat::vgm(psill = fitvar1_exp_Pr$cov.pars[1],
                           model = "Exp",
                           range = fitvar1_exp_Pr$cov.pars[2],
                           nugget = fitvar1_exp_Pr$nugget
                           
)

# Se crea un objeto en gstat ------------------------------

coordinates(datosPr) <- ~Este + Norte
proj4string(datosPr) <- CRS("EPSG:3310")

g_obj<-gstat::gstat(id="Presion",
             formula = Presion ~ Norte + Este,
             model = best_model_Pr,
             data = datosPr)

#Kriging ------------------------------------------------

invisible(predic <- predict(g_obj, newdata = new))


#Mapas de predicción -------------------------------------

gridded(predic) <- TRUE

#1. Mapa de Kriging --------------------------------------

predic_raster_utm <- raster(predic, layer = "Presion.pred")

crs(predic_raster_utm) <- "+init=epsg:3310"

predic_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        predic_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

min_pred <- raster::cellStats(predic_raster_wgs84, stat='min')
max_pred <- raster::cellStats(predic_raster_wgs84, stat='max')

pred_range <- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))

step_pred <- (max_pred-min_pred)/ 6

bins <- round(seq(min_pred, max_pred, by=step_pred),0)

pal_pred <- colorBin(
  palette = "viridis", # La paleta de colores
  domain = pred_range,
  bins = bins,
  na.color = "transparent"
)

mapa_kriging_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    predic_raster_wgs84, 
    colors = pal_pred, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
    addCircleMarkers(data = datosPr_sf_wgs84,
                   fillColor = ~palPr(Presion),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("Presión:", Presion, "mb")) %>% 
  
  addLegend(
    pal = pal_pred, 
    values = pred_range,
    title = "Predicción Presión mb",
    position = "topright"
  ) %>%
  
  addLegend(pal = palPr,
            values = datosPr_sf_wgs84$Presion,
            title = "Presión Observada",
    position = "topleft"
  ) 

#2 Mapa Varianza------------------------------------------

var_raster_utm <- raster(predic, layer = "Presion.var")

crs(var_raster_utm) <- "+init=epsg:3310"

var_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        var_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

max_var <- raster::cellStats(var_raster_wgs84, stat='max')
step_var <- max_var / 6

binsv <- round(seq(0, max_var, by=step_var),2)

var_range <- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))
pal_var <- colorBin(
  palette = "Spectral", # La paleta de colores
  domain = var_range,
  bins = binsv,
  na.color = "transparent"
)

mapa_var_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    var_raster_wgs84,
    colors = pal_var, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_var, 
    values = var_range,
    title = "Varianza",
    position = "topright"
  ) 

#3. Mapa Cv ----------------------------------------------

cv_raster_utm <- sqrt(var_raster_utm) / abs(predic_raster_utm)

mapa_mayor_a_uno <- cv_raster_utm > 1
cv_raster_utm[mapa_mayor_a_uno] <- 1

crs(cv_raster_utm) <- "+init=epsg:3310"

cv_terra <- terra::rast(cv_raster_utm)
sh_terra <- terra::vect(sh_mundos_sp_utm_simple)

masked_cv_terra <- terra::mask(cv_terra, sh_terra)

cv_raster_wgs84_terra <- terra::project(
    masked_cv_terra, 
    y = "epsg:4326", 
    method = "bilinear" # Similar a projectRaster
)

cv_raster_wgs84 <- raster::raster(cv_raster_wgs84_terra)

max_cv <- raster::cellStats(cv_raster_wgs84, stat='max')
step_cv <- max_cv / 10

bincv <- seq(0,max_cv, by=step_cv)

cv_range <- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))

pal_cv <- colorBin(
  palette = "RdYlGn", # Rojo-Amarillo-Verde
  domain = cv_range,
  na.color = "transparent",
  bins = bincv,
  reverse = TRUE
)

mapa_cv_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    cv_raster_wgs84,
    colors = pal_cv, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_cv, 
    values = cv_range,
    title = "Coeficiente de Variación",
    position = "topright"
  )

```

En el siguiente panel se presentan 3 mapas que resumen el proceso de predicción:

::: panel-tabset
##### Predicción

```{r}
mapa_kriging_leaflet
```

##### Varianza

```{r}
mapa_var_leaflet
```

##### Coeficiente de variación

```{r}
mapa_cv_leaflet
```
:::

La presión atmosférica es más alta en la costa y en el sur del estado, y más baja en las regiones de gran altitud del este y del norte. Aunque las predicciones presentan buena precisión (bajo CV) en el Valle Central y el sur, el mapa de varianza absoluta muestra valores elevados en estas mismas zonas. Esto indica que el modelo **Exponencial** está capturando una alta heterogeneidad local de la presión en áreas con abundantes datos, probablemente asociada a efectos topográficos o meteorológicos muy localizados. Por su parte, la incertidumbre relativa sigue siendo mayor en el norte debido a la escasez de estaciones de monitoreo; para mitigar el efecto de las grandes distancias entre puntos, se aplicó un **Kriging de vecinos cercanos**, mejorando la confiabilidad de las estimaciones en regiones con datos limitados.

## Conclusiones

1.  Se logró modelar y mitigar la tendencia espacial de todas las variables analizadas. Las correlaciones iniciales con las coordenadas (principalmente para temperatura y presión) se redujeron significativamente tras el ajuste de los modelos de media, evidenciado tanto en los gráficos de dispersión como en los coeficientes significativos de los modelos.

2.  Los modelos de semivariograma ajustados (Esférico, Wave y Exponencial según la variable) capturaron la dependencia espacial de manera adecuada. El uso del **Kriging de vecinos cercanos** permitió mitigar el efecto de las grandes distancias entre estaciones de monitoreo, mejorando la precisión en zonas con baja densidad de datos, aunque persistió incertidumbre relativa en el norte y áreas fronterizas.

3.  Las predicciones son más confiables en regiones con alta densidad de estaciones (sur y Valle Central), mientras que la varianza y el coeficiente de variación son mayores en el norte y en áreas rurales o fronterizas, reflejando la menor disponibilidad de datos y la complejidad local de ciertas variables (como la velocidad del viento y la presión).

4.  La temperatura es más alta en el sur del estado y en el Valle Central, mientras que la presión atmosférica alcanza valores mayores en la costa y el sur, y menores en las zonas de gran altitud del norte y este. La velocidad del viento muestra máximos en el Valle Central y el interior sur, reflejando la heterogeneidad espacial del comportamiento atmosférico en California.

5.  El enfoque geoestadístico permitió cumplir los objetivos planteados: se identificaron patrones espaciales, se estimaron semivariogramas y se ajustaron modelos teóricos adecuados, y se construyeron mapas de predicción y de incertidumbre que representan de manera confiable la distribución espacial de las variables. Esto demuestra que la metodología es útil para caracterizar la variabilidad espacial de variables meteorológicas y contaminantes como el ozono, incluso en territorios extensos como California

# Referencias {.unnumbered}
