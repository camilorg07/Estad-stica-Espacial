[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Estadística Espacial",
    "section": "",
    "text": "Contenido\nEn este documento tiene como objetivo ilustrar el recorrido de la implementación de la metodología y teoría vista durante el curso de Estadística Espacial. Se implementaran modelos de análisis geoestadístico univariados y bivariados, modelos de análisis espacio-temporal y de datos funcionales.",
    "crumbs": [
      "Contenido"
    ]
  },
  {
    "objectID": "Geo_uni.html",
    "href": "Geo_uni.html",
    "title": "1  Análisis Univariado",
    "section": "",
    "text": "1.1 Planteamiento del problema",
    "crumbs": [
      "Análisis Geoestadístico",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Análisis Univariado</span>"
    ]
  },
  {
    "objectID": "Geo_uni.html#descripción",
    "href": "Geo_uni.html#descripción",
    "title": "1  Análisis Univariado",
    "section": "1.2 Descripción",
    "text": "1.2 Descripción\nLos datos objeto de este estudio provienen de la Agencia de Protección Ambiental (EPA) de los Estados Unidos y corresponden a registros horarios obtenidos de las estaciones de monitoreo durante el mes de marzo de 2024. En partícular, se analizan las variables Temperatura y Ozono (O_3).\n\n1.2.1 Unidades\n\nTemperatura: Medido en grados celsius (C°) con una intensidad horaria.\nOzono: Medido en partes por billón (ppb) con una intensidad horaria.\n\n\n\nVer código\n#Librerias necesarias ------------------------------------\n\nset.seed(123)\n\nlibrary(dplyr)\nlibrary(geoR)\nlibrary(sp)\nlibrary(readxl)\nlibrary(tidyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(raster)\nlibrary(stars)\nlibrary(terra)\n\n#Variale Temperatura --------------------------------------\n\nTemp &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Temperatura\")\ncolnames(Temp)[-1] &lt;- as.numeric(colnames(Temp)[-1])\nEstacionesT &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesT &lt;- EstacionesT %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesT &lt;- EstacionesT %&gt;% filter(AQSID %in% colnames(Temp)[-1])\n\n#Variable Ozono ------------------------------------------\n\nOzono &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Ozono\")\ncolnames(Ozono)[-1] &lt;- as.numeric(colnames(Ozono)[-1])\nEstacionesOz &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesOz &lt;- EstacionesOz %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesOz &lt;- EstacionesOz %&gt;% filter(AQSID %in% colnames(Ozono)[-1])\n\n#Variable velocidad del viento ----------------------------\n\nWS &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"WindSpeed\")\ncolnames(WS)[-1] &lt;- as.numeric(colnames(WS)[-1])\nEstacionesWS &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesWS &lt;- EstacionesWS %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesWS &lt;- EstacionesWS %&gt;% filter(AQSID %in% colnames(WS)[-1])\n\n#Variable presión atmosférica -----------------------------\n\nPresion &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Presion\")\ncolnames(Presion)[-1] &lt;- as.numeric(colnames(Presion)[-1])\nEstacionesPr &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesPr &lt;- EstacionesPr %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesPr &lt;- EstacionesPr %&gt;% filter(AQSID %in% colnames(Presion)[-1])\n\n\n#Para el mapa de California -------------------------------\n\nsh_mundos&lt;-st_read(\"admin00.shp\",quiet=TRUE)\nsh_mundos &lt;- sh_mundos %&gt;% filter(CNTRY_NAME==\"United States\")\nsh_mundos &lt;- sh_mundos %&gt;% filter(ADMIN_NAME==\"California\")\n\nCRS_UTM_NY = \"+init=epsg:3310\"\n\nsh_mundos_wgs84 &lt;- st_transform(sh_mundos, crs = 4326)\n\nsh_mundos_utm &lt;- st_transform(sh_mundos, crs = CRS(\"EPSG:3310\"))\n\nsh_mundos_sp_utm &lt;- as(sh_mundos_utm, \"Spatial\")\n\nsh_mundos_utm_simple &lt;- st_union(sh_mundos_utm)\nsh_mundos_sp_utm_simple &lt;- as(sh_mundos_utm_simple, \"Spatial\")\n\n#Grilla para hacer kriging ------------------------------\n\nnew &lt;- sp::spsample(as(sh_mundos_utm, \"Spatial\"), n = 50000, type = \"regular\")\n\nproj4string(new) &lt;- CRS(\"EPSG:3310\")\ninvisible(coordinates(new) ~ Este + Norte)\ncolnames(new@coords) &lt;- c(\"Este\", \"Norte\")\n\n#Gráficos de dispersión ----------------------------------\n\nsimple_scatter_plot &lt;- function(datos, variable1, variable2) {\n\n    plot1 &lt;- ggplot(as.data.frame(datos),\n                    aes(x = .data[[variable1]], y = .data[[variable2]],\n                               color = as.factor(1))) +\n                    geom_point() +\n                    scale_colour_viridis_d() +\n                    labs(\n                        x = variable1,\n                        y = variable2\n                        ) +\n                    theme_light() +\n                    theme(legend.position = \"none\")\n\n    return(plot1)\n\n}\n\n#1. Funciones de correlación, covarianza y semivarianza: ------------------------\n\n#1.1 Modelo exponencial ----\n\nrho_exp &lt;- function(h, phi){\n  exp(-(h/phi)) #Correlacion espacial\n}\n\ncov_exp &lt;- function(sigma, h, phi){\n  sigma*rho_exp(h, phi) #Covarianza espacial\n}\n\nsv_exp &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_exp(sigma, h, phi) #Semivarianza espacial\n} \n\n#1.2 Modelo Gaussianio ----\n\nrho_gauss &lt;- function(h, phi){\n  exp(-(h/phi)^2)\n}\n\ncov_gauss &lt;- function(sigma, h, phi){\n  sigma*rho_gauss(h, phi) #Covarianza espacial\n}\n\nsv_gauss &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_gauss(sigma, h, phi) #Semivarianza espacial\n}\n#1.3 Modelo Gneting ----\n\ncov_gneiting &lt;- function(sigma, h, phi){\n  s &lt;- 1/phi\n  x &lt;- h *s\n  cov &lt;- ifelse(\n    0 &lt;= x & x &lt;= 1,\n    sigma*(1 + 8*x + 25*x^2 + 32*x^3) * (1 - x)^8,\n    0\n  )\n  return(cov)\n}\n\nsv_gneiting &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_gneiting(sigma, h, phi) #Semivarianza espacial\n}\n\n#1.4 Modelo Spherical ----\n\nrho_spherical &lt;- function(h, phi){\n  ifelse(h&lt;phi,\n         1 - 1.5*(h/phi) + 0.5*(h/phi)^3,\n         0)\n}\n\ncov_spherical &lt;- function(sigma, h, phi){\n  sigma*rho_spherical(h, phi) #Covarianza espacial\n}\n\nsv_spherical &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_spherical(sigma, h, phi) #Semivarianza espacial\n}\n\n#1.5 Modelo Matern ----\n\nrho_matern &lt;- function(h, phi, kappa){\n  (1/(2*gamma(kappa))) * (h/phi)^kappa * besselK((h/phi), kappa)\n}\n\ncov_matern &lt;- function(sigma, h, phi, kappa){\n  sigma*rho_matern(h, phi, kappa) #Covarianza espacial\n}\n\nsv_matern &lt;- function(nugget, sigma, h, phi, kappa){\n  nugget + sigma - cov_matern(sigma, h, phi, kappa) #Semivarianza espacial\n}\n\n#1.6 Modelo Coseno -----------------\n\ncov_cos &lt;- function(sigma, h, phi){\n  sigma * cos(h/phi)\n}\n\ncos_sv &lt;- function(nugget, sigma, h, phi){\n  nugget +  sigma *(1 - cos(2*pi*h/phi))\n}\n\n#1.7 Modelo wave ------\n\n\nrho_wave &lt;- function(h, sigma, phi){\n  ifelse(h == 0,\n         1,\n         (phi / h) * sin(h / phi))\n}\n\nsv_wave &lt;- function(nugget, sigma, h, phi) {\n  ifelse(h == 0,\n         nugget,\n         nugget + sigma - sigma * (phi / h) * sin(h / phi))\n}\n\ncov_wave &lt;- function(h, sigma, phi, nugget) {\n  ifelse(h == 0,\n         sigma,\n         sigma * (phi / h) * sin(h / phi))\n}\n\n\n#2. Función para estimar por WLS----\n\nMSE_ponderados &lt;- function(par, h, gamma,kappa=NA,w, model, n, pesos){\n  nugget &lt;- par[1]\n  sigma &lt;- par[2]\n  phi &lt;- par[3]\n  \n  gamma_hat &lt;- switch(model,\n                      \"exponencial\" = sv_exp(nugget, sigma, h, phi),\n                      \"gaussian\"    = sv_gauss(nugget, sigma, h, phi),\n                      \"gneiting\"    = sv_gneiting(nugget, sigma, h, phi),\n                      \"spherical\"   = sv_spherical(nugget, sigma, h, phi),\n                      \"matern\"      = sv_matern(nugget, sigma, h, phi, kappa),\n                      \"cos\"         = cos_sv(nugget, sigma, h, phi)\n  )\n  \n  w &lt;- switch(pesos,\n              \"Cressie\" = 1/(2*(2*gamma_hat)^2/n),\n              \"n\" = 1/n,\n              \"h/n\" = 1/(h/n),\n              \"I\" = 1)\n  \n  sum(w*(gamma - gamma_hat)^2)\n}\n\n\nest_sev_WLS &lt;- function(par, kappa = NA, model, h, gamma, n){\n  sigma_0 &lt;- par[1]\n  phi_0 &lt;- par[2]\n  nugget_0 &lt;- par[3]\n  kappa_0 &lt;- kappa\n  \n  # Selección de función\n  sv &lt;- switch(model,\n               \"exponencial\" = sv_exp,\n               \"gaussian\"    = sv_gauss,\n               \"spherical\"   = sv_spherical,\n               \"gneiting\"    = sv_gneiting,\n               \"matern\"      = sv_matern,\n               \"cos\" = cos_sv\n  )\n  \n  args_sv &lt;- names(formals(sv))\n  \n  args_list &lt;- list(\n    nugget = nugget_0,\n    sigma  = sigma_0,\n    h      = h,\n    phi    = phi_0,\n    kappa  = kappa_0\n  )\n  \n  args_list &lt;- args_list[names(args_list) %in% args_sv]\n  \n  sv_ini &lt;- do.call(sv, args_list)\n  \n  formula_sv &lt;- switch(model,\n                       \"gneiting\" = gamma ~ sv(nugget, sigma, h),\n                       \"matern\" = gamma ~ sv(nugget, sigma, h, phi, kappa),\n                       gamma ~ sv(nugget, sigma, h, phi)\n  )\n  \n  start_list &lt;- switch(model,\n                       \"gneting\" = list(nugget = nugget_0, sigma = sigma_0),\n                       \"matern\" = list(nugget = nugget_0, sigma = sigma_0, phi = phi_0, kappa = kappa_0),\n                       list(nugget = nugget_0, sigma = sigma_0, phi = phi_0)\n  )\n    \n    #1. Ponderación de Bessel\n    \n    WW &lt;- (2*(2*sv_ini)^2/n)\n    \n    Bessel &lt;- nls(formula = formula_sv,\n                  start = start_list,\n                  weights = 1/WW,\n                  lower = c(0, rep(1e-6, length(start_list)-1)),\n                  control = nls.control(maxiter = 500, warnOnly = TRUE))\n    \n    ini_Bessel&lt;-coef(Bessel)\n    \n    #1.1 Optim Bessel\n    \n    optim_bessel &lt;- optim(\n      par = coef(Bessel),\n      fn = MSE_ponderados,\n      h = h,\n      gamma = gamma,\n      pesos = \"Cressie\",\n      model = model,\n      n = n,\n      method = \"L-BFGS-B\",\n      lower = c(0, rep(1e-6, length(start_list)-1))\n    )\n    \n    par_optim_Bess &lt;- optim_bessel$par[c(\"nugget\", \"sigma\", \"phi\")]\n    \n    #2. Ponderación 1/n\n    \n    W1 &lt;- n\n    \n    n_pond &lt;- nls(formula = formula_sv,\n                  start = start_list,\n                  weights = 1/W1,\n                  lower = c(0, rep(1e-6, length(start_list)-1)),\n                  control = nls.control(maxiter = 500, warnOnly = TRUE))\n    \n    ini_n&lt;-coef(n_pond)\n    \n    #2.1 Optimización 1/n\n    \n    optim_n &lt;- optim(\n      par = coef(n_pond),\n      fn = MSE_ponderados,\n      h = h,\n      gamma = gamma,\n      pesos = \"n\",\n      n = n,\n      model = model,\n      method = \"L-BFGS-B\",\n      lower = c(0, rep(1e-6, length(start_list)-1))\n    )    \n    \n    par_optim_n &lt;- optim_n$par[c(\"nugget\", \"sigma\", \"phi\")]\n    \n    \n    #3. Ponderación h/n\n    \n    W2 &lt;- h/n\n    \n    h_n_pond &lt;- nls(formula = formula_sv,\n                    start = start_list,\n                    weights = 1/W2,\n                    lower = c(0, rep(1e-6, length(start_list)-1)),\n                    control = nls.control(maxiter = 500, warnOnly = TRUE))\n    \n    ini_h_n&lt;-coef(h_n_pond)\n    \n    optim_h_n &lt;- optim(\n      par = coef(h_n_pond),\n      fn = MSE_ponderados,\n      h = h,\n      gamma = gamma,\n      pesos = \"h/n\",\n      model = model,\n      n = n,\n      method = \"L-BFGS-B\",\n      lower = c(0, rep(1e-6, length(start_list)-1))\n    )    \n    \n    par_optim_h_n &lt;- optim_h_n$par[c(\"nugget\", \"sigma\", \"phi\")]\n    \n\nres &lt;- list(Bessel = list(Iniciales = ini_Bessel,\n                           Optimizados = par_optim_Bess),\n            `1/n` = list(Iniciales = ini_n,\n                          Optimizados = par_optim_n),\n            `h/n` = list(Iniciales = ini_h_n,\n                          Optimizados = par_optim_h_n))    \nreturn(res)\n}\n\nMSE_sv &lt;- function(gamma_hat, par, kappa, model, h){\n  sigma_0 &lt;- par[[2]]\n  phi_0 &lt;- par[[3]]\n  nugget_0 &lt;- par[[1]]\n  kappa_0 &lt;- kappa\n  \n  sv &lt;- switch(model,\n               \"exponencial\" = sv_exp,\n               \"gaussian\"    = sv_gauss,\n               \"spherical\"   = sv_spherical,\n               \"gneiting\"    = sv_gneiting,\n               \"matern\"      = sv_matern,\n               \"cos\" = cos_sv,\n               \"wave\" = sv_wave\n  )\n  \n  args_sv &lt;- names(formals(sv))\n  \n  args_list &lt;- list(\n    nugget = nugget_0,\n    sigma  = sigma_0,\n    h      = h,\n    phi    = phi_0,\n    kappa  = kappa_0\n  )\n  \n  args_list &lt;- args_list[names(args_list) %in% args_sv]\n  \n  sv_est &lt;- do.call(sv, args_list)\n  \n  return(mean((sv_est-gamma_hat)^2))\n}\n\n#3. Función para etimar por máxima verosimilitud\n\nloglik &lt;- function(par, kappa=NA, z, dist_matrix, model){\n  sigma_0 &lt;- par[1]\n  phi_0 &lt;- par[2]\n  nugget_0 &lt;- par[3]\n  kappa_0 &lt;- kappa\n  \n  cov &lt;- switch(model,\n               \"exponencial\" = cov_exp,\n               \"gaussian\"    = cov_gauss,\n               \"spherical\"   = cov_spherical,\n               \"gneiting\"    = cov_gneiting,\n               \"matern\"      = cov_matern\n  )\n  \n  args_cov &lt;- names(formals(cov))\n  \n  args_list &lt;- list(\n    sigma  = sigma_0,\n    nugget = nugget_0,\n    h      = dist_matrix,\n    phi    = phi_0,\n    kappa  = kappa_0\n  )\n  \n  args_list &lt;- args_list[names(args_list) %in% args_cov]\n  \n  Sigma &lt;- do.call(cov, args_list) \n  diag(Sigma) = diag(Sigma) + nugget_0\n  \n  # Descomposición de Cholesky (más estable que solve o det)\n  inv_Sigma &lt;- solve(Sigma)\n  det &lt;- log(det(Sigma))\n  \n  # Log-verosimilitud del modelo Gaussiano\n  z &lt;- z \n  n &lt;- length(z)\n  ll &lt;- -0.5 * (n * log(2 * pi) + det + crossprod(z, inv_Sigma %*% z))  # Log-verosimilitud (negativa porque optim minimiza)\n  return(-ll)\n}",
    "crumbs": [
      "Análisis Geoestadístico",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Análisis Univariado</span>"
    ]
  },
  {
    "objectID": "Geo_uni.html#análisis-geoestadístico",
    "href": "Geo_uni.html#análisis-geoestadístico",
    "title": "1  Análisis Univariado",
    "section": "1.2 Análisis geoestadístico",
    "text": "1.2 Análisis geoestadístico\nEn el análisis se consideran los datos de todas las variables registrados a las 00:00 horas del 1 de marzo de 2024.\n\n\nVer código\n#Librerias necesarias ------------------------------------\n\nset.seed(123)\n\nlibrary(dplyr)\nlibrary(geoR)\nlibrary(sp)\nlibrary(readxl)\nlibrary(tidyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(raster)\nlibrary(stars)\nlibrary(terra)\n\n#Variale Temperatura --------------------------------------\n\nTemp &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Temperatura\")\ncolnames(Temp)[-1] &lt;- as.numeric(colnames(Temp)[-1])\nEstacionesT &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesT &lt;- EstacionesT %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesT &lt;- EstacionesT %&gt;% filter(AQSID %in% colnames(Temp)[-1])\n\n#Variable Ozono ------------------------------------------\n\nOzono &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Ozono\")\ncolnames(Ozono)[-1] &lt;- as.numeric(colnames(Ozono)[-1])\nEstacionesOz &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesOz &lt;- EstacionesOz %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesOz &lt;- EstacionesOz %&gt;% filter(AQSID %in% colnames(Ozono)[-1])\n\n#Variable velocidad del viento ----------------------------\n\nWS &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"WindSpeed\")\ncolnames(WS)[-1] &lt;- as.numeric(colnames(WS)[-1])\nEstacionesWS &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesWS &lt;- EstacionesWS %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesWS &lt;- EstacionesWS %&gt;% filter(AQSID %in% colnames(WS)[-1])\n\n#Variable presión atmosférica -----------------------------\n\nPresion &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Presion\")\ncolnames(Presion)[-1] &lt;- as.numeric(colnames(Presion)[-1])\nEstacionesPr &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesPr &lt;- EstacionesPr %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesPr &lt;- EstacionesPr %&gt;% filter(AQSID %in% colnames(Presion)[-1])\n\n\n#Para el mapa de California -------------------------------\n\nsh_mundos&lt;-st_read(\"admin00.shp\",quiet=TRUE)\nsh_mundos &lt;- sh_mundos %&gt;% filter(CNTRY_NAME==\"United States\")\nsh_mundos &lt;- sh_mundos %&gt;% filter(ADMIN_NAME==\"California\")\n\nCRS_UTM_NY = \"+init=epsg:3310\"\n\nsh_mundos_wgs84 &lt;- st_transform(sh_mundos, crs = 4326)\n\nsh_mundos_utm &lt;- st_transform(sh_mundos, crs = CRS(\"EPSG:3310\"))\n\nsh_mundos_sp_utm &lt;- as(sh_mundos_utm, \"Spatial\")\n\nsh_mundos_utm_simple &lt;- st_union(sh_mundos_utm)\nsh_mundos_sp_utm_simple &lt;- as(sh_mundos_utm_simple, \"Spatial\")\n\n#Grilla para hacer kriging ------------------------------\n\nnew &lt;- sp::spsample(as(sh_mundos_utm, \"Spatial\"), n = 50000, type = \"regular\")\n\nproj4string(new) &lt;- CRS(\"EPSG:3310\")\ninvisible(coordinates(new) ~ Este + Norte)\ncolnames(new@coords) &lt;- c(\"Este\", \"Norte\")\n\n#Gráficos de dispersión ----------------------------------\n\nsimple_scatter_plot &lt;- function(datos, variable1, variable2) {\n\n    plot1 &lt;- ggplot(as.data.frame(datos),\n                    aes(x = .data[[variable1]], y = .data[[variable2]],\n                               color = as.factor(1))) +\n                    geom_point() +\n                    scale_colour_viridis_d() +\n                    labs(\n                        x = variable1,\n                        y = variable2\n                        ) +\n                    theme_light() +\n                    theme(legend.position = \"none\")\n\n    return(plot1)\n\n}\n\n#1. Funciones de correlación, covarianza y semivarianza: ------------------------\n\n#1.1 Modelo exponencial ----\n\nrho_exp &lt;- function(h, phi){\n  exp(-(h/phi)) #Correlacion espacial\n}\n\ncov_exp &lt;- function(sigma, h, phi){\n  sigma*rho_exp(h, phi) #Covarianza espacial\n}\n\nsv_exp &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_exp(sigma, h, phi) #Semivarianza espacial\n} \n\n#1.2 Modelo Gaussianio ----\n\nrho_gauss &lt;- function(h, phi){\n  exp(-(h/phi)^2)\n}\n\ncov_gauss &lt;- function(sigma, h, phi){\n  sigma*rho_gauss(h, phi) #Covarianza espacial\n}\n\nsv_gauss &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_gauss(sigma, h, phi) #Semivarianza espacial\n}\n#1.3 Modelo Gneting ----\n\ncov_gneiting &lt;- function(sigma, h, phi){\n  s &lt;- 1/phi\n  x &lt;- h *s\n  cov &lt;- ifelse(\n    0 &lt;= x & x &lt;= 1,\n    sigma*(1 + 8*x + 25*x^2 + 32*x^3) * (1 - x)^8,\n    0\n  )\n  return(cov)\n}\n\nsv_gneiting &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_gneiting(sigma, h, phi) #Semivarianza espacial\n}\n\n#1.4 Modelo Spherical ----\n\nrho_spherical &lt;- function(h, phi){\n  ifelse(h&lt;phi,\n         1 - 1.5*(h/phi) + 0.5*(h/phi)^3,\n         0)\n}\n\ncov_spherical &lt;- function(sigma, h, phi){\n  sigma*rho_spherical(h, phi) #Covarianza espacial\n}\n\nsv_spherical &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_spherical(sigma, h, phi) #Semivarianza espacial\n}\n\n#1.5 Modelo Matern ----\n\nrho_matern &lt;- function(h, phi, kappa){\n  (1/(2*gamma(kappa))) * (h/phi)^kappa * besselK((h/phi), kappa)\n}\n\ncov_matern &lt;- function(sigma, h, phi, kappa){\n  sigma*rho_matern(h, phi, kappa) #Covarianza espacial\n}\n\nsv_matern &lt;- function(nugget, sigma, h, phi, kappa){\n  nugget + sigma - cov_matern(sigma, h, phi, kappa) #Semivarianza espacial\n}\n\n#1.6 Modelo Coseno -----------------\n\ncov_cos &lt;- function(sigma, h, phi){\n  sigma * cos(h/phi)\n}\n\ncos_sv &lt;- function(nugget, sigma, h, phi){\n  nugget +  sigma *(1 - cos(2*pi*h/phi))\n}\n\n#1.7 Modelo wave ------\n\n\nrho_wave &lt;- function(h, sigma, phi){\n  ifelse(h == 0,\n         1,\n         (phi / h) * sin(h / phi))\n}\n\nsv_wave &lt;- function(nugget, sigma, h, phi) {\n  ifelse(h == 0,\n         nugget,\n         nugget + sigma - sigma * (phi / h) * sin(h / phi))\n}\n\ncov_wave &lt;- function(h, sigma, phi, nugget) {\n  ifelse(h == 0,\n         sigma,\n         sigma * (phi / h) * sin(h / phi))\n}\n\n\n#2. Función para estimar por WLS----\n\nMSE_ponderados &lt;- function(par, h, gamma,kappa=NA,w, model, n, pesos){\n  nugget &lt;- par[1]\n  sigma &lt;- par[2]\n  phi &lt;- par[3]\n  \n  gamma_hat &lt;- switch(model,\n                      \"exponencial\" = sv_exp(nugget, sigma, h, phi),\n                      \"gaussian\"    = sv_gauss(nugget, sigma, h, phi),\n                      \"gneiting\"    = sv_gneiting(nugget, sigma, h, phi),\n                      \"spherical\"   = sv_spherical(nugget, sigma, h, phi),\n                      \"matern\"      = sv_matern(nugget, sigma, h, phi, kappa),\n                      \"cos\"         = cos_sv(nugget, sigma, h, phi)\n  )\n  \n  w &lt;- switch(pesos,\n              \"Cressie\" = 1/(2*(2*gamma_hat)^2/n),\n              \"n\" = 1/n,\n              \"h/n\" = 1/(h/n),\n              \"I\" = 1)\n  \n  sum(w*(gamma - gamma_hat)^2)\n}\n\n\nest_sev_WLS &lt;- function(par, kappa = NA, model, h, gamma, n){\n  sigma_0 &lt;- par[1]\n  phi_0 &lt;- par[2]\n  nugget_0 &lt;- par[3]\n  kappa_0 &lt;- kappa\n  \n  # Selección de función\n  sv &lt;- switch(model,\n               \"exponencial\" = sv_exp,\n               \"gaussian\"    = sv_gauss,\n               \"spherical\"   = sv_spherical,\n               \"gneiting\"    = sv_gneiting,\n               \"matern\"      = sv_matern,\n               \"cos\" = cos_sv\n  )\n  \n  args_sv &lt;- names(formals(sv))\n  \n  args_list &lt;- list(\n    nugget = nugget_0,\n    sigma  = sigma_0,\n    h      = h,\n    phi    = phi_0,\n    kappa  = kappa_0\n  )\n  \n  args_list &lt;- args_list[names(args_list) %in% args_sv]\n  \n  sv_ini &lt;- do.call(sv, args_list)\n  \n  formula_sv &lt;- switch(model,\n                       \"gneiting\" = gamma ~ sv(nugget, sigma, h),\n                       \"matern\" = gamma ~ sv(nugget, sigma, h, phi, kappa),\n                       gamma ~ sv(nugget, sigma, h, phi)\n  )\n  \n  start_list &lt;- switch(model,\n                       \"gneting\" = list(nugget = nugget_0, sigma = sigma_0),\n                       \"matern\" = list(nugget = nugget_0, sigma = sigma_0, phi = phi_0, kappa = kappa_0),\n                       list(nugget = nugget_0, sigma = sigma_0, phi = phi_0)\n  )\n    \n    #1. Ponderación de Bessel\n    \n    WW &lt;- (2*(2*sv_ini)^2/n)\n    \n    Bessel &lt;- nls(formula = formula_sv,\n                  start = start_list,\n                  weights = 1/WW,\n                  lower = c(0, rep(1e-6, length(start_list)-1)),\n                  control = nls.control(maxiter = 500, warnOnly = TRUE))\n    \n    ini_Bessel&lt;-coef(Bessel)\n    \n    #1.1 Optim Bessel\n    \n    optim_bessel &lt;- optim(\n      par = coef(Bessel),\n      fn = MSE_ponderados,\n      h = h,\n      gamma = gamma,\n      pesos = \"Cressie\",\n      model = model,\n      n = n,\n      method = \"L-BFGS-B\",\n      lower = c(0, rep(1e-6, length(start_list)-1))\n    )\n    \n    par_optim_Bess &lt;- optim_bessel$par[c(\"nugget\", \"sigma\", \"phi\")]\n    \n    #2. Ponderación 1/n\n    \n    W1 &lt;- n\n    \n    n_pond &lt;- nls(formula = formula_sv,\n                  start = start_list,\n                  weights = 1/W1,\n                  lower = c(0, rep(1e-6, length(start_list)-1)),\n                  control = nls.control(maxiter = 500, warnOnly = TRUE))\n    \n    ini_n&lt;-coef(n_pond)\n    \n    #2.1 Optimización 1/n\n    \n    optim_n &lt;- optim(\n      par = coef(n_pond),\n      fn = MSE_ponderados,\n      h = h,\n      gamma = gamma,\n      pesos = \"n\",\n      n = n,\n      model = model,\n      method = \"L-BFGS-B\",\n      lower = c(0, rep(1e-6, length(start_list)-1))\n    )    \n    \n    par_optim_n &lt;- optim_n$par[c(\"nugget\", \"sigma\", \"phi\")]\n    \n    \n    #3. Ponderación h/n\n    \n    W2 &lt;- h/n\n    \n    h_n_pond &lt;- nls(formula = formula_sv,\n                    start = start_list,\n                    weights = 1/W2,\n                    lower = c(0, rep(1e-6, length(start_list)-1)),\n                    control = nls.control(maxiter = 500, warnOnly = TRUE))\n    \n    ini_h_n&lt;-coef(h_n_pond)\n    \n    optim_h_n &lt;- optim(\n      par = coef(h_n_pond),\n      fn = MSE_ponderados,\n      h = h,\n      gamma = gamma,\n      pesos = \"h/n\",\n      model = model,\n      n = n,\n      method = \"L-BFGS-B\",\n      lower = c(0, rep(1e-6, length(start_list)-1))\n    )    \n    \n    par_optim_h_n &lt;- optim_h_n$par[c(\"nugget\", \"sigma\", \"phi\")]\n    \n\nres &lt;- list(Bessel = list(Iniciales = ini_Bessel,\n                           Optimizados = par_optim_Bess),\n            `1/n` = list(Iniciales = ini_n,\n                          Optimizados = par_optim_n),\n            `h/n` = list(Iniciales = ini_h_n,\n                          Optimizados = par_optim_h_n))    \nreturn(res)\n}\n\nMSE_sv &lt;- function(gamma_hat, par, kappa, model, h){\n  sigma_0 &lt;- par[[2]]\n  phi_0 &lt;- par[[3]]\n  nugget_0 &lt;- par[[1]]\n  kappa_0 &lt;- kappa\n  \n  sv &lt;- switch(model,\n               \"exponencial\" = sv_exp,\n               \"gaussian\"    = sv_gauss,\n               \"spherical\"   = sv_spherical,\n               \"gneiting\"    = sv_gneiting,\n               \"matern\"      = sv_matern,\n               \"cos\" = cos_sv,\n               \"wave\" = sv_wave\n  )\n  \n  args_sv &lt;- names(formals(sv))\n  \n  args_list &lt;- list(\n    nugget = nugget_0,\n    sigma  = sigma_0,\n    h      = h,\n    phi    = phi_0,\n    kappa  = kappa_0\n  )\n  \n  args_list &lt;- args_list[names(args_list) %in% args_sv]\n  \n  sv_est &lt;- do.call(sv, args_list)\n  \n  return(mean((sv_est-gamma_hat)^2))\n}\n\n#3. Función para etimar por máxima verosimilitud\n\nloglik &lt;- function(par, kappa=NA, z, dist_matrix, model){\n  sigma_0 &lt;- par[1]\n  phi_0 &lt;- par[2]\n  nugget_0 &lt;- par[3]\n  kappa_0 &lt;- kappa\n  \n  cov &lt;- switch(model,\n               \"exponencial\" = cov_exp,\n               \"gaussian\"    = cov_gauss,\n               \"spherical\"   = cov_spherical,\n               \"gneiting\"    = cov_gneiting,\n               \"matern\"      = cov_matern\n  )\n  \n  args_cov &lt;- names(formals(cov))\n  \n  args_list &lt;- list(\n    sigma  = sigma_0,\n    nugget = nugget_0,\n    h      = dist_matrix,\n    phi    = phi_0,\n    kappa  = kappa_0\n  )\n  \n  args_list &lt;- args_list[names(args_list) %in% args_cov]\n  \n  Sigma &lt;- do.call(cov, args_list) \n  diag(Sigma) = diag(Sigma) + nugget_0\n  \n  # Descomposición de Cholesky (más estable que solve o det)\n  inv_Sigma &lt;- solve(Sigma)\n  det &lt;- log(det(Sigma))\n  \n  # Log-verosimilitud del modelo Gaussiano\n  z &lt;- z \n  n &lt;- length(z)\n  ll &lt;- -0.5 * (n * log(2 * pi) + det + crossprod(z, inv_Sigma %*% z))  # Log-verosimilitud (negativa porque optim minimiza)\n  return(-ll)\n}\n\n\n\n1.2.1 Variable Ozono\nEn el siguiente mapa se presenta la distribución territorial de las estaciones de Ozono, así mismo como sus valores muestrales:\n\n\nVer código\ny_oz &lt;- Ozono[1,] #Tomar una fecha\ny_oz &lt;- cbind(colnames(y_oz),t(y_oz[1,]))\ny_oz &lt;- y_oz[-1,]\ny_oz &lt;- as.data.frame(y_oz)\ny_oz &lt;- na.omit(y_oz)\ny_oz$V1 &lt;- as.numeric(y_oz$V1)\ny_oz &lt;- inner_join(y_oz, EstacionesOz, by=c(\"V1\"=\"AQSID\"))\ndatosOZ &lt;- y_oz[,c(13,14,2)] #DatosOz es la base con coordenadas + variable\ncolnames(datosOZ)=c(\"Este\",\"Norte\",\"Ozono\")\ndatosOZ$Ozono &lt;- as.numeric(datosOZ$Ozono)\n\ndatosOZ_sf &lt;- st_as_sf(datosOZ, coords = c(\"Este\", \"Norte\"), crs = 3310)\n\ndatosO_sf_wgs84 &lt;- st_transform(datosOZ_sf, crs = 4326)\n\npalO &lt;- colorNumeric(palette = \"viridis\", domain = datosO_sf_wgs84$Ozono)\n\nleaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = \"black\", weight = 2) %&gt;%\n  addCircleMarkers(data = datosO_sf_wgs84,\n                   fillColor = ~palO(Ozono),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"Ozono:\", Ozono, \"°C\")) %&gt;%\n  addLegend(pal = palO, values = datosO_sf_wgs84$Ozono, title = \"Ozono (ppb)\")\n\n\n\n\n\n\nLos datos observados son trabajados en el formato geodata mediante el uso de la función as.geodata() del paquete GeoR. El resumen de las coordenadas y la variable Ozono se presenta tabularmente en seguida:\n\n\nVer código\nozone &lt;- as.geodata(datosOZ) \npander::pander(summary(ozone))\n\n\n\nn: 139\ncoords.summary:\n\n\n\n\n\n\n\n\n \nEste\nNorte\n\n\n\n\nmin\n-276541\n-598934\n\n\nmax\n500862\n415184\n\n\n\ndistances.summary:\n\n\n\n\n\n\n\nmin\nmax\n\n\n\n\n6305\n1187480\n\n\n\ndata.summary:\n\n\n\n\n\n\n\n\n\n\n\nMin.\n1st Qu.\nMedian\nMean\n3rd Qu.\nMax.\n\n\n\n\n20\n35\n38\n37.48\n40.5\n53\n\n\n\n\n\n\n\n\n1.2.1.1 Análisis de Estacionariedad en Media\nAhora, se procede a revisar el comportamiento de la media de la variable con respecto a las coordenadas Este y Norte. Para entender de mejor manera la distribución de la variable ozono se presentan la matriz de correlación muestral y los siguientes gráficos:\n\nMatrizGráficos de dispersiónGeoR\n\n\n\n\nVer código\npander::pander(cor(datosOZ))\n\n\n\n\n\n\n\n\n\n\n\n \nEste\nNorte\nOzono\n\n\n\n\nEste\n1\n-0.8322\n0.5718\n\n\nNorte\n-0.8322\n1\n-0.4797\n\n\nOzono\n0.5718\n-0.4797\n1\n\n\n\n\n\n\n\n\n\nVer código\npO1 &lt;- simple_scatter_plot(datosOZ, \"Este\", \"Ozono\")\npO2 &lt;- simple_scatter_plot(datosOZ, \"Norte\", \"Ozono\")\n\ncowplot::plot_grid(pO1,pO2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(ozone, qt.col = c(\"purple\",\n                          \"pink\",\n                          \"green\",\n                          \"yellow\"),\n     scatter3d=T)\n\n\n\n\n\n\n\n\n\n\n\n\nEn el gráfico se observa una relación polinomial de la variable Ozono con respecto a las coordenadas en Norte, mientras que con respecto a las coordenadas en Este se observa una correlación lineal. Se prueba con varios modelos hasta encontrar aquel que mitigue el efecto espacial de mejor manera.\n\n1.2.1.1.1 Ajuste del Modelo\nEl modelo que mejor atrapa el efecto de la media es:\nOzono = \\beta_0+\\beta_1 \\times Norte^2 + \\beta_2 \\times Norte^3 + \\beta_3 \\times Este\n\n\nVer código\nfitO &lt;- lm(Ozono~I(Norte^2)+I(Norte^3)+Este, data = datosOZ) \npander::pander(summary(fitO))\n\n\n\n\n\n\n\n\n\n\n\n\n \nEstimate\nStd. Error\nt value\nPr(&gt;|t|)\n\n\n\n\n(Intercept)\n34.99\n0.6033\n58\n2.656e-97\n\n\nI(Norte^2)\n5.085e-11\n1.078e-11\n4.716\n5.931e-06\n\n\nI(Norte^3)\n7.94e-17\n1.922e-17\n4.131\n6.297e-05\n\n\nEste\n1.416e-05\n3.326e-06\n4.257\n3.855e-05\n\n\n\n\nFitting linear model: Ozono ~ I(Norte^2) + I(Norte^3) + Este\n\n\n\n\n\n\n\n\nObservations\nResidual Std. Error\nR^2\nAdjusted R^2\n\n\n\n\n139\n3.984\n0.4223\n0.4094\n\n\n\n\n\nSe observa que todos los coeficientes del modelo resultan estadísticamente significativos. Además, aunque el valor de R^2 (0.42) no es particularmente alto, es lo suficientemente representativo como para considerar que el ajuste del modelo fue adecuado y aporta información relevante sobre el fenómeno analizado.\n\nGráficos de dispersiónGeoR\n\n\n\n\nVer código\ndatosOZ$Residuos &lt;- fitO$residuals\n\npO1 &lt;- simple_scatter_plot(datosOZ, \"Este\", \"Residuos\")\npO2 &lt;- simple_scatter_plot(datosOZ, \"Norte\", \"Residuos\")\n\ncowplot::plot_grid(pO1,pO2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(ozone, qt.col = c(\"purple\",\n                          \"pink\",\n                          \"green\",\n                          \"yellow\"),\n     scatter3d=T, trend = ~ poly(Norte,3))\n\n\n\n\n\n\n\n\n\n\n\n\nEn los gráficos de dispersión, usando ggplot y geoR, se aprecia también una notable mitigación del efecto de las coordenadas sobre la variable ozono, lo que sugiere que la estructura espacial de la media fue modelada de manera adecuada..\n\n\n\n1.2.1.2 Estudio del Semivariograma\n\n1.2.1.2.1 Estimación Empírica del Semivariograma\nA continuación, se presenta la estimación del semivariograma obtenida con la función variog(). Para asegurar la fiabilidad de los resultados, se especifican los argumentos estimator.type = \"modulus\" y pairs.min=50, con el fin de utilizar un estimador robusto y garantizar un número mínimo adecuado de pares en cada intervalo de distancia.\n\n\nVer código\nvg_O &lt;- variog(ozone,estimator.type = \"modulus\", pairs.min=50) #Sin tendencia espacial\n\nvg1_O &lt;- variog(ozone, trend = ~I(Norte^2)+I(Norte^3)+Este, estimator.type = \"modulus\", pairs.min=50)\n\n\n\nCon tendenciaRemoviendo Tendencia\n\n\n\n\nVer código\nplot(vg_O,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Sin remover tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(vg1_O,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Removiendo tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\nSe observa que la estimación de la varianza de la variable incrementos es más estable y presenta valores más bajos al remover la tendencia, lo que indica que en este caso el semivariograma refleja de manera más adecuada la verdadera estructura espacial del fenómeno.\n\n\n1.2.1.2.2 Estimación del Modelo Teórico de Semivariograma\nPara obtener unos valores iniciales de los modelos teóricos se usa la función EyeFit() de la librería GeoR.\nLos modelos obtenidos ajustando por EyeFit(), son:\n\ncov.model sigmasq phi tausq kappa kappa2 practicalRange\n1 matern 17.0 440676.0 5 0.5 NA 1320147\n2 gneiting 17.5 803585.6 9 NA NA 1371348\n3 exponential 10 6e5 10 NA NA 1320147\n\n\nMaternGneitingExponencial\n\n\n\n\nVer código\nvariog_O &lt;- data.frame(h = vg1_O$u, gamma_hat = vg1_O$v,\n                       n = vg1_O$n)\n\nsigma_0_mO &lt;- 12.0\nphi_0_mO &lt;- 224249.7\nnugget_0_mO &lt;- 2.00 \nkappa_0_mO &lt;- 0.2\n\nini1_mat_O &lt;- c(sigma_0_mO, phi_0_mO)\nfitvar1_mat_O &lt;- variofit(vg1_O,\n                    cov.model = \"matern\",\n                    ini1_mat_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_mO,\n                    kappa = kappa_0_mO,\n                    wei = \"equal\")\n\nfitvar2_mat_O &lt;- variofit(vg1_O,\n                    cov.model = \"matern\",\n                    ini1_mat_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_mO,\n                    kappa = kappa_0_mO,\n                    wei = \"npairs\")\n\nfitvar3_mat_O &lt;- variofit(vg1_O,\n                    cov.model = \"matern\",\n                    ini1_mat_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_mO,\n                    kappa = kappa_0_mO,\n                    wei = \"cressie\")\n\nfitvar4_mat_O &lt;- likfit(ozone,\n                  coords = ozone$coords,\n                  data = ozone$data,\n                  trend = ~ I(Norte^2) + I(Norte^3) + Este,\n                  ini.cov.pars = ini1_mat_O,\n                  fix.nugget = F,\n                  nugget = nugget_0_mO,\n                  kappa = kappa_0_mO,\n                  cov.model = \"matern\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_O,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_mat_O, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_mat_O, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_mat_O, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_mat_O, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Om &lt;- c(fitvar1_mat_O$nugget, fitvar1_mat_O$cov.pars[1], fitvar1_mat_O$cov.pars[2], fitvar1_mat_O$kappa)\npar2Om &lt;- c(fitvar2_mat_O$nugget, fitvar2_mat_O$cov.pars[1], fitvar2_mat_O$cov.pars[2],fitvar2_mat_O$kappa)\npar3Om &lt;- c(fitvar3_mat_O$nugget, fitvar3_mat_O$cov.pars[1], fitvar3_mat_O$cov.pars[2],fitvar3_mat_O$kappa)\npar4Om &lt;- c(fitvar4_mat_O$nugget, fitvar4_mat_O$cov.pars[1], fitvar4_mat_O$cov.pars[2],fitvar4_mat_O$kappa)\n\nresumen_O_m &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1Om,\n    par2Om,\n    par3Om,\n    par4Om\n  ),\n  MSE = c(\n    mean((par1Om[1]+par1Om[2]-cov.spatial(variog_O$h, cov.model = \"matern\", cov.pars = par1Om[c(2,3)], kappa = par1Om[4])-variog_O$gamma_hat)^2),\n    mean((par2Om[1]+par2Om[2]-cov.spatial(variog_O$h, cov.model = \"matern\", cov.pars = par2Om[c(2,3)], kappa = par2Om[4])-variog_O$gamma_hat)^2),\n    mean((par3Om[1]+par3Om[2]-cov.spatial(variog_O$h, cov.model = \"matern\", cov.pars = par3Om[c(2,3)], kappa = par3Om[4])-variog_O$gamma_hat)^2),\n     mean((par4Om[1]+par4Om[2]-cov.spatial(variog_O$h, cov.model = \"matern\", cov.pars = par4Om[c(2,3)], kappa = par4Om[4])-variog_O$gamma_hat)^2)\n  )\n)\n\nresumen_O_m &lt;- as.data.frame(resumen_O_m)\nresumen_O_m[ , -1] &lt;- lapply(resumen_O_m[ , -1], function(x) round(as.numeric(x), 3))\nkable(resumen_O_m, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"Kappa\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nKappa\nMSE\n\n\n\n\nMCO\n1.863\n53.490\n13147381.6\n0.2\n5.475\n\n\n1/n\n3.789\n35.449\n8696936.7\n0.2\n7.114\n\n\nCressie\n2.872\n12.025\n224249.7\n0.2\n14.639\n\n\nMLE\n0.000\n68.806\n224249.7\n0.2\n2216.497\n\n\n\n\n\n\n\n\n\nVer código\nsigma_0_gO &lt;- 17.5\nphi_0_gO &lt;- 803585.6\nnugget_0_gO &lt;- 9\n\nini1_g_O &lt;- c(sigma_0_gO, phi_0_gO)\nfitvar1_g_O &lt;- variofit(vg1_O,\n                    cov.model = \"gneiting\",\n                    ini1_g_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_gO,\n                    wei = \"equal\")\n\nfitvar2_g_O &lt;- variofit(vg1_O,\n                    cov.model = \"gneiting\",\n                    ini1_g_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_gO,\n                    wei = \"npairs\")\n\nfitvar3_g_O &lt;- variofit(vg1_O,\n                    cov.model = \"gneiting\",\n                    ini1_g_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_gO,\n                    wei = \"cressie\")\n\nfitvar4_g_O &lt;- likfit(ozone,\n                  coords = ozone$coords,\n                  data = ozone$data,\n                  trend = ~ I(Norte^2) + I(Norte^3) + Este,\n                  ini.cov.pars = ini1_g_O,\n                  fix.nugget = F,\n                  nugget = nugget_0_gO,\n                  cov.model = \"gneiting\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_O,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_g_O, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_g_O, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_g_O, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_g_O, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Og &lt;- c(fitvar1_g_O$nugget, fitvar1_g_O$cov.pars[1], fitvar1_g_O$cov.pars[2])\npar2Og &lt;- c(fitvar2_g_O$nugget, fitvar2_g_O$cov.pars[1], fitvar2_g_O$cov.pars[2])\npar3Og &lt;- c(fitvar1_g_O$nugget, fitvar3_g_O$cov.pars[1], fitvar3_g_O$cov.pars[2])\npar4Og &lt;- c(fitvar4_g_O$nugget, fitvar4_g_O$cov.pars[1], fitvar4_g_O$cov.pars[2])\n\nresumen_O_g &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1Og,\n    par2Og,\n    par3Og,\n    par4Og\n  ),\n  MSE = c(\n    mean((par1Og[1]+par1Og[2]-cov.spatial(variog_O$h, cov.model = \"gneiting\", cov.pars = par1Og[c(2,3)])-variog_O$gamma_hat)^2),\n    mean((par2Og[1]+par2Og[2]-cov.spatial(variog_O$h, cov.model = \"gneiting\", cov.pars = par2Og[c(2,3)])-variog_O$gamma_hat)^2),\n    mean((par3Og[1]+par3Og[2]-cov.spatial(variog_O$h, cov.model = \"gneiting\", cov.pars = par3Og[c(2,3)])-variog_O$gamma_hat)^2),\n     mean((par4Og[1]+par4Og[2]-cov.spatial(variog_O$h, cov.model = \"gneiting\", cov.pars = par4Og[c(2,3)])-variog_O$gamma_hat)^2)\n  )\n)\n\nresumen_O_g &lt;- as.data.frame(resumen_O_g)\nresumen_O_g[ , -1] &lt;- lapply(resumen_O_g[ , -1], function(x) round(as.numeric(x), 3))\nkable(resumen_O_g, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n9.591\n17.140\n855834.6\n2.836\n\n\n1/n\n10.024\n172.640\n3276275.0\n3.696\n\n\nCressie\n9.591\n14.366\n803585.6\n3.260\n\n\nMLE\n14.000\n506.520\n803587.0\n45739.365\n\n\n\n\n\n\n\n\n\nVer código\nsigma_0_lO &lt;- 10\nphi_0_lO &lt;- 6e5\nnugget_0_lO &lt;- 10\n\nini1_l_O &lt;- c(sigma_0_lO, phi_0_lO)\nfitvar1_l_O &lt;- variofit(vg1_O,\n                    cov.model = \"exponential\",\n                    ini1_l_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_lO,\n                    wei = \"equal\")\n\nfitvar2_l_O &lt;- variofit(vg1_O,\n                    cov.model = \"exponential\",\n                    ini1_l_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_lO,\n                    wei = \"npairs\")\n\nfitvar3_l_O &lt;- variofit(vg1_O,\n                    cov.model = \"exponential\",\n                    ini1_l_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_lO,\n                    wei = \"cressie\")\n\nfitvar4_l_O &lt;- likfit(ozone,\n                  coords = ozone$coords,\n                  data = ozone$data,\n                  trend = ~ I(Norte^2) + I(Norte^3) + Este,\n                  ini.cov.pars = ini1_l_O,\n                  fix.nugget = F,\n                  nugget = nugget_0_lO,\n                  cov.model = \"exponential\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_O,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_l_O, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_l_O, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_l_O, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_l_O, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Oexp &lt;- c(fitvar1_l_O$nugget, fitvar1_l_O$cov.pars[1], fitvar1_l_O$cov.pars[2])\npar2Oexp &lt;- c(fitvar2_l_O$nugget, fitvar2_l_O$cov.pars[1], fitvar2_l_O$cov.pars[2])\npar3Oexp &lt;- c(fitvar1_l_O$nugget, fitvar3_l_O$cov.pars[1], fitvar3_l_O$cov.pars[2])\npar4Oexp &lt;- c(fitvar4_l_O$nugget, fitvar4_l_O$cov.pars[1], fitvar4_l_O$cov.pars[2])\n\nresumen_O_exp &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1Oexp,\n    par2Oexp,\n    par3Oexp,\n    par4Oexp\n  ),\n  MSE = c(\n    mean((par1Oexp[1]+par1Oexp[2]-cov.spatial(variog_O$h, cov.model = \"exponential\", cov.pars = par1Oexp[c(2,3)])-variog_O$gamma_hat)^2),\n    mean((par2Oexp[1]+par2Oexp[2]-cov.spatial(variog_O$h, cov.model = \"exponential\", cov.pars = par2Oexp[c(2,3)])-variog_O$gamma_hat)^2),\n    mean((par3Oexp[1]+par3Oexp[2]-cov.spatial(variog_O$h, cov.model = \"exponential\", cov.pars = par3Oexp[c(2,3)])-variog_O$gamma_hat)^2),\n     mean((par4Oexp[1]+par4Oexp[2]-cov.spatial(variog_O$h, cov.model = \"exponential\", cov.pars = par4Oexp[c(2,3)])-variog_O$gamma_hat)^2)\n  )\n)\n\nresumen_O_exp &lt;- as.data.frame(resumen_O_exp)\nresumen_O_exp[ , -1] &lt;- lapply(resumen_O_exp[ , -1], function(x) round(as.numeric(x), 3))\nkable(resumen_O_exp, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n7.838\n121.907\n8214726.4\n3.560\n\n\n1/n\n7.388\n13.033\n600000.0\n6.737\n\n\nCressie\n7.838\n11.486\n600000.0\n8.208\n\n\nMLE\n4.317\n128.551\n599998.9\n3740.136\n\n\n\n\n\n\n\n\nSe observa que los modelos Exponencial y Gneiting presentan un menor error cuadrático medio, sin embargo, ambos modelos presentan un nugget considerablemente alto en relación a la magnitud de la semivarianza observada. Por esta razón se opta por utilizar el modelo Matern para realizar la predicción.\n\n\n\n1.2.1.3 Kriging\nEl modelo Matern, con los parámetros obtenidos por MCO, que se usará para realizar Kriging es el siguiente:\n\n\n\n\n\n\n\n\n\nPara realizar la predicción, se genera una muestra aleatoria de puntos dentro del polígono que delimita el estado de California mediante la función spsample() del paquete sp. Sobre estos puntos se estiman los valores esperados aplicando el método de Kriging de vecinos cercanos, con el fin de mejorar la precisión de las estimaciones al considerar las grandes distancias características del territorio californiano. El procedimiento se implementa mediante la función krige() de gstat, especifícando la opción nmin=20 y utilizando la función predict() de base de R.\n\n\nVer código\n#Se ajusta el mejor modelo -------------------------------\n\nbest_model_O &lt;- gstat::vgm(psill = fitvar1_mat_O$cov.pars[1],\n                           model = \"Mat\",\n                           range = fitvar1_mat_O$cov.pars[2],\n                           nugget = fitvar1_mat_O$nugget,\n                           kappa = fitvar1_mat_O$kappa\n                           \n)\n\n# Se crea un objeto en gstat ------------------------------\n\ncoordinates(datosOZ) &lt;- ~Este + Norte\nproj4string(datosOZ) &lt;- CRS(\"EPSG:3310\")\n\ng_obj&lt;-gstat::gstat(id=\"Ozono\",\n             formula = Ozono ~ I(Norte^2) + I(Norte^3) + Este,\n             model = best_model_O,\n             data = datosOZ)\n\n#Kriging ------------------------------------------------\n\ninvisible(predic &lt;- predict(g_obj, newdata = new, nmin = 20))\n\n\n#Mapas de predicción -------------------------------------\n\ngridded(predic) &lt;- TRUE\n\n#1. Mapa de Kriging --------------------------------------\n\npredic_raster_utm &lt;- raster(predic, layer = \"Ozono.pred\")\n\ncrs(predic_raster_utm) &lt;- \"+init=epsg:3310\"\n\npredic_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        predic_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmin_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='min')\nmax_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='max')\n\npred_range &lt;- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))\n\nstep_pred &lt;- (max_pred-min_pred)/ 6\n\nbins &lt;- round(seq(min_pred, max_pred, by=step_pred),0)\n\npal_pred &lt;- colorBin(\n  palette = \"viridis\", # La paleta de colores\n  domain = pred_range,\n  bins = bins,\n  na.color = \"transparent\"\n)\n\nmapa_kriging_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    predic_raster_wgs84, \n    colors = pal_pred, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n    addCircleMarkers(data = datosO_sf_wgs84,\n                   fillColor = ~palO(Ozono),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"Ozn:\", Ozono, \"ppb\")) %&gt;% \n  \n  addLegend(\n    pal = pal_pred, \n    values = pred_range,\n    title = \"Predicción Oz ppb\",\n    position = \"topright\"\n  ) %&gt;%\n  \n  addLegend(pal = palO,\n            values = datosO_sf_wgs84$Ozono,\n            title = \"Ozono Observado\",\n    position = \"topleft\"\n  ) \n\n#2 Mapa Varianza------------------------------------------\n\nvar_raster_utm &lt;- raster(predic, layer = \"Ozono.var\")\n\ncrs(var_raster_utm) &lt;- \"+init=epsg:3310\"\n\nvar_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        var_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmax_var &lt;- raster::cellStats(var_raster_wgs84, stat='max')\nstep_var &lt;- max_var / 6\n\nbinsv &lt;- round(seq(0, max_var, by=step_var),2)\n\nvar_range &lt;- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))\npal_var &lt;- colorBin(\n  palette = \"Spectral\", # La paleta de colores\n  domain = var_range,\n  bins = binsv,\n  na.color = \"transparent\"\n)\n\nmapa_var_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    var_raster_wgs84,\n    colors = pal_var, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  addLegend(\n    pal = pal_var, \n    values = var_range,\n    title = \"Varianza\",\n    position = \"topright\"\n  ) \n\n#3. Mapa Cv ----------------------------------------------\n\ncv_raster_utm &lt;- sqrt(var_raster_utm) / abs(predic_raster_utm)\n\nmapa_mayor_a_uno &lt;- cv_raster_utm &gt; 1\ncv_raster_utm[mapa_mayor_a_uno] &lt;- 1\n\ncrs(cv_raster_utm) &lt;- \"+init=epsg:3310\"\n\ncv_terra &lt;- terra::rast(cv_raster_utm)\nsh_terra &lt;- terra::vect(sh_mundos_sp_utm_simple)\n\nmasked_cv_terra &lt;- terra::mask(cv_terra, sh_terra)\n\ncv_raster_wgs84_terra &lt;- terra::project(\n    masked_cv_terra, \n    y = \"epsg:4326\", \n    method = \"bilinear\" # Similar a projectRaster\n)\n\ncv_raster_wgs84 &lt;- raster::raster(cv_raster_wgs84_terra)\n\nmax_cv &lt;- raster::cellStats(cv_raster_wgs84, stat='max')\nstep_cv &lt;- max_cv / 10\n\nbincv &lt;- seq(0,max_cv, by=step_cv)\n\ncv_range &lt;- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))\n\npal_cv &lt;- colorBin(\n  palette = \"RdYlGn\", # Rojo-Amarillo-Verde\n  domain = cv_range,\n  na.color = \"transparent\",\n  bins = bincv,\n  reverse = TRUE\n)\n\nmapa_cv_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    cv_raster_wgs84,\n    colors = pal_cv, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  addLegend(\n    pal = pal_cv, \n    values = cv_range,\n    title = \"Coeficiente de Variación\",\n    position = \"topright\"\n  )\n\n\nEn el siguiente panel se presentan 3 mapas que resumen el proceso de predicción:\n\nPredicciónVarianzaCoeficiente de variación\n\n\n\n\nVer código\nmapa_kriging_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_var_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_cv_leaflet\n\n\n\n\n\n\n\n\n\nLos resultados del Kriging indican que la calidad del aire tiende a ser más deficiente en el sur de California y en el Valle Central, donde se observan las concentraciones predichas más altas de ozono. Dado que estas regiones cuentan con una alta densidad de estaciones de monitoreo, se cuenta con una mayor confiabilidad y precisión en las estimaciones del modelo (reflejada en valores bajos de varianza o coeficiente de variación). En contraste, las predicciones sobre la concentración de ozono presentan mayor incertidumbre (varianza o CV elevados) en las zonas rurales y fronterizas del norte y este del estado, debido a la menor disponibilidad de estaciones de observación en esas áreas.\nA pesar de que los coeficientes de variación presentan valores muy bajos, todos inferiores al 11%, es importante interpretar estos resultados con cautela. Aunque se aplicó un Kriging de vecinos cercanos para mitigar el efecto de las grandes distancias entre puntos, es posible que aún persista cierto nivel de ruido o variabilidad residual asociado a la extensión geográfica del área californiana.\n\n\n\n1.2.2 Variable Temperatura\nEn el siguiente mapa se presenta la distribución territorial de las estaciones de Temperatura, así mismo como sus valores muestrales:\n\n\nVer código\ny_T &lt;- Temp[1,] #Tomar una fecha\ny_T &lt;- cbind(colnames(y_T),t(y_T[1,]))\ny_T &lt;- y_T[-1,]\ny_T &lt;- as.data.frame(y_T)\ny_T &lt;- na.omit(y_T)\ny_T &lt;- y_T[-which.min(y_T$V2),]\ny_T$V1 &lt;- as.numeric(y_T$V1)\ny_T &lt;- inner_join(y_T, EstacionesT, by=c(\"V1\"=\"AQSID\"))\ndatosT &lt;- y_T[,c(13,14,2)]\ncolnames(datosT)=c(\"Este\",\"Norte\",\"Temperatura\")\ndatosT$Temperatura &lt;- as.numeric(datosT$Temperatura)\n\ndatosT_sf &lt;- st_as_sf(datosT, coords = c(\"Este\", \"Norte\"), crs = 3310)\n\ndatosT_sf_wgs84 &lt;- st_transform(datosT_sf, crs = 4326)\n\npal &lt;- colorNumeric(palette = \"viridis\", domain = datosT_sf_wgs84$Temperatura)\n\nleaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = \"black\", weight = 2) %&gt;%\n  addCircleMarkers(data = datosT_sf_wgs84,\n                   fillColor = ~pal(Temperatura),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"Temp:\", Temperatura, \"°C\")) %&gt;%\n  addLegend(pal = pal, values = datosT_sf_wgs84$Temperatura, title = \"Temperatura (°C)\")\n\n\n\n\n\n\nLos datos observados son trabajados en el formato geodata mediante el uso de la función as.geodata() del paquete GeoR. El resumen de las coordenadas y la variable Ozono se presenta tabularmente en seguida:\n\n\nVer código\ntemp &lt;- as.geodata(datosT) \npander::pander(summary(temp))\n\n\n\nn: 122\ncoords.summary:\n\n\n\n\n\n\n\n\n \nEste\nNorte\n\n\n\n\nmin\n-325701\n-580919\n\n\nmax\n387270\n281577\n\n\n\ndistances.summary:\n\n\n\n\n\n\n\nmin\nmax\n\n\n\n\n609.2\n1e+06\n\n\n\ndata.summary:\n\n\n\n\n\n\n\n\n\n\n\nMin.\n1st Qu.\nMedian\nMean\n3rd Qu.\nMax.\n\n\n\n\n-3.2\n13.15\n15.8\n14.43\n17.2\n24.5\n\n\n\n\n\n\n\n\n1.2.2.1 Análisis de Estacionariedad en Media\nAhora, se procede a revisar el comportamiento de la media de la variable con respecto a las coordenadas Este y Norte. Para entender de mejor manera la distribución de la variable ozono se presentan la matriz de correlación muestral y los siguientes gráficos:\n\nMatrizGráficos de dispersiónGeoR\n\n\n\n\nVer código\npander::pander(cor(datosT))\n\n\n\n\n\n\n\n\n\n\n\n \nEste\nNorte\nTemperatura\n\n\n\n\nEste\n1\n-0.7668\n0.3464\n\n\nNorte\n-0.7668\n1\n-0.458\n\n\nTemperatura\n0.3464\n-0.458\n1\n\n\n\n\n\n\n\n\n\nVer código\npT1 &lt;- simple_scatter_plot(datosT, \"Este\", \"Temperatura\")\npT2 &lt;- simple_scatter_plot(datosT, \"Norte\", \"Temperatura\")\n\ncowplot::plot_grid(pT1,pT2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(temp, qt.col = c(\"purple\",\n                    \"pink\",\n                    \"green\",\n                    \"yellow\"),\n     scatter3d=T)\n\n\n\n\n\n\n\n\n\n\n\n\nEn la matriz de correlaciones se observa una asociación notable entre la temperatura con la coordenada Norte. No obstante, esta relación no se aprecia de forma claramente lineal en el gráfico de dispersión, por lo que se opta por ajustar un polinomio con el fin de corregir la tendencia y capturar mejor la variación espacial de la variable.\n\n1.2.2.1.1 Ajuste del Modelo\nEl modelo que mejor atrapa el efecto de la media es:\n\nTemperatura = \\beta_0 + \\beta_1 \\times Norte + \\beta_2 \\times Norte^2\n\n\n\nVer código\nfitT &lt;- lm(Temperatura~Norte+I(Norte^2), data = datosT) \npander::pander(summary(fitT))\n\n\n\n\n\n\n\n\n\n\n\n\n \nEstimate\nStd. Error\nt value\nPr(&gt;|t|)\n\n\n\n\n(Intercept)\n13.26\n0.5352\n24.77\n8.812e-49\n\n\nNorte\n-2.229e-05\n3.23e-06\n-6.901\n2.676e-10\n\n\nI(Norte^2)\n-3.754e-11\n8.551e-12\n-4.39\n2.469e-05\n\n\n\n\nFitting linear model: Temperatura ~ Norte + I(Norte^2)\n\n\n\n\n\n\n\n\nObservations\nResidual Std. Error\nR^2\nAdjusted R^2\n\n\n\n\n122\n4.049\n0.3199\n0.3084\n\n\n\n\n\nTodos los coeficientes del modelo son significativos. Sin embargo, el R^2 es relativamente bajo, por lo que se considera necesario verificar gráficamente si la tendencia espacial fue efectivamente mitigada.\n\nGráficos de dispersiónGeoR\n\n\n\n\nVer código\ndatosT$Residuos &lt;- fitT$residuals\n\npT1 &lt;- simple_scatter_plot(datosT, \"Este\", \"Residuos\")\npT2 &lt;- simple_scatter_plot(datosT, \"Norte\", \"Residuos\")\n\ncowplot::plot_grid(pT1,pT2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(temp, qt.col = c(\"purple\",\n                    \"pink\",\n                    \"green\",\n                    \"yellow\"),\n     scatter3d=T, trend=~Norte+I(Norte^2))\n\n\n\n\n\n\n\n\n\n\n\n\nLos gráficos evidencian que la tendencia existente entre la variable y la coordenada Norte ha sido mitigada, lo que indica que se ha logrado un ajuste adecuado del modelo.\n\n\n\n1.2.2.2 Estudio del Semivariograma\n\n1.2.2.2.1 Estimación Empírica del Semivariograma\nA continuación, se presenta la estimación del semivariograma obtenida con la función variog(). Para asegurar la fiabilidad de los resultados, se especifican los argumentos estimator.type = \"modulus\" y pairs.min=50, con el fin de utilizar un estimador robusto y garantizar un número mínimo adecuado de pares en cada intervalo de distancia.\n\n\nVer código\nvg_T &lt;- variog(temp, estimator.type = \"modulus\", pairs.min=50) #Sin tendencia espacial\n\nvg1_T &lt;- variog(temp, trend = ~Norte+I(Norte^2),\n                estimator.type = \"modulus\", pairs.min=50)\n\n\n\nCon tendenciaRemoviendo tendencia\n\n\n\n\nVer código\nplot(vg_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Sin remover tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Removiendo tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\nCuando no se remueve la tendencia, la semivarianza alcanza valores más altos y presenta una forma aparentemente más regular, aunque dicha regularidad está influenciada por la tendencia global de los datos. En cambio, al eliminar la tendencia, los valores de semivarianza disminuyen y el patrón pierde suavidad, pero el variograma refleja con mayor fidelidad la verdadera dependencia espacial.\n\n\n1.2.2.2.2 Estimación del Modelo Teórico de Semivariograma\nPara obtener unos valores iniciales de los modelos teóricos se usa la función EyeFit() de la librería GeoR.\nLos modelos obtenidos ajustando por EyeFit(), son:\n\ncov.model sigmasq phi tausq kappa kappa2 practicalRange\n1 exponential 10.74 109166.3 2.07 NA NA 327033.0\n2 gaussian 10.00 80000.0 2.07 NA NA 138465.5\n3 spherical 10.00 157832.8 2.07 NA NA 157832.8\n\n\n\nVer código\ndist_matrix_T &lt;- as.matrix(dist(temp$coords))\n\nvariog_T &lt;- data.frame(h = vg1_T$u, gamma_hat = vg1_T$v,\n                       n = vg1_T$n)\n\nrange_sv_T &lt;- seq(1,max(variog_T$h), by=1000)\n\n# Modelo exponencial ----\n\nsigma_0_eT &lt;- 10.74\nphi_0_eT &lt;- 109166.3\nnugget_0_eT &lt;- 2.07\n\npar_eT &lt;- c(sigma_0_eT, phi_0_eT, nugget_0_eT)\n\nres_e_T &lt;- est_sev_WLS(par=par_eT, kappa = NA,\n                       model=\"exponencial\",\n                       h=variog_T$h,\n                       gamma = variog_T$gamma_hat,\n                       n = variog_T$n)\n\nMLE_eT &lt;- optim(fn = loglik,\n             par = par_eT,\n             kappa=NA,\n             z = datosT$Residuos, \n             dist_matrix=dist_matrix_T,\n             model = \"exponencial\",\n             method = \"L-BFGS-B\",\n             lower = c(0, 0, 0))\n\nestsv_exp_Bess_T &lt;- do.call(sv_exp, c(as.list(res_e_T$Bessel$Optimizados), list(h = range_sv_T)))\nestsv_exp_n_T &lt;- do.call(sv_exp, c(as.list(res_e_T$`1/n`$Optimizados), list(h = range_sv_T)))\nestsv_exp_h_n_T &lt;- do.call(sv_exp, c(as.list(res_e_T$`h/n`$Optimizados), list(h = range_sv_T)))\nestsv_exp_MLE_T &lt;- do.call(sv_exp, c(list(nugget = MLE_eT$par[3], phi = MLE_eT$par[2] , sigma = MLE_eT$par[1],h = range_sv_T)))\n\n# Modelo Gaussiano ----\n\nsigma_0_gT &lt;- 10.00    \nphi_0_gT &lt;- 80000.0\nnugget_0_gT &lt;- 2.07\n\npar_gT &lt;- c(sigma_0_gT, phi_0_gT, nugget_0_gT)\n\nres_g_T &lt;- est_sev_WLS(par=par_gT, kappa = NA,\n                       model=\"gaussian\",\n                       h=variog_T$h,\n                       gamma = variog_T$gamma_hat,\n                       n = variog_T$n)\n\nestsv_g_Bess_T &lt;- do.call(sv_gauss, c(as.list(res_g_T$Bessel$Optimizados), list(h = range_sv_T)))\nestsv_g_n_T &lt;- do.call(sv_gauss, c(as.list(res_g_T$`1/n`$Optimizados), list(h = range_sv_T)))\nestsv_g_h_n_T &lt;- do.call(sv_gauss, c(as.list(res_g_T$`h/n`$Optimizados), list(h = range_sv_T)))\n\n# Modelo esférico\n\nsigma_0_esT &lt;- 10.00   \nphi_0_esT &lt;- 157832.8\nnugget_0_esT &lt;- 2.07\n\npar_esT &lt;- c(sigma_0_esT, phi_0_esT, nugget_0_esT)\n\nres_es_T &lt;- est_sev_WLS(par=par_esT, kappa = NA,\n                       model=\"spherical\",\n                       h=variog_T$h,\n                       gamma = variog_T$gamma_hat,\n                       n = variog_T$n)\n\nMLE_esT &lt;- optim(fn = loglik,\n             par = par_esT,\n             kappa=NA,\n             z = datosT$Residuos, \n             dist_matrix=dist_matrix_T,\n             model = \"spherical\",\n             method = \"L-BFGS-B\",\n             lower = c(0, 0, 0))\n\n\nestsv_es_Bess_T &lt;- do.call(sv_spherical, c(as.list(res_es_T$Bessel$Optimizados), list(h = range_sv_T)))\nestsv_es_n_T &lt;- do.call(sv_spherical, c(as.list(res_es_T$`1/n`$Optimizados), list(h = range_sv_T)))\nestsv_es_h_n_T &lt;- do.call(sv_spherical, c(as.list(res_es_T$`h/n`$Optimizados), list(h = range_sv_T)))\nestsv_es_MLE_T &lt;- do.call(sv_spherical, c(list(nugget = MLE_esT$par[3], phi = MLE_esT$par[2] , sigma = MLE_esT$par[1],h = range_sv_T)))\n\n\n\nExponencialGaussianoEsférico\n\n\n\nOptimGeoR\n\n\n\n\nVer código\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (optim)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(range_sv_T, estsv_exp_Bess_T, col=\"#FF4040\", lwd=1.5)\nlines(range_sv_T, estsv_exp_n_T, col=\"#4169E1\", lwd=1.5)\nlines(range_sv_T, estsv_exp_h_n_T, col=\"#008B00\", lwd=1.5)\nlines(range_sv_T, estsv_exp_MLE_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"Cressie\", \"1/n\", \"n/h\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\nVer código\nresumen_exp_T &lt;- cbind(\n  c(\"Cressie\", \"1/n\", \"n/h\", \"MLE\"),\n  rbind(\n    t(res_e_T$Bessel$Optimizados),\n    t(res_e_T$`1/n`$Optimizados),\n    t(res_e_T$`h/n`$Optimizados),\n    MLE_eT$par[c(3,1,2)]\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, res_e_T$Bessel$Optimizados, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_e_T$`1/n`$Optimizados, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_e_T$`h/n`$Optimizados, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, list(nugget = MLE_eT$par[3], phi = MLE_eT$par[2] , sigma = MLE_eT$par[1]), NA, model = \"exponencial\", variog_T$h)\n  )\n)\n\nresumen_exp_T &lt;- as.data.frame(resumen_exp_T)\nresumen_exp_T[ , -1] &lt;- lapply(resumen_exp_T[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_exp_T, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nCressie\n0\n12.944\n98216.22\n3.591000e+00\n\n\n1/n\n0\n11.178\n74809.83\n3.867000e+00\n\n\nn/h\n0\n12.797\n98765.50\n3.465000e+00\n\n\nMLE\n0\n31.706\n109166.30\n1.191489e+10\n\n\n\n\n\n\n\n\n\nVer código\nini1_exp_T &lt;- c(sigma_0_eT, phi_0_eT)\nfitvar1_exp_T &lt;- variofit(vg1_T,\n                    cov.model = \"exponential\",\n                    ini1_exp_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_eT,\n                    wei = \"equal\")\n\nfitvar2_exp_T &lt;- variofit(vg1_T,\n                    cov.model = \"exponential\",\n                    ini1_exp_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_eT,\n                    wei = \"npairs\")\n\nfitvar3_exp_T &lt;- variofit(vg1_T,\n                    cov.model = \"exponential\",\n                    ini1_exp_T,\n                    fix.nugget =F,\n                    nugget = nugget_0_eT,\n                    wei = \"cressie\")\n\nfitvar4_exp_T &lt;- likfit(temp,\n                  coords = temp$coords,\n                  data = temp$data,\n                  trend = ~ poly(Norte, 2, raw = FALSE),\n                  ini.cov.pars = ini1_exp_T,\n                  fix.nugget = F,\n                  nugget = nugget_0_eT,\n                  cov.model = \"exponential\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_exp_T, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_exp_T, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_exp_T, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_exp_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Texp &lt;- c(fitvar1_exp_T$nugget, fitvar1_exp_T$cov.pars[1], fitvar1_exp_T$cov.pars[2])\npar2Texp &lt;- c(fitvar2_exp_T$nugget, fitvar2_exp_T$cov.pars[1], fitvar2_exp_T$cov.pars[2])\npar3Texp &lt;- c(fitvar3_exp_T$nugget, fitvar3_exp_T$cov.pars[1], fitvar3_exp_T$cov.pars[2])\npar4Texp &lt;- c(fitvar4_exp_T$nugget, fitvar4_exp_T$cov.pars[1], fitvar4_exp_T$cov.pars[2])\n\nresumen_exp_T2 &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1Texp,\n    par2Texp,\n    par3Texp,\n    par4Texp\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, par1Texp, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par2Texp, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par3Texp, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par4Texp, NA, model = \"exponencial\", variog_T$h)\n  )\n)\n\nresumen_exp_T2 &lt;- as.data.frame(resumen_exp_T2)\nresumen_exp_T2[ , -1] &lt;- lapply(resumen_exp_T2[ , -1], function(x) round(as.numeric(x), 3))\nkable(resumen_exp_T2, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n0\n12.141\n82253.47\n3.184\n\n\n1/n\n0\n12.423\n83939.28\n3.243\n\n\nCressie\n0\n13.298\n109166.30\n4.009\n\n\nMLE\n0\n23.536\n75307.83\n117.551\n\n\n\n\n\n\n\n\n\n\n\nOptimGeoR\n\n\n\n\nVer código\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (optim)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(range_sv_T, estsv_g_Bess_T, col=\"#FF4040\", lwd=1.5)\nlines(range_sv_T, estsv_g_n_T, col=\"#4169E1\", lwd=1.5)\nlines(range_sv_T, estsv_g_h_n_T, col=\"#008B00\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"Cressie\", \"1/n\", \"n/h\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\nVer código\nresumen_g_T &lt;- cbind(\n  c(\"Cressie\", \"1/n\", \"n/h\"),\n  rbind(\n    t(res_g_T$Bessel$Optimizados),\n    t(res_g_T$`1/n`$Optimizados),\n    t(res_g_T$`h/n`$Optimizados)\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, res_g_T$Bessel$Optimizados, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_g_T$`1/n`$Optimizados, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_g_T$`h/n`$Optimizados, NA, model = \"gaussian\", variog_T$h)\n  )\n)\n\nresumen_g_T &lt;- as.data.frame(resumen_g_T)\nresumen_g_T[ , -1] &lt;- lapply(resumen_g_T[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_g_T, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nCressie\n0\n12.053\n74520.08\n2.809\n\n\n1/n\n0\n11.126\n69275.08\n3.233\n\n\nn/h\n0\n11.620\n72540.06\n2.825\n\n\n\n\n\n\n\n\n\nVer código\nini1_g_T &lt;- c(sigma_0_gT, phi_0_gT)\nfitvar1_g_T &lt;- variofit(vg1_T,\n                    cov.model = \"gaussian\",\n                    ini1_g_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_gT,\n                    wei = \"equal\")\n\nfitvar2_g_T &lt;- variofit(vg1_T,\n                    cov.model = \"gaussian\",\n                    ini1_g_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_gT,\n                    wei = \"npairs\")\n\nfitvar3_g_T &lt;- variofit(vg1_T,\n                    cov.model = \"gaussian\",\n                    ini1_g_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_gT,\n                    wei = \"cressie\")\n\nfitvar4_g_T &lt;- likfit(temp,\n                  coords = temp$coords,\n                  data = temp$data,\n                  trend = ~ poly(Norte, 2, raw = FALSE),\n                  ini.cov.pars = ini1_g_T,\n                  fix.nugget = F,\n                  nugget = nugget_0_gT,\n                  cov.model = \"gaussian\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_g_T, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_g_T, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_g_T, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_g_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Tg &lt;- c(fitvar1_g_T$nugget, fitvar1_g_T$cov.pars[1], fitvar1_g_T$cov.pars[2])\npar2Tg &lt;- c(fitvar2_g_T$nugget, fitvar2_g_T$cov.pars[1], fitvar2_g_T$cov.pars[2])\npar3Tg &lt;- c(fitvar3_g_T$nugget, fitvar3_g_T$cov.pars[1], fitvar3_g_T$cov.pars[2])\npar4Tg &lt;- c(fitvar4_g_T$nugget, fitvar4_g_T$cov.pars[1], fitvar4_g_T$cov.pars[2])\n\nresumen_g_T2 &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1Tg,\n    par2Tg,\n    par3Tg,\n    par4Tg\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, par1Tg, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par2Tg, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par3Tg, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par4Tg, NA, model = \"gaussian\", variog_T$h)\n  )\n)\n\nresumen_g_T2 &lt;- as.data.frame(resumen_g_T2)\nresumen_g_T2[ , -1] &lt;- lapply(resumen_g_T2[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_g_T2, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n0.000\n11.862\n74341.87\n2.776\n\n\n1/n\n0.000\n11.884\n74607.88\n2.777\n\n\nCressie\n0.349\n11.781\n80000.00\n2.835\n\n\nMLE\n3.589\n21.264\n80000.00\n155.000\n\n\n\n\n\n\n\n\n\n\n\nOptimGeoR\n\n\n\n\nVer código\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (optim)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(range_sv_T, estsv_es_Bess_T, col=\"#FF4040\", lwd=1.5)\nlines(range_sv_T, estsv_es_n_T, col=\"#4169E1\", lwd=1.5)\nlines(range_sv_T, estsv_es_h_n_T, col=\"#008B00\", lwd=1.5)\nlines(range_sv_T, estsv_es_MLE_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"Cressie\", \"1/n\", \"n/h\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\nVer código\nresumen_es_T &lt;- cbind(\n  c(\"Cressie\", \"1/n\", \"n/h\",\"MLE\"),\n  rbind(\n    t(res_es_T$Bessel$Optimizados),\n    t(res_es_T$`1/n`$Optimizados),\n    t(res_es_T$`h/n`$Optimizados),\n    MLE_esT$par[c(3,1,2)]\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, res_es_T$Bessel$Optimizados, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_es_T$`1/n`$Optimizados, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_es_T$`h/n`$Optimizados, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, list(nugget = MLE_esT$par[3], phi = MLE_esT$par[2] , sigma = MLE_esT$par[1]), NA, model = \"spherical\", variog_T$h)\n  )\n)\n\nresumen_es_T &lt;- as.data.frame(resumen_es_T)\nresumen_es_T[ , -1] &lt;- lapply(resumen_es_T[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_es_T, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nCressie\n0\n12.165\n191573.0\n3.044000e+00\n\n\n1/n\n0\n11.128\n165974.5\n3.417000e+00\n\n\nn/h\n0\n11.692\n175441.2\n2.976000e+00\n\n\nMLE\n0\n27.958\n157832.8\n2.490774e+10\n\n\n\n\n\n\n\n\n\nVer código\nini1_es_T &lt;- c(sigma_0_esT, phi_0_esT)\nfitvar1_es_T &lt;- variofit(vg1_T,\n                    cov.model = \"spherical\",\n                    ini1_es_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_esT,\n                    wei = \"equal\")\n\nfitvar2_es_T &lt;- variofit(vg1_T,\n                    cov.model = \"spherical\",\n                    ini1_es_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_esT,\n                    wei = \"npairs\")\n\nfitvar3_es_T &lt;- variofit(vg1_T,\n                    cov.model = \"spherical\",\n                    ini1_es_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_esT,\n                    wei = \"cressie\")\n\nfitvar4_es_T &lt;- likfit(temp,\n                  coords = temp$coords,\n                  data = temp$data,\n                  trend = ~ poly(Norte, 2, raw = FALSE),\n                  ini.cov.pars = ini1_es_T,\n                  fix.nugget = F,\n                  nugget = nugget_0_esT,\n                  cov.model = \"spherical\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_es_T, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_es_T, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_es_T, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_es_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Tes &lt;- c(fitvar1_es_T$nugget, fitvar1_es_T$cov.pars[1], fitvar1_es_T$cov.pars[2])\npar2Tes &lt;- c(fitvar2_es_T$nugget, fitvar2_es_T$cov.pars[1], fitvar2_es_T$cov.pars[2])\npar3Tes &lt;- c(fitvar3_es_T$nugget, fitvar3_es_T$cov.pars[1], fitvar3_es_T$cov.pars[2])\npar4Tes &lt;- c(fitvar4_es_T$nugget, fitvar4_es_T$cov.pars[1], fitvar4_es_T$cov.pars[2])\n\nresumen_es_T2 &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1Tes,\n    par2Tes,\n    par3Tes,\n    par4Tes\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, par1Tes, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par2Tes, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par3Tes, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par4Tes, NA, model = \"spherical\", variog_T$h)\n  )\n)\n\nresumen_es_T2 &lt;- as.data.frame(resumen_es_T2)\nresumen_es_T2[ , -1] &lt;- lapply(resumen_es_T2[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_es_T2, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n0\n11.878\n171733.0\n2.938\n\n\n1/n\n0\n11.898\n166427.4\n2.944\n\n\nCressie\n0\n11.860\n157832.8\n2.977\n\n\nMLE\n0\n25.641\n144147.3\n179.276\n\n\n\n\n\n\n\n\n\n\n\nEl modelo con menor MSE corresponde al modelo Gaussiano. No obstante, debido a la inestabilidad numérica observada durante el proceso de predicción, se opta por emplear el modelo Esférico ajustado mediante mínimos cuadrados ponderados con la ponderación h/n, el cual representa la segunda mejor alternativa en términos del MSE.\n\n\n\n1.2.2.3 Kriging\nEl modelo Esférico, con los parámetros obtenidos por WLS usando la ponderación h/n, que se usará para realizar Kriging es el siguiente:\n\n\n\n\n\n\n\n\n\nPara realizar la predicción, se genera una muestra aleatoria de puntos dentro del polígono que delimita el estado de California mediante la función spsample() del paquete sp. Sobre estos puntos se estiman los valores esperados aplicando el método de Kriging de vecinos cercanos, con el fin de mejorar la precisión de las estimaciones al considerar las grandes distancias características del territorio californiano. El procedimiento se implementa mediante la función krige() de gstat, especifícando la opción nmin=20 y utilizando la función predict() de base de R.\n\n\nVer código\n#Se escoge el mejor modelo --------------------------------\n\nbest_model_T &lt;- gstat::vgm(psill = res_es_T$`h/n`$Optimizados[2],\n                           model = \"Sph\",\n                           range = res_es_T$`h/n`$Optimizados[3],\n                           nugget = res_es_T$`h/n`$Optimizados[1]\n)\n\n#Se crea un objeto en gstat -------------------------------\n\ncoordinates(datosT) &lt;- ~Este + Norte\nproj4string(datosT) &lt;- CRS(\"EPSG:3310\")\n\ng_obj&lt;-gstat::gstat(id=\"Temperatura\",\n             formula = Temperatura ~ Norte + I(Norte^2),\n             model = best_model_T,\n             data = datosT)\n\n#Kriging -------------------------------------------------\n\nsuppressMessages(predic &lt;- predict(g_obj, newdata = new, nmin = 20))\n\n#Mapas de predicción --------------------------------------\n\ngridded(predic) &lt;- TRUE\n\n#1. Mapa de Kriging ---------------------------------------\n\npredic_raster_utm &lt;- raster(predic, layer = \"Temperatura.pred\")\n\ncrs(predic_raster_utm) &lt;- \"+init=epsg:3310\"\n\npredic_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        predic_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmin_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='min')\nmax_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='max')\n\npred_range &lt;- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))\n\nstep_pred &lt;- (max_pred-min_pred)/ 6\n\nbins &lt;- round(seq(min_pred, max_pred, by=step_pred),0)\n\npal_pred &lt;- colorBin(\n  palette = \"viridis\", # La paleta de colores\n  domain = pred_range,\n  bins = bins,\n  na.color = \"transparent\"\n)\n\nmapa_kriging_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    predic_raster_wgs84,\n    colors = pal_pred, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n    addCircleMarkers(data = datosT_sf_wgs84,\n                   fillColor = ~pal(Temperatura),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"Temp:\", Temperatura, \"°C\")) %&gt;% \n  addLegend(\n    pal = pal_pred, \n    values = pred_range,\n    title = \"Predicción T (°C)\",\n    position = \"topright\"\n  ) %&gt;%\n  addLegend(pal = pal,\n            values = datosT_sf_wgs84$Temperatura,\n            title = \"Temperatura Observada\",\n    position = \"topleft\"\n  ) \n\n#2 Mapa Varianza------------------------------------------\n\nvar_raster_utm &lt;- raster(predic, layer = \"Temperatura.var\")\n\ncrs(var_raster_utm) &lt;- \"+init=epsg:3310\"\n\nvar_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        var_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmax_var &lt;- raster::cellStats(var_raster_wgs84, stat='max')\nstep_var &lt;- max_var / 6\n\nbinsv &lt;- round(seq(0, max_var, by=step_var),2)\n\nvar_range &lt;- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))\npal_var &lt;- colorBin(\n  palette = \"Spectral\", # La paleta de colores\n  domain = var_range,\n  bins = binsv,\n  na.color = \"transparent\"\n)\n\nmapa_var_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    var_raster_wgs84, \n    colors = pal_var, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  addLegend(\n    pal = pal_var, \n    values = var_range,\n    title = \"Varianza\",\n    position = \"topright\"\n  ) \n\n#3. Mapa Cv ----------------------------------------------\n\ncv_raster_utm &lt;- sqrt(var_raster_utm) / abs(predic_raster_utm)\n\nmapa_mayor_a_uno &lt;- cv_raster_utm &gt; 1\ncv_raster_utm[mapa_mayor_a_uno] &lt;- 1\n\ncrs(cv_raster_utm) &lt;- \"+init=epsg:3310\"\n\ncv_terra &lt;- terra::rast(cv_raster_utm)\n\nmasked_cv_terra &lt;- terra::mask(cv_terra, sh_terra)\n\ncv_raster_wgs84_terra &lt;- terra::project(\n    masked_cv_terra, \n    y = \"epsg:4326\", \n    method = \"bilinear\" # Similar a projectRaster\n)\n\ncv_raster_wgs84 &lt;- raster::raster(cv_raster_wgs84_terra)\n\nmax_cv &lt;- raster::cellStats(cv_raster_wgs84, stat='max')\nstep_cv &lt;- max_cv / 10\n\nbincv &lt;- seq(0,max_cv, by=step_cv)\n\ncv_range &lt;- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))\n\npal_cv &lt;- colorBin(\n  palette = \"RdYlGn\", # Rojo-Amarillo-Verde\n  domain = cv_range,\n  na.color = \"transparent\",\n  bins = bincv,\n  reverse = TRUE \n)\n\nmapa_cv_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    cv_raster_wgs84, \n    colors = pal_cv, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  \n  addLegend(\n    pal = pal_cv, \n    values = cv_range,\n    title = \"Coeficiente de Variación\",\n    position = \"topright\"\n  )\n\n\nEn el siguiente panel se presentan 3 mapas que resumen el proceso de predicción:\n\nPredicciónVarianzaCoeficiente de variación\n\n\n\n\nVer código\nmapa_kriging_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_var_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_cv_leaflet\n\n\n\n\n\n\n\n\n\nLos mapas de kriging para la temperatura muestran que las zonas más cálidas y con predicciones más confiables se concentran en el sur de California y en el Valle Central. En contraste, las regiones con mayor incertidumbre (alta varianza y coeficiente de variación) se ubican principalmente en el extremo norte y a lo largo de las fronteras del estado.\nEsta menor fiabilidad en el norte se debe a la escasa presencia de estaciones de monitoreo en esas extensas áreas. El modelo de semivarianza empleado (Esférico) presenta un rango de influencia de aproximadamente 175 km, lo que implica que las mediciones dejan de ser útiles para la predicción más allá de esa distancia. Aunque se aplicó un Kriging de vecinos cercanos para mitigar el efecto de estas grandes distancias, persiste un nivel considerable de incertidumbre en las zonas con baja densidad de observaciones\n\n\n\n1.2.3 Variable Velocidad del viento\nEn el siguiente mapa se presenta la distribución territorial de las estaciones de Velocidad del Viento, así mismo como sus valores muestrales:\n\n\nVer código\ny_WS &lt;- WS[1,] #Tomar una fecha\ny_WS &lt;- cbind(colnames(y_WS),t(y_WS[1,]))\ny_WS &lt;- y_WS[-1,]\ny_WS &lt;- as.data.frame(y_WS)\ny_WS &lt;- na.omit(y_WS)\ny_WS$V1 &lt;- as.numeric(y_WS$V1)\ny_WS &lt;- inner_join(y_WS, EstacionesWS, by=c(\"V1\"=\"AQSID\"))\ndatosWS &lt;- y_WS[,c(13,14,2)]\ncolnames(datosWS)=c(\"Este\",\"Norte\",\"WindSpeed\")\ndatosWS$WindSpeed &lt;- as.numeric(datosWS$WindSpeed)\n\ndatosWS_sf &lt;- st_as_sf(datosWS, coords = c(\"Este\", \"Norte\"), crs = 3310)\n\ndatosWS_sf_wgs84 &lt;- st_transform(datosWS_sf, crs = 4326)\n\npalWS &lt;- colorNumeric(palette = \"viridis\", domain = datosWS_sf_wgs84$WindSpeed)\n\nleaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = \"black\", weight = 2) %&gt;%\n  addCircleMarkers(data = datosWS_sf_wgs84,\n                   fillColor = ~palWS(WindSpeed),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"WindSpeed:\", WindSpeed, \"m/s\")) %&gt;%\n  addLegend(pal = palWS, values = datosWS_sf_wgs84$WindSpeed, title = \"WindSpeed (m/s)\")\n\n\n\n\n\n\nLos datos observados son trabajados en el formato geodata mediante el uso de la función as.geodata() del paquete GeoR. El resumen de las coordenadas y la variable Ozono se presenta tabularmente en seguida:\n\n\nVer código\nws &lt;- as.geodata(datosWS)\npander::pander(summary(ws))\n\n\n\nn: 89\ncoords.summary:\n\n\n\n\n\n\n\n\n \nEste\nNorte\n\n\n\n\nmin\n-276541\n-543973\n\n\nmax\n415574\n281577\n\n\n\ndistances.summary:\n\n\n\n\n\n\n\nmin\nmax\n\n\n\n\n2216\n987994\n\n\n\ndata.summary:\n\n\n\n\n\n\n\n\n\n\n\nMin.\n1st Qu.\nMedian\nMean\n3rd Qu.\nMax.\n\n\n\n\n0.8\n2.5\n3.8\n4.375\n5.5\n14.1\n\n\n\n\n\n\n\n\n1.2.3.1 Análisis de Estacionariedad en Media\nAhora, se procede a revisar el comportamiento de la media de la variable con respecto a las coordenadas Este y Norte. Para entender de mejor manera la distribución de la variable ozono se presentan la matriz de correlación muestral y los siguientes gráficos:\n\nMatrizGráficos de dispersiónGeoR\n\n\n\n\nVer código\npander::pander(cor(datosWS))\n\n\n\n\n\n\n\n\n\n\n\n \nEste\nNorte\nWindSpeed\n\n\n\n\nEste\n1\n-0.7654\n0.1151\n\n\nNorte\n-0.7654\n1\n0.3195\n\n\nWindSpeed\n0.1151\n0.3195\n1\n\n\n\n\n\n\n\n\n\nVer código\npWS1 &lt;- simple_scatter_plot(datosWS, \"Este\", \"WindSpeed\")\npWS2 &lt;- simple_scatter_plot(datosWS, \"Norte\", \"WindSpeed\")\n\ncowplot::plot_grid(pWS1,pWS2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(ws, qt.col = c(\"purple\",\n                          \"pink\",\n                          \"green\",\n                          \"yellow\"),\n     scatter3d=T)\n\n\n\n\n\n\n\n\n\n\n\n\nEn la matriz de correlaciones no se aprecia una asociación fuerte ni evidente entre la velocidad del viento y las coordenadas espaciales. Sin embargo, los gráficos sugieren una posible relación, aunque débil, por lo que se explorarán distintos modelos hasta identificar aquel que describa mejor la tendencia observada.\n\n1.2.3.1.1 Ajuste del Modelo\nEl modelo que mejor atrapa el efecto de la media es:\nWindSpeed = \\beta_0 + \\beta_1 \\times Este + \\beta_2 \\times Norte + \\beta_3 \\times Este \\times Norte\n\n\nVer código\nfitWS &lt;- lm(WindSpeed~Este*Norte, data = datosWS) \npander::pander(summary(fitWS))\n\n\n\n\n\n\n\n\n\n\n\n\n \nEstimate\nStd. Error\nt value\nPr(&gt;|t|)\n\n\n\n\n(Intercept)\n6.398\n0.3639\n17.58\n4.751e-30\n\n\nEste\n2.069e-05\n2.674e-06\n7.739\n1.895e-11\n\n\nNorte\n1.159e-05\n1.808e-06\n6.411\n7.746e-09\n\n\nEste:Norte\n2.558e-11\n7.483e-12\n3.419\n0.000968\n\n\n\n\nFitting linear model: WindSpeed ~ Este * Norte\n\n\n\n\n\n\n\n\nObservations\nResidual Std. Error\nR^2\nAdjusted R^2\n\n\n\n\n89\n1.938\n0.4851\n0.4669\n\n\n\n\n\nSe observa que todos los coeficientes del modelo resultan estadísticamente significativos, y que el ajuste presenta un R^2 de 0.48, lo cual indica un nivel de explicación adecuado de la variabilidad de la velocidad del viento.\n\nGráficos de dispersiónGeoR\n\n\n\n\nVer código\ndatosWS$Residuos &lt;- fitWS$residuals\n\npWS1 &lt;- simple_scatter_plot(datosWS, \"Este\", \"Residuos\")\npWS2 &lt;- simple_scatter_plot(datosWS, \"Norte\", \"Residuos\")\n\ncowplot::plot_grid(pWS1,pWS2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(temp, qt.col = c(\"purple\",\n                      \"pink\",\n                      \"green\",\n                      \"yellow\"),\n     scatter3d=T, trend=~Norte*Este)\n\n\n\n\n\n\n\n\n\n\n\n\nEn los gráficos se observa que el patrón asociado a las coordenadas se ha atenuado considerablemente, lo que sugiere que el modelo se ajustó de manera adecuada.\n\n\n\n1.2.3.2 Estudio del Semivariograma\nA continuación, se presenta la estimación del semivariograma obtenida con la función variog(). Para asegurar la fiabilidad de los resultados, se especifican los argumentos estimator.type = \"modulus\" y pairs.min=50, con el fin de utilizar un estimador robusto y garantizar un número mínimo adecuado de pares en cada intervalo de distancia.\n\n1.2.3.2.1 Estimación Empírica del Semivariograma\n\n\nVer código\nvgO_WS &lt;- variog(ws,estimator.type = \"modulus\", pairs.min=50) \n\nvg1_WS &lt;- variog(ws, trend = ~Norte*Este,\n                estimator.type = \"modulus\", pairs.min=50)\n\n\n\nCon tendenciaRemoviendo Tendencia\n\n\n\n\nVer código\nplot(vgO_WS,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Sin remover tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(vg1_WS,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Removiendo tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\nSe observa que la estimación de la varianza de la variable incrementos presenta valores más bajos al remover la tendencia, lo que indica que en este caso el semivariograma refleja de manera más adecuada la verdadera estructura espacial del fenómeno.\n\n\n1.2.3.2.2 Estimación del Modelo Teórico de Semivariograma\nPara obtener unos valores iniciales de los modelos teóricos se usa la función EyeFit() de la librería GeoR. Por su parte, para el modelo coseno se realizo una estimación a ojo mediante la construcción de una función sv_cos() basada en la literatura.\nLos modelos obtenidos ajustando por EyeFit() y sv_cos(), son:\n\ncov.model sigmasq phi tausq kappa kappa2 practicalRange\n1 cos 1.5 .6e5 1.5 NA NA NA\n2 wave 3.5 .6e5 1.5 NA NA NA\n\nLa estimación de los parámetros del modelo Wave se hizo haciendo uso de las funciones nls() y optim() de R.\n\n\nVer código\nvariog_WS &lt;- data.frame(h = vg1_WS$u, gamma_hat = vg1_WS$v,\n                       n = vg1_WS$n)\n\nrange_sv_WS &lt;- seq(1,max(variog_WS$h), by=1000)\n\n#Modelo Coseno---------------------------------------------\n\nsigma_0_cosWS &lt;- 1.5\nphi_0_cosWS &lt;- .6e5\nnugget_0_cosWS &lt;- 1.5\n\n#MCO -------\nI_pond_WS &lt;- nls(formula = gamma_hat ~cos_sv(nugget, sigma, h, phi),\n              start = c(nugget = nugget_0_cosWS, sigma = sigma_0_cosWS, phi = phi_0_cosWS),\n              lower = rep(1e-6,3),\n              data = variog_WS,\n              control = nls.control(maxiter = 500, warnOnly = TRUE))\n\noptim_I_WS &lt;- optim(\n  par = coef(I_pond_WS),\n  fn = MSE_ponderados,\n  h = variog_WS$h,\n  gamma = variog_WS$gamma_hat,\n  pesos = \"I\",\n  model = \"cos\",\n  n = n,\n  method = \"L-BFGS-B\",\n  lower = rep(1e-6,3)\n)\n\npar_optim_I_WS &lt;- optim_I_WS$par[c(\"nugget\", \"sigma\", \"phi\")]\n\nestsv_cos_I_WS &lt;- do.call(cos_sv, c(as.list(par_optim_I_WS), list(h = range_sv_WS)))\n\n\n#WLS -------\n\npar_cosWS &lt;- c(sigma_0_cosWS, phi_0_cosWS, nugget_0_cosWS)\n\nres_cos_WS &lt;- est_sev_WLS(par=par_cosWS, kappa = NA,\n                       model=\"cos\",\n                       h=variog_WS$h,\n                       gamma = variog_WS$gamma_hat,\n                       n = variog_WS$n)\n\nestsv_cos_Bess_WS &lt;- do.call(cos_sv, c(as.list(res_cos_WS$Bessel$Optimizados), list(h = range_sv_WS)))\nestsv_cos_n_WS &lt;- do.call(cos_sv, c(as.list(res_cos_WS$`1/n`$Optimizados), list(h = range_sv_WS)))\nestsv_cos_h_n_WS &lt;- do.call(cos_sv, c(as.list(res_cos_WS$`h/n`$Optimizados), list(h = range_sv_WS)))\n\n#Modelo Wave ---------------------------------------------\n\nnugget_0_wvWS &lt;- 1.5\n\npar_wvWS &lt;- c(3.5,.6e5)\n\nfitvar1_cos_WS &lt;- variofit(vg1_WS,\n                    cov.model = \"wave\",\n                    par_wvWS,\n                    fix.nugget = F,\n                    nugget = nugget_0_wvWS,\n                    wei = \"equal\")\nfitvar2_cos_WS &lt;- variofit(vg1_WS,\n                    cov.model = \"wave\",\n                    par_wvWS,\n                    fix.nugget = F,\n                    nugget = nugget_0_wvWS,\n                    wei = \"npairs\")\n\nfitvar3_cos_WS &lt;- variofit(vg1_WS,\n                    cov.model = \"wave\",\n                    par_wvWS,\n                    fix.nugget = F,\n                    nugget = nugget_0_wvWS,\n                    wei = \"cressie\")\n\nfitvar4_cos_WS &lt;- likfit(ws,\n                       coords = ws$coords,\n                       data = ws$data,\n                       trend = ~ Este*Norte,\n                       ini.cov.pars = par_wvWS,\n                       fix.nugget = F,\n                       nugget = nugget_0_wvWS,\n                       cov.model = \"wave\",\n                       lik.method = \"ML\")\n\n\n\nCoseno (Optim)Wave (GeoR)\n\n\n\n\nVer código\nplot(vg1_WS,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (optim)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(range_sv_WS, estsv_cos_Bess_WS, col=\"#FF4040\", lwd=1.5)\nlines(range_sv_WS, estsv_cos_n_WS, col=\"#4169E1\", lwd=1.5)\nlines(range_sv_WS, estsv_cos_h_n_WS, col=\"#008B00\", lwd=1.5)\nlines(range_sv_WS, estsv_cos_I_WS, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"Cressie\", \"1/n\", \"n/h\", \"MCO\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\nVer código\nresumen_cos_SV &lt;- cbind(\n  c(\"Cressie\", \"1/n\", \"n/h\", \"MCO\"),\n  rbind(\n    t(res_cos_WS$Bessel$Optimizados),\n    t(res_cos_WS$`1/n`$Optimizados),\n    t(res_cos_WS$`h/n`$Optimizados),\n    par_optim_I_WS\n  ),\n  MSE = c(\n    MSE_sv(variog_WS$gamma_hat, res_cos_WS$Bessel$Optimizados, NA, model = \"cos\", variog_WS$h),\n    MSE_sv(variog_WS$gamma_hat, res_cos_WS$`1/n`$Optimizados, NA, model = \"cos\", variog_WS$h),\n    MSE_sv(variog_WS$gamma_hat, res_cos_WS$`h/n`$Optimizados, NA, model = \"cos\", variog_WS$h),\n    MSE_sv(variog_WS$gamma_hat, par_optim_I_WS, NA, model = \"cos\", variog_WS$h)\n  )\n)\n\nresumen_cos_SV &lt;- as.data.frame(resumen_cos_SV)\nresumen_cos_SV[ , -1] &lt;- lapply(resumen_cos_SV[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_cos_SV, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nCressie\n2.988\n0.513\n59341.12\n1.288\n\n\n1/n\n1.397\n1.316\n59754.77\n1.324\n\n\nn/h\n2.581\n0.000\n64723.22\n1.389\n\n\nMCO\n2.321\n0.694\n59631.92\n0.999\n\n\n\n\n\n\n\n\n\nVer código\nplot(vg1_WS,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\n\nlines(fitvar1_cos_WS, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_cos_WS, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_cos_WS, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_cos_WS, col=\"#FFA500\", lwd=1.5)\n\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1WScos &lt;- c(fitvar1_cos_WS$nugget, fitvar1_cos_WS$cov.pars[1], fitvar1_cos_WS$cov.pars[2])\npar2WScos &lt;- c(fitvar2_cos_WS$nugget, fitvar2_cos_WS$cov.pars[1], fitvar2_cos_WS$cov.pars[2])\npar3WScos &lt;- c(fitvar3_cos_WS$nugget, fitvar3_cos_WS$cov.pars[1], fitvar3_cos_WS$cov.pars[2])\npar4WScos &lt;- c(fitvar4_cos_WS$nugget, fitvar4_cos_WS$cov.pars[1], fitvar4_cos_WS$cov.pars[2])\n\nresumen_wv_WS &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1WScos,\n    par2WScos,\n    par3WScos,\n    par4WScos\n  ),\n  MSE = c(\n    MSE_sv(variog_WS$gamma_hat, par1WScos, NA, model = \"wave\", variog_WS$h),\n    MSE_sv(variog_WS$gamma_hat, par2WScos, NA, model = \"wave\", variog_WS$h),\n    MSE_sv(variog_WS$gamma_hat, par3WScos, NA, model = \"wave\", variog_WS$h),\n    MSE_sv(variog_WS$gamma_hat, par4WScos, NA, model = \"wave\", variog_WS$h)\n  )\n)\n\nresumen_wv_WS &lt;- as.data.frame(resumen_wv_WS)\nresumen_wv_WS[ , -1] &lt;- lapply(resumen_wv_WS[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_wv_WS, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n1.692\n1.447\n60000.00\n1.014\n\n\n1/n\n1.069\n2.467\n50139.56\n0.864\n\n\nCressie\n1.300\n2.284\n50724.55\n0.908\n\n\nMLE\n2.819\n0.890\n60000.00\n1.450\n\n\n\n\n\n\n\n\nAl comparar los valores del MSE, se determinó que el modelo más adecuado es el Wave, ajustado mediante el método de WSL con ponderación basada en el número de pares por distancia en el semivariograma.\n\n\n\n1.2.3.3 Kriging\nEl modelo Wave, con los parámetros obtenidos por WLS usando la ponderación 1/n, que se usará para realizar Kriging es el siguiente:\n\n\n\n\n\n\n\n\n\nPara realizar la predicción, se genera una muestra aleatoria de puntos dentro del polígono que delimita el estado de California mediante la función spsample() del paquete sp. Sobre estos puntos se estiman los valores esperados aplicando el método de Kriging de vecinos cercanos, con el fin de mejorar la precisión de las estimaciones al considerar las grandes distancias características del territorio californiano. El procedimiento se implementa mediante la función krige() de gstat, especifícando la opción nmin=20 y utilizando la función predict() de base de R.\n\n\nVer código\n#Se escoge el mejor modelo --------------------------------\n\nbest_model_WS &lt;- gstat::vgm(psill = par2WScos[2],\n                           model = \"Wav\",\n                           range = par2WScos[3],\n                           nugget = par2WScos[1]\n)\n\n#Se crea un objeto en gstat -------------------------------\n\ncoordinates(datosWS) &lt;- ~Este + Norte\nproj4string(datosWS) &lt;- CRS(\"EPSG:3310\")\n\ng_obj&lt;-gstat::gstat(id=\"WindSpeed\",\n             formula = WindSpeed ~ Norte*Este,\n             model = best_model_WS,\n             data = datosWS)\n\n#Kriging -------------------------------------------------\n\nsuppressMessages(predic &lt;- predict(g_obj, newdata = new, nmin = 20))\n\n#Mapas de predicción --------------------------------------\n\ngridded(predic) &lt;- TRUE\n\n#1. Mapa de Kriging ---------------------------------------\n\npredic_raster_utm &lt;- raster(predic, layer = \"WindSpeed.pred\")\n\ncrs(predic_raster_utm) &lt;- \"+init=epsg:3310\"\n\npredic_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        predic_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmin_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='min')\nmax_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='max')\n\npred_range &lt;- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))\n\nstep_pred &lt;- (max_pred-min_pred)/ 6\n\nbins &lt;- round(seq(min_pred, max_pred, by=step_pred),0)\n\npal_pred &lt;- colorBin(\n  palette = \"viridis\", # La paleta de colores\n  domain = pred_range,\n  bins = bins,\n  na.color = \"transparent\"\n)\n\nmapa_kriging_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    predic_raster_wgs84,\n    colors = pal_pred, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n    addCircleMarkers(data = datosWS_sf_wgs84,\n                   fillColor = ~palWS(WindSpeed),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"WS:\", WindSpeed, \"m/s\")) %&gt;% \n  addLegend(\n    pal = pal_pred, \n    values = pred_range,\n    title = \"Predicción WS (m/s)\",\n    position = \"topright\"\n  ) %&gt;%\n  addLegend(pal = palWS,\n            values = datosWS_sf_wgs84$WindSpeed,\n            title = \"WS Observada\",\n    position = \"topleft\"\n  ) \n\n#2 Mapa Varianza------------------------------------------\n\nvar_raster_utm &lt;- raster(predic, layer = \"WindSpeed.var\")\n\ncrs(var_raster_utm) &lt;- \"+init=epsg:3310\"\n\nvar_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        var_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmax_var &lt;- raster::cellStats(var_raster_wgs84, stat='max')\nstep_var &lt;- max_var / 6\n\nbinsv &lt;- round(seq(0, max_var, by=step_var),2)\n\nvar_range &lt;- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))\npal_var &lt;- colorBin(\n  palette = \"Spectral\", # La paleta de colores\n  domain = var_range,\n  bins = binsv,\n  na.color = \"transparent\"\n)\n\nmapa_var_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    var_raster_wgs84, \n    colors = pal_var, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  addLegend(\n    pal = pal_var, \n    values = var_range,\n    title = \"Varianza\",\n    position = \"topright\"\n  ) \n\n#3. Mapa Cv ----------------------------------------------\n\npredic$cv &lt;- sqrt(predic$WindSpeed.var) / pmax(abs(predic$WindSpeed.pred), 1e-6)\n\npredic$cv[predic$cv &gt; 1] &lt;- 1\n\ncv_raster_utm &lt;- raster(predic, layer = \"cv\")\n\ncrs(cv_raster_utm) &lt;- \"+init=epsg:3310\"\n\ncv_terra &lt;- terra::rast(cv_raster_utm)\n\nmasked_cv_terra &lt;- terra::mask(cv_terra, sh_terra)\n\ncv_raster_wgs84_terra &lt;- terra::project(\n    masked_cv_terra, \n    y = \"epsg:4326\", \n    method = \"bilinear\" # Similar a projectRaster\n)\n\ncv_raster_wgs84 &lt;- raster::raster(cv_raster_wgs84_terra)\n\nmax_cv &lt;- raster::cellStats(cv_raster_wgs84, stat='max')\nstep_cv &lt;- max_cv / 10\n\nbincv &lt;- seq(0,max_cv, by=step_cv)\n\ncv_range &lt;- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))\n\n\npal_cv &lt;- colorBin(\n  palette = \"RdYlGn\", # Rojo-Amarillo-Verde\n  domain = cv_range,\n  na.color = \"transparent\",\n  bins = bincv,\n  reverse = TRUE \n)\n\nmapa_cv_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    cv_raster_wgs84, \n    colors = pal_cv, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  \n  addLegend(\n    pal = pal_cv, \n    values = cv_range,\n    title = \"Coeficiente de Variación\",\n    position = \"topright\"\n  )\n\n\nEn el siguiente panel se presentan 3 mapas que resumen el proceso de predicción:\n\nPredicciónVarianzaCoeficiente de variación\n\n\n\n\nVer código\nmapa_kriging_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_var_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_cv_leaflet\n\n\n\n\n\n\n\n\n\nLa velocidad del viento es más elevada en el Valle Central y en el interior sur de California, y, en general, las predicciones en la mitad sur del estado muestran buena precisión (bajo coeficiente de variación). La incertidumbre más alta se concentra en el extremo norte, debido a la escasez de datos. El modelo Wave se utiliza para capturar la naturaleza variable del viento; sin embargo, la varianza sigue siendo elevada en zonas con baja densidad de estaciones y en algunas áreas muestreadas donde el viento probablemente es más turbulento o errático, lo que dificulta la interpolación. Para mitigar el efecto de las grandes distancias entre estaciones, se aplicó un Kriging de vecinos cercanos, lo que mejora la fiabilidad de las predicciones en puntos aislados.\n\n\n\n1.2.4 Variable Presión Barométrica\nEn el siguiente mapa se presenta la distribución territorial de las estaciones de Presión Barométrica, así mismo como sus valores muestrales:\n\n\nVer código\ny_Pr &lt;- Presion[1,] #Tomar una fecha\ny_Pr &lt;- cbind(colnames(y_Pr),t(y_Pr[1,]))\ny_Pr &lt;- y_Pr[-1,]\ny_Pr &lt;- as.data.frame(y_Pr)\ny_Pr &lt;- na.omit(y_Pr)\ny_Pr$V1 &lt;- as.numeric(y_Pr$V1)\ny_Pr &lt;- y_Pr[-which.min(y_Pr$V2),]\ny_Pr &lt;- y_Pr[-which.min(y_Pr$V2),]\ny_Pr &lt;- inner_join(y_Pr, EstacionesPr, by=c(\"V1\"=\"AQSID\"))\ndatosPr &lt;- y_Pr[,c(13,14,2)]\ncolnames(datosPr)=c(\"Este\",\"Norte\",\"Presion\")\ndatosPr$Presion &lt;- as.numeric(datosPr$Presion)\n\ndatosPr_sf &lt;- st_as_sf(datosPr, coords = c(\"Este\", \"Norte\"), crs = 3310)\n\ndatosPr_sf_wgs84 &lt;- st_transform(datosPr_sf, crs = 4326)\n\npalPr &lt;- colorNumeric(palette = \"viridis\", domain = datosPr_sf_wgs84$Presion)\n\nleaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = \"black\", weight = 2) %&gt;%\n  addCircleMarkers(data = datosPr_sf_wgs84,\n                   fillColor = ~palPr(Presion),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"Presion:\", Presion, \"mb\")) %&gt;%\n  addLegend(pal = palPr, values = datosPr_sf_wgs84$Presion, title = \"Presión Barométrica mb\")\n\n\n\n\n\n\nLos datos observados son trabajados en el formato geodata mediante el uso de la función as.geodata() del paquete GeoR. El resumen de las coordenadas y la variable Ozono se presenta tabularmente en seguida:\n\n\nVer código\npresion &lt;- as.geodata(datosPr)\npander::pander(summary(presion))\n\n\n\nn: 42\ncoords.summary:\n\n\n\n\n\n\n\n\n \nEste\nNorte\n\n\n\n\nmin\n-325701\n-467412\n\n\nmax\n320088\n164450\n\n\n\ndistances.summary:\n\n\n\n\n\n\n\nmin\nmax\n\n\n\n\n3267\n896013\n\n\n\ndata.summary:\n\n\n\n\n\n\n\n\n\n\n\nMin.\n1st Qu.\nMedian\nMean\n3rd Qu.\nMax.\n\n\n\n\n863.6\n957.6\n1003\n975.1\n1008\n1019\n\n\n\n\n\n\n\n\n1.2.4.1 Análisis de Estacionariedad en Media\nAhora, se procede a revisar el comportamiento de la media de la variable con respecto a las coordenadas Este y Norte. Para entender de mejor manera la distribución de la variable ozono se presentan la matriz de correlación muestral y los siguientes gráficos:\n\nMatrizGráficos de dispersiónGeoR\n\n\n\n\nVer código\npander::pander(cor(datosPr))\n\n\n\n\n\n\n\n\n\n\n\n \nEste\nNorte\nPresion\n\n\n\n\nEste\n1\n-0.7921\n-0.4299\n\n\nNorte\n-0.7921\n1\n-0.07364\n\n\nPresion\n-0.4299\n-0.07364\n1\n\n\n\n\n\n\n\n\n\nVer código\npPr1 &lt;- simple_scatter_plot(datosPr, \"Este\", \"Presion\")\npPr2 &lt;- simple_scatter_plot(datosPr, \"Norte\", \"Presion\")\n\ncowplot::plot_grid(pPr1,pPr2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(presion, qt.col = c(\"purple\",\n                          \"pink\",\n                          \"green\",\n                          \"yellow\"),\n     scatter3d=T)\n\n\n\n\n\n\n\n\n\n\n\n\nEn la matriz de correlaciones se aprecia una ligera asociación de la presión con la coordenada Este. No obstante, en los gráficos se observa una tendencia más evidente que involucra ambas coordenadas.\n\n1.2.4.1.1 Ajuste del Modelo\nEl modelo que mejor atrapa el efecto de la media es:\nPresion = \\beta_0 + \\beta_1 \\times Este + \\beta_2 \\times Norte \n\n\nVer código\nfitPr &lt;- lm(Presion~Este+Norte, data=datosPr)\npander::pander(summary(fitPr))\n\n\n\n\n\n\n\n\n\n\n\n\n \nEstimate\nStd. Error\nt value\nPr(&gt;|t|)\n\n\n\n\n(Intercept)\n941.3\n9.702\n97.03\n4.043e-48\n\n\nEste\n-0.0004972\n5.927e-05\n-8.39\n2.88e-10\n\n\nNorte\n-0.000331\n4.65e-05\n-7.117\n1.48e-08\n\n\n\n\nFitting linear model: Presion ~ Este + Norte\n\n\n\n\n\n\n\n\nObservations\nResidual Std. Error\nR^2\nAdjusted R^2\n\n\n\n\n42\n30.61\n0.6454\n0.6272\n\n\n\n\n\nTodos los coeficientes del modelo resultan estadísticamente significativos, y el valor de R^2 (0.65) indica que el ajuste captura de manera adecuada la variabilidad de la presión, sugiriendo que el modelo es apropiado.\n\nGráficos de dispersiónGeoR\n\n\n\n\nVer código\ndatosPr$Residuos &lt;- fitPr$residuals\n\npPr1 &lt;- simple_scatter_plot(datosPr, \"Este\", \"Residuos\")\npPr2 &lt;- simple_scatter_plot(datosPr, \"Norte\", \"Residuos\")\n\ncowplot::plot_grid(pPr1,pPr2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(presion, qt.col = c(\"purple\",\n                      \"pink\",\n                      \"green\",\n                      \"yellow\"),\n     scatter3d=T, trend=~Norte+Este)\n\n\n\n\n\n\n\n\n\n\n\n\nLos gráficos de dispersión corroboran los resultados del ajuste del modelo, mostrando que la tendencia respecto a las coordenadas espaciales se ha mitigado de buena manera.\n\n\n\n1.2.4.2 Estudio del Semivariograma\nA continuación, se presenta la estimación del semivariograma obtenida con la función variog(). Para asegurar la fiabilidad de los resultados, se especifican los argumentos estimator.type = \"modulus\" y pairs.min=50, con el fin de utilizar un estimador robusto y garantizar un número mínimo adecuado de pares en cada intervalo de distancia.\n\n\nVer código\nvgO_Pr &lt;- variog(presion,estimator.type = \"modulus\", pairs.min=50) \n\nvg1_Pr &lt;- variog(presion, trend = ~Norte+Este,\n                estimator.type = \"modulus\", pairs.min=50)\n\n\n\nCon tendenciaRemoviendo Tendencia\n\n\n\n\nVer código\nplot(vgO_Pr,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Sin remover tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(vg1_Pr,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Removiendo tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.4.2.1 Estimación del Modelo Teórico de Semivariograma\nPara obtener unos valores iniciales de los modelos teóricos se usa la función EyeFit() de la librería GeoR.\nEl modelo obtenido ajustando por EyeFit(), son:\n\ncov.model sigmasq phi tausq kappa kappa2 practicalRange\n1 exponential 1056.47 126360.8 132.06 NA NA 378543.2\n\n\n1.2.4.2.1.1 Exponencial\n\n\nVer código\nvariog_Pr &lt;- data.frame(h = vg1_Pr$u, gamma_hat = vg1_Pr$v,\n                       n = vg1_Pr$n)\n\nnugget_0_ePr &lt;- 132.06\n\npar_ePr &lt;- c(1056.47,126360.8)\n\nfitvar1_exp_Pr &lt;- variofit(vg1_Pr,\n                    cov.model = \"exponential\",\n                    par_ePr,\n                    fix.nugget = F,\n                    nugget = nugget_0_ePr,\n                    wei = \"equal\")\n\nfitvar2_exp_Pr &lt;- variofit(vg1_Pr,\n                    cov.model = \"exponential\",\n                    par_ePr,\n                    fix.nugget = F,\n                    nugget = nugget_0_ePr,\n                    wei = \"npairs\")\n\nfitvar3_exp_Pr &lt;- variofit(vg1_Pr,\n                    cov.model = \"exponential\",\n                    par_ePr,\n                    fix.nugget = F,\n                    nugget = nugget_0_ePr,\n                    wei = \"cressie\")\n\nfitvar4_exp_Pr &lt;- likfit(presion,\n                       coords = presion$coords,\n                       data = presion$data,\n                       trend = ~ Este+Norte,\n                       ini.cov.pars = par_ePr,\n                       fix.nugget = F,\n                       nugget = nugget_0_ePr,\n                       cov.model = \"exponential\",\n                       lik.method = \"ML\")\n\nplot(vg1_Pr,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_exp_Pr, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_exp_Pr, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_exp_Pr, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_exp_Pr, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Prexp &lt;- c(fitvar1_exp_Pr$nugget, fitvar1_exp_Pr$cov.pars[1], fitvar1_exp_Pr$cov.pars[2])\npar2Prexp &lt;- c(fitvar2_exp_Pr$nugget, fitvar2_exp_Pr$cov.pars[1], fitvar2_exp_Pr$cov.pars[2])\npar3Prexp &lt;- c(fitvar3_exp_Pr$nugget, fitvar3_exp_Pr$cov.pars[1], fitvar3_exp_Pr$cov.pars[2])\npar4Prexp &lt;- c(fitvar4_exp_Pr$nugget, fitvar4_exp_Pr$cov.pars[1], fitvar4_exp_Pr$cov.pars[2])\n\nresumen_exp_Pr &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1Prexp,\n    par2Prexp,\n    par3Prexp,\n    par4Prexp\n  ),\n  MSE = c(\n    MSE_sv(variog_Pr$gamma_hat, par1Prexp, NA, model = \"exponencial\", variog_Pr$h),\n    MSE_sv(variog_Pr$gamma_hat, par2Prexp, NA, model = \"exponencial\", variog_Pr$h),\n    MSE_sv(variog_Pr$gamma_hat, par3Prexp, NA, model = \"exponencial\", variog_Pr$h),\n    MSE_sv(variog_Pr$gamma_hat, par4Prexp, NA, model = \"exponencial\", variog_Pr$h)\n  )\n)\n\nresumen_exp_Pr &lt;- as.data.frame(resumen_exp_Pr)\nresumen_exp_Pr[ , -1] &lt;- lapply(resumen_exp_Pr[ , -1], function(x) round(as.numeric(x), 3))\nkable(resumen_exp_Pr, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n0\n998.786\n48215.75\n42965.03\n\n\n1/n\n0\n1008.061\n47795.01\n43055.30\n\n\nCressie\n0\n1099.124\n65376.00\n50323.55\n\n\nMLE\n0\n866.939\n49360.65\n57875.45\n\n\n\n\n\n\n\n\n\n1.2.4.3 Kriging\nEl modelo Exponencial, con los parámetros obtenidos por MCO, que se usará para realizar Kriging es el siguiente:\n\n\nVer código\nplot(vg1_Pr,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Modelo exponencial para Presión\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_exp_Pr, col=\"#FF4040\", lwd=1.5)\n\n\n\n\n\n\n\n\n\nPara realizar la predicción, se genera una muestra aleatoria de puntos dentro del polígono que delimita el estado de California mediante la función spsample() del paquete sp. Sobre estos puntos se estiman los valores esperados aplicando el método de Kriging de vecinos cercanos, con el fin de mejorar la precisión de las estimaciones al considerar las grandes distancias características del territorio californiano. El procedimiento se implementa mediante la función krige() de gstat, especifícando la opción nmin=20 y utilizando la función predict() de base de R.\n\n\nVer código\n#Se ajusta el mejor modelo -------------------------------\n\nbest_model_Pr &lt;- gstat::vgm(psill = fitvar1_exp_Pr$cov.pars[1],\n                           model = \"Exp\",\n                           range = fitvar1_exp_Pr$cov.pars[2],\n                           nugget = fitvar1_exp_Pr$nugget\n                           \n)\n\n# Se crea un objeto en gstat ------------------------------\n\ncoordinates(datosPr) &lt;- ~Este + Norte\nproj4string(datosPr) &lt;- CRS(\"EPSG:3310\")\n\ng_obj&lt;-gstat::gstat(id=\"Presion\",\n             formula = Presion ~ Norte + Este,\n             model = best_model_Pr,\n             data = datosPr)\n\n#Kriging ------------------------------------------------\n\ninvisible(predic &lt;- predict(g_obj, newdata = new))\n\n\n#Mapas de predicción -------------------------------------\n\ngridded(predic) &lt;- TRUE\n\n#1. Mapa de Kriging --------------------------------------\n\npredic_raster_utm &lt;- raster(predic, layer = \"Presion.pred\")\n\ncrs(predic_raster_utm) &lt;- \"+init=epsg:3310\"\n\npredic_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        predic_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmin_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='min')\nmax_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='max')\n\npred_range &lt;- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))\n\nstep_pred &lt;- (max_pred-min_pred)/ 6\n\nbins &lt;- round(seq(min_pred, max_pred, by=step_pred),0)\n\npal_pred &lt;- colorBin(\n  palette = \"viridis\", # La paleta de colores\n  domain = pred_range,\n  bins = bins,\n  na.color = \"transparent\"\n)\n\nmapa_kriging_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    predic_raster_wgs84, \n    colors = pal_pred, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n    addCircleMarkers(data = datosPr_sf_wgs84,\n                   fillColor = ~palPr(Presion),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"Presión:\", Presion, \"mb\")) %&gt;% \n  \n  addLegend(\n    pal = pal_pred, \n    values = pred_range,\n    title = \"Predicción Presión mb\",\n    position = \"topright\"\n  ) %&gt;%\n  \n  addLegend(pal = palPr,\n            values = datosPr_sf_wgs84$Presion,\n            title = \"Presión Observada\",\n    position = \"topleft\"\n  ) \n\n#2 Mapa Varianza------------------------------------------\n\nvar_raster_utm &lt;- raster(predic, layer = \"Presion.var\")\n\ncrs(var_raster_utm) &lt;- \"+init=epsg:3310\"\n\nvar_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        var_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmax_var &lt;- raster::cellStats(var_raster_wgs84, stat='max')\nstep_var &lt;- max_var / 6\n\nbinsv &lt;- round(seq(0, max_var, by=step_var),2)\n\nvar_range &lt;- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))\npal_var &lt;- colorBin(\n  palette = \"Spectral\", # La paleta de colores\n  domain = var_range,\n  bins = binsv,\n  na.color = \"transparent\"\n)\n\nmapa_var_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    var_raster_wgs84,\n    colors = pal_var, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  addLegend(\n    pal = pal_var, \n    values = var_range,\n    title = \"Varianza\",\n    position = \"topright\"\n  ) \n\n#3. Mapa Cv ----------------------------------------------\n\ncv_raster_utm &lt;- sqrt(var_raster_utm) / abs(predic_raster_utm)\n\nmapa_mayor_a_uno &lt;- cv_raster_utm &gt; 1\ncv_raster_utm[mapa_mayor_a_uno] &lt;- 1\n\ncrs(cv_raster_utm) &lt;- \"+init=epsg:3310\"\n\ncv_terra &lt;- terra::rast(cv_raster_utm)\nsh_terra &lt;- terra::vect(sh_mundos_sp_utm_simple)\n\nmasked_cv_terra &lt;- terra::mask(cv_terra, sh_terra)\n\ncv_raster_wgs84_terra &lt;- terra::project(\n    masked_cv_terra, \n    y = \"epsg:4326\", \n    method = \"bilinear\" # Similar a projectRaster\n)\n\ncv_raster_wgs84 &lt;- raster::raster(cv_raster_wgs84_terra)\n\nmax_cv &lt;- raster::cellStats(cv_raster_wgs84, stat='max')\nstep_cv &lt;- max_cv / 10\n\nbincv &lt;- seq(0,max_cv, by=step_cv)\n\ncv_range &lt;- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))\n\npal_cv &lt;- colorBin(\n  palette = \"RdYlGn\", # Rojo-Amarillo-Verde\n  domain = cv_range,\n  na.color = \"transparent\",\n  bins = bincv,\n  reverse = TRUE\n)\n\nmapa_cv_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    cv_raster_wgs84,\n    colors = pal_cv, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  addLegend(\n    pal = pal_cv, \n    values = cv_range,\n    title = \"Coeficiente de Variación\",\n    position = \"topright\"\n  )\n\n\nEn el siguiente panel se presentan 3 mapas que resumen el proceso de predicción:\n\nPredicciónVarianzaCoeficiente de variación\n\n\n\n\nVer código\nmapa_kriging_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_var_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_cv_leaflet\n\n\n\n\n\n\n\n\n\nLa presión atmosférica es más alta en la costa y en el sur del estado, y más baja en las regiones de gran altitud del este y del norte. Aunque las predicciones presentan buena precisión (bajo CV) en el Valle Central y el sur, el mapa de varianza absoluta muestra valores elevados en estas mismas zonas. Esto indica que el modelo Exponencial está capturando una alta heterogeneidad local de la presión en áreas con abundantes datos, probablemente asociada a efectos topográficos o meteorológicos muy localizados. Por su parte, la incertidumbre relativa sigue siendo mayor en el norte debido a la escasez de estaciones de monitoreo; para mitigar el efecto de las grandes distancias entre puntos, se aplicó un Kriging de vecinos cercanos, mejorando la confiabilidad de las estimaciones en regiones con datos limitados.",
    "crumbs": [
      "Análisis Geoestadístico",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Análisis Univariado</span>"
    ]
  },
  {
    "objectID": "Geo_uni.html#conclusiones",
    "href": "Geo_uni.html#conclusiones",
    "title": "1  Análisis Univariado",
    "section": "1.3 Conclusiones",
    "text": "1.3 Conclusiones\n\nSe logró modelar y mitigar la tendencia espacial de todas las variables analizadas. Las correlaciones iniciales con las coordenadas (principalmente para temperatura y presión) se redujeron significativamente tras el ajuste de los modelos de media, evidenciado tanto en los gráficos de dispersión como en los coeficientes significativos de los modelos.\nLos modelos de semivariograma ajustados (Esférico, Wave y Exponencial según la variable) capturaron la dependencia espacial de manera adecuada. El uso del Kriging de vecinos cercanos permitió mitigar el efecto de las grandes distancias entre estaciones de monitoreo, mejorando la precisión en zonas con baja densidad de datos, aunque persistió incertidumbre relativa en el norte y áreas fronterizas.\nLas predicciones son más confiables en regiones con alta densidad de estaciones (sur y Valle Central), mientras que la varianza y el coeficiente de variación son mayores en el norte y en áreas rurales o fronterizas, reflejando la menor disponibilidad de datos y la complejidad local de ciertas variables (como la velocidad del viento y la presión).\nLa temperatura es más alta en el sur del estado y en el Valle Central, mientras que la presión atmosférica alcanza valores mayores en la costa y el sur, y menores en las zonas de gran altitud del norte y este. La velocidad del viento muestra máximos en el Valle Central y el interior sur, reflejando la heterogeneidad espacial del comportamiento atmosférico en California.\nEl enfoque geoestadístico permitió cumplir los objetivos planteados: se identificaron patrones espaciales, se estimaron semivariogramas y se ajustaron modelos teóricos adecuados, y se construyeron mapas de predicción y de incertidumbre que representan de manera confiable la distribución espacial de las variables. Esto demuestra que la metodología es útil para caracterizar la variabilidad espacial de variables meteorológicas y contaminantes como el ozono, incluso en territorios extensos como California",
    "crumbs": [
      "Análisis Geoestadístico",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Análisis Univariado</span>"
    ]
  },
  {
    "objectID": "Geo_bi.html",
    "href": "Geo_bi.html",
    "title": "2  Análisis Bivariado",
    "section": "",
    "text": "2.1 Planteamiento del problema",
    "crumbs": [
      "Análisis Geoestadístico",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis Bivariado</span>"
    ]
  },
  {
    "objectID": "Geo_bi.html#modelos-univariados",
    "href": "Geo_bi.html#modelos-univariados",
    "title": "2  Análisis Bivariado",
    "section": "",
    "text": "2.1.1 Estacionariedad en Media\n\nTemperaturaVelocidad del viento\n\n\nEl modelo es: Temperatura = \\beta_0 + \\beta_1 \\times Norte + \\beta_2 \\times Norte^2\n\n\nVer código\nplot(temp, qt.col = c(\"purple\",\n                    \"pink\",\n                    \"green\",\n                    \"yellow\"),\n     scatter3d=T, trend=~Norte+I(Norte^2))\n\n\n\n\n\n\n\n\n\nVer código\nfitT &lt;- lm(Temperatura~Norte+I(Norte^2), data = datosT) \npander::pander(summary(fitT))\n\n\n\n\n\n\n\n\n\n\n\n\n \nEstimate\nStd. Error\nt value\nPr(&gt;|t|)\n\n\n\n\n(Intercept)\n13.26\n0.5352\n24.77\n8.812e-49\n\n\nNorte\n-2.229e-05\n3.23e-06\n-6.901\n2.676e-10\n\n\nI(Norte^2)\n-3.754e-11\n8.551e-12\n-4.39\n2.469e-05\n\n\n\n\nFitting linear model: Temperatura ~ Norte + I(Norte^2)\n\n\n\n\n\n\n\n\nObservations\nResidual Std. Error\nR^2\nAdjusted R^2\n\n\n\n\n122\n4.049\n0.3199\n0.3084\n\n\n\n\n\n\n\nEl modelo es: WindSpeed = \\beta_0 + \\beta_1 \\times Este + \\beta_2 \\times Norte + + \\beta_3 \\times Este \\times Norte\n\n\nVer código\nplot(temp, qt.col = c(\"purple\",\n                      \"pink\",\n                      \"green\",\n                      \"yellow\"),\n     scatter3d=T, trend=~Norte*Este)\n\n\n\n\n\n\n\n\n\nVer código\nfitWS &lt;- lm(WindSpeed~Este*Norte, data = datosWS) \npander::pander(summary(fitWS))\n\n\n\n\n\n\n\n\n\n\n\n\n \nEstimate\nStd. Error\nt value\nPr(&gt;|t|)\n\n\n\n\n(Intercept)\n6.398\n0.3639\n17.58\n4.751e-30\n\n\nEste\n2.069e-05\n2.674e-06\n7.739\n1.895e-11\n\n\nNorte\n1.159e-05\n1.808e-06\n6.411\n7.746e-09\n\n\nEste:Norte\n2.558e-11\n7.483e-12\n3.419\n0.000968\n\n\n\n\nFitting linear model: WindSpeed ~ Este * Norte\n\n\n\n\n\n\n\n\nObservations\nResidual Std. Error\nR^2\nAdjusted R^2\n\n\n\n\n89\n1.938\n0.4851\n0.4669\n\n\n\n\n\n\n\n\n\n\n2.1.2 Variogramas\n\n2.1.2.1 Temperatura\nPara esta variable ya se analizo y encontró un modelo apropiado en el capítulo 1.\n\n\n2.1.2.2 Velocidad del viento\n\n\nVer código\nvgO_WS &lt;- variog(ws,estimator.type = \"modulus\", pairs.min=50)\n\nvg1_WS &lt;- variog(ws, trend = ~Norte*Este,\n                estimator.type = \"modulus\", pairs.min=50)\n\n\n\nCon tendenciaSin tendencia\n\n\n\n\nVer código\nplot(vgO_WS,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Sin remover tendencia\",\n     col.main = 4, cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(vg1_WS,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Removiendo tendencia\",\n     col.main = 4, cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.1.2.2.1 Estimación teórica del semivariograma\nSe asume un modelo Coseno y Wave:\n\n\nVer código\n#Estimación del coseno ---------------------------------\n\nh_range &lt;- seq(0, max(vg1_WS$u), by = 1000)\n\nMSE_ponderados &lt;- function(par, h, gamma,kappa=NA,w, model, n, pesos){\n  nugget &lt;- par[1]\n  sigma &lt;- par[2]\n  phi &lt;- par[3]\n  \n  gamma_hat &lt;- switch(model,\n                      \"exponencial\" = sv_exp(nugget, sigma, h, phi),\n                      \"gaussian\"    = sv_gauss(nugget, sigma, h, phi),\n                      \"gneiting\"    = sv_gneiting(nugget, sigma, h, phi),\n                      \"spherical\"   = sv_spherical(nugget, sigma, h, phi),\n                      \"matern\"      = sv_matern(nugget, sigma, h, phi, kappa),\n                      \"cos\"         = cos_sv(nugget, sigma, h, phi)\n  )\n  \n  w &lt;- switch(pesos,\n              \"Cressie\" = 1/(2*(2*gamma_hat)^2/n),\n              \"n\" = 1/n,\n              \"h/n\" = 1/(h/n),\n              \"I\" = 1)\n  \n  sum(w*(gamma - gamma_hat)^2)\n}\n\n\nloglik &lt;- function(par, kappa=NA, z, dist_matrix, model){\n  sigma_0 &lt;- par[1]\n  phi_0 &lt;- par[2]\n  nugget_0 &lt;- par[3]\n  kappa_0 &lt;- kappa\n  \n  cov &lt;- switch(model,\n                \"exponencial\" = cov_exp,\n                \"gaussian\"    = cov_gauss,\n                \"spherical\"   = cov_spherical,\n                \"gneiting\"    = cov_gneiting,\n                \"matern\"      = cov_matern,\n                \"cos\"         = cov_cos \n  )\n  \n  args_cov &lt;- names(formals(cov))\n  \n  args_list &lt;- list(\n    sigma  = sigma_0,\n    nugget = nugget_0,\n    h      = dist_matrix,\n    phi    = phi_0,\n    kappa  = kappa_0\n  )\n  \n  args_list &lt;- args_list[names(args_list) %in% args_cov]\n  \n  Sigma &lt;- do.call(cov, args_list) \n  diag(Sigma) = diag(Sigma) + nugget_0\n  \n  if (!is.positive.definite(Sigma)) {\n    Sigma &lt;- as.matrix(nearPD(Sigma, corr = FALSE)$mat)\n  }\n  \n  # Descomposición de Cholesky (más estable que solve o det)\n  inv_Sigma &lt;- solve(Sigma)\n  det &lt;- log(det(Sigma))\n  \n  # Log-verosimilitud del modelo Gaussiano\n  z &lt;- z \n  n &lt;- length(z)\n  ll &lt;- -0.5 * (n * log(2 * pi) + det + crossprod(z, inv_Sigma %*% z))  # Log-verosimilitud (negativa porque optim minimiza)\n  return(-ll)\n}\n\nsv_ini &lt;- cos_sv(1.5, 1.5, vg1_WS$u, .6e5)\nn &lt;- vg1_WS$n\n\nvariog_WS &lt;- data.frame(h = vg1_WS$u, gamma_hat = vg1_WS$v,\n                       n = vg1_WS$n)\n\n# Cressie -------------------------------------------------\n\nWW &lt;- (2*(2*sv_ini)^2/n)\n\nBessel &lt;- nls(formula = gamma_hat ~cos_sv(nugget, sigma, h, phi),\n              start = c(nugget = 1.5, sigma = 1.5, phi = .6e5),\n              weights = 1/WW,\n              lower = rep(1e-6,3),\n              data = variog_WS,\n              control = nls.control(maxiter = 500, warnOnly = TRUE))\n\n\noptim_bessel &lt;- optim(\n  par = coef(Bessel),\n  fn = MSE_ponderados,\n  h = variog_WS$h,\n  gamma = variog_WS$gamma_hat,\n  pesos = \"Cressie\",\n  model = \"cos\",\n  n = n,\n  method = \"L-BFGS-B\",\n  lower = rep(1e-6,3)\n)\n\npar_optim_Bess &lt;- optim_bessel$par[c(\"nugget\", \"sigma\", \"phi\")]\n\n# 1/n ------------------------------------------------------\n\nW1 &lt;- n\n\nn_pond &lt;- nls(formula = gamma_hat ~cos_sv(nugget, sigma, h, phi),\n              start = c(nugget = 1.5, sigma = 1.5, phi = .6e5),\n              weights = 1/W1,\n              lower = rep(1e-6,3),\n              data = variog_WS,\n              control = nls.control(maxiter = 500, warnOnly = TRUE))\n\n\noptim_n &lt;- optim(\n  par = coef(n_pond),\n  fn = MSE_ponderados,\n  h = variog_WS$h,\n  gamma = variog_WS$gamma_hat,\n  pesos = \"n\",\n  model = \"cos\",\n  n = n,\n  method = \"L-BFGS-B\",\n  lower = rep(1e-6,3)\n)\n\npar_optim_n &lt;- optim_n$par[c(\"nugget\", \"sigma\", \"phi\")]\n\n# n/h -----------------------------------------------------\n\nW2 &lt;- variog_WS$h/n\n\nh_n_pond &lt;- nls(formula = gamma_hat ~cos_sv(nugget, sigma, h, phi),\n              start = c(nugget = 1.5, sigma = 1.5, phi = .6e5),\n              weights = 1/W2,\n              lower = rep(1e-6,3),\n              data = variog_WS,\n              control = nls.control(maxiter = 500, warnOnly = TRUE))\n\noptim_h_n &lt;- optim(\n  par = coef(h_n_pond),\n  fn = MSE_ponderados,\n  h = variog_WS$h,\n  gamma = variog_WS$gamma_hat,\n  pesos = \"h/n\",\n  model = \"cos\",\n  n = n,\n  method = \"L-BFGS-B\",\n  lower = rep(1e-6,3)\n)\n\npar_optim_h_n &lt;- optim_h_n$par[c(\"nugget\", \"sigma\", \"phi\")]\n\nI_pond &lt;- nls(formula = gamma_hat ~cos_sv(nugget, sigma, h, phi),\n              start = c(nugget = 1.5, sigma = 1.5, phi = .6e5),\n              lower = rep(1e-6,3),\n              data = variog_WS,\n              control = nls.control(maxiter = 500, warnOnly = TRUE))\n\n# MCO -----------------------------------------------------\n\noptim_I &lt;- optim(\n  par = coef(I_pond),\n  fn = MSE_ponderados,\n  h = variog_WS$h,\n  gamma = variog_WS$gamma_hat,\n  pesos = \"I\",\n  model = \"cos\",\n  n = n,\n  method = \"L-BFGS-B\",\n  lower = rep(1e-6,3)\n)\n\npar_optim_I &lt;- optim_I$par[c(\"nugget\", \"sigma\", \"phi\")]\n\nestcos_sv_Bess_WS &lt;- do.call(cos_sv, c(as.list(par_optim_Bess), list(h = h_range)))\nestcos_sv_n_WS &lt;- do.call(cos_sv, c(as.list(par_optim_n), list(h = h_range)))\nestcos_sv_h_n_WS &lt;- do.call(cos_sv, c(as.list(par_optim_h_n), list(h = h_range)))\nestcos_sv_I_WS &lt;- do.call(cos_sv, c(as.list(par_optim_I), list(h = h_range)))\n\n# Modelo wave ----------------------------------------------\n\nfitvar1 &lt;- variofit(vg1_WS,\n                    cov.model = \"wave\",\n                    c(3.5,.6e5),\n                    fix.nugget = F,\n                    wei = \"equal\")\nfitvar2 &lt;- variofit(vg1_WS,\n                    cov.model = \"wave\",\n                    c(3.5,.6e5),\n                    fix.nugget = F,\n                    wei = \"npairs\")\n\nfitvar3 &lt;- variofit(vg1_WS,\n                    cov.model = \"wave\",\n                    c(3.5,.6e5),\n                    fix.nugget = F,\n                    wei = \"cressie\")\n\nfitvar4_es_T &lt;- likfit(ws,\n                       coords = ws$coords,\n                       data = ws$data,\n                       trend = ~ Este*Norte,\n                       ini.cov.pars = c(3.5, .6e5),\n                       fix.nugget = F,\n                       nugget = 1.5,\n                       cov.model = \"wave\",\n                       lik.method = \"ML\")\n\n\n\nCoseno (Optim)Wave (GeoR)\n\n\n\n\nVer código\nplot(vg1_WS,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Removiendo tendencia\",\n     col.main = 4, cex.main =1.3)\nlines(h_range, estcos_sv_Bess_WS, col=\"#FF4040\", lwd=1.5)\nlines(h_range, estcos_sv_n_WS, col=\"#4169E1\", lwd=1.5)\nlines(h_range, estcos_sv_h_n_WS, col=\"#008B00\", lwd=1.5)\nlines(h_range, estcos_sv_I_WS, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"Cressie\", \"1/n\", \"n/h\", \"MCO\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(vg1_WS,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Removiendo tendencia\",\n     col.main = 4, cex.main =1.3)\n\nlines(fitvar1, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_es_T, col=\"#FFA500\", lwd=1.5)\n\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)",
    "crumbs": [
      "Análisis Geoestadístico",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis Bivariado</span>"
    ]
  },
  {
    "objectID": "Geo_bi.html#modelo-cruzado-de-semivarianza",
    "href": "Geo_bi.html#modelo-cruzado-de-semivarianza",
    "title": "2  Análisis Bivariado",
    "section": "2.3 Modelo cruzado de semivarianza",
    "text": "2.3 Modelo cruzado de semivarianza\nConsiderando un modelo esférico para Temperatura y un modelo Wave para WS, las matrices para el modelo de coregionalización son:\n\nmat1 &lt;- cbind(c(8, 3.5),\n              c(3.5, 1))\n\nmat2 &lt;-cbind(c(8, 3.5),\n             c(3.5, 1))\n\n\n\nVer código\ndatosT1 &lt;- datosT\ndatosWS1 &lt;- datosWS\ninvisible(coordinates(datosT1) &lt;- ~ Este + Norte)\ninvisible(coordinates(datosWS1) &lt;- ~ Este + Norte)\n\n\nvgmntemp &lt;- vgm(psill = mat1[1, 1],\n              model = \"Sph\",\n              range = 2e5,\n              nugget = .5,\n              add.to = vgm(psill = mat2[1, 1],\n                           model = \"Wav\",\n                           range = .5e5, nugget = 2))\n\nvgmws &lt;- vgm(psill = mat1[2, 2],\n             model = \"Sph\",\n             range = 2e5,\n             nugget = .5,\n             add.to = vgm(psill = mat2[2, 2],\n                          model = \"Wav\",\n                          range = .5e5, nugget = 2))\n\n\nvgmntemp_sv &lt;- vgm(psill = mat1[1, 2], model = \"Sph\",\n                 range = 2e5,\n                 nugget = .5,\n                 add.to = vgm(psill = mat2[1, 2],\n                              model = \"Wav\",\n                              range = .5e5, nugget = 2))\n\n\n\ng &lt;- gstat(NULL, id=\"Temp\", formula=Temperatura~Norte+I(Norte^2),\n           data=datosT1, model = vgmntemp)\ng &lt;- gstat(g, id=\"W_speed\", formula=WindSpeed~Norte*Este,\n           data=datosWS1, model = vgmws)\ng &lt;- gstat(g, c(\"Temp\",\"W_speed\"), model = vgmntemp_sv)\n\nplot(variogram(g),\n     model = g$model,\n     pl = F,\n     xlab = \"Distancias\",\n     ylab = \"Semivarianza\")",
    "crumbs": [
      "Análisis Geoestadístico",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis Bivariado</span>"
    ]
  },
  {
    "objectID": "Geo_uni.html#planteamiento-del-problema",
    "href": "Geo_uni.html#planteamiento-del-problema",
    "title": "1  Análisis Univariado",
    "section": "",
    "text": "1.1.1 Introducción\nLa calidad del aire influye directamente en la salud de las personas, en su bienestar y en el equilibrio del entorno. En California, este tema cobra especial relevancia: es uno de los estados más afectados por la contaminación atmosférica en Estados Unidos. Su alta densidad de población, el tráfico vehicular, la actividad industrial y fenómenos naturales como los incendios forestales hacen que muchas de sus ciudades enfrenten niveles preocupantes de contaminación.\nEl comportamiento de los contaminantes atmosféricos, como el ozono troposférico (O_3), depende en gran medida de las condiciones meteorológicas, entre ellas la temperatura, la velocidad del viento y la presión barométrica. Estas variables influyen en la dispersión y concentración de los contaminantes, generando patrones espaciales que pueden variar significativamente en función del tiempo y la ubicación. En este contexto, el análisis geoestadístico se presenta como una herramienta fundamental para identificar y modelar dichas dependencias espaciales, permitiendo estimar tendencias, ajustar modelos teóricos de variabilidad y construir mapas de predicción que aporten una comprensión más precisa de su comportamiento.\n\n\n1.1.2 Descripción de los datos\nLos datos objeto de este estudio provienen de la Agencia de Protección Ambiental (EPA) de los Estados Unidos y corresponden a registros horarios obtenidos de las estaciones de monitoreo durante el mes de marzo de 2024. En particular, se analizan las variables Temperatura ambiente (Temp), Ozono (O_3), Velocidad del viento (WS) y Presión barométrica.\n\n1.1.2.1 Unidades\n\nTemperatura ambiente: Medida en grados celsius (C°) con una intensidad horaria.\nOzono: Medida en partes por billón (ppb) con una intensidad horaria.\nVelocidad del viento: Medida en metros por segundo (m/s) con una intensidad horaria.\nPresión barométrica: Medida en milibares (mb) con una intensidad horaria.\n\n\n\n\n1.1.3 Objetivos\n\n1.1.3.1 Objetivo general\nEstudiar e identificar la tendencia y los patrones espaciales de las variables meteorológicas y del ozono troposférico (O_3) mediante el uso de herramientas de análisis geoestadístico, con el propósito de establecer modelos de predicción espacial que permitan caracterizar su comportamiento en el estado de California durante un periodo específico de tiempo de marzo de 2024.\n\n\n1.1.3.2 Objetivos específicos\n\nRealizar un análisis de estacionariedad en media, estudiando para cada variable la estructura de la media, identificando la existencia de dependencia espacial y modelándola en consecuencia.\nConstruir el semivariograma empírico a partir de los datos y ajustar un modelo teórico que describa la dependencia espacial de cada variable.\nAplicar la técnica de Kriging para construir los mapas de predicción espacial y los mapas de incertidumbre asociados, con el fin de representar la distribución esperada de las variables y evaluar la precisión de las estimaciones.",
    "crumbs": [
      "Análisis Geoestadístico",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Análisis Univariado</span>"
    ]
  },
  {
    "objectID": "Geo_bi.html#planteamiento-del-problema",
    "href": "Geo_bi.html#planteamiento-del-problema",
    "title": "2  Análisis Bivariado",
    "section": "",
    "text": "En desarrollo…\n\n\n\n\n\n\n\n2.1.1 Introducción\n\n\n\n\n\n\nEn desarrollo…\n\n\n\n\n\n\n\n\n2.1.2 Descripción de los datos\nLos datos objeto de este estudio provienen de la Agencia de Protección Ambiental (EPA) de los Estados Unidos y corresponden a registros horarios obtenidos de las estaciones de monitoreo durante el mes de marzo de 2024. En particular, se analizan las variables Temperatura ambiente (Temp) y Velocidad del viento (WS).\n\n2.1.2.1 Unidades\n\nTemperatura ambiente: Medida en grados celsius (C°) con una intensidad horaria.\nVelocidad del viento: Medida en metros por segundo (m/s) con una intensidad horaria.\n\n\n\n\n2.1.3 Objetivos\n\n2.1.3.1 Objetivo general\n\n\n\n\n\n\nEn desarrollo…\n\n\n\n\n\n\n\n\n2.1.3.2 Objetivos específicos\n\n\n\n\n\n\nEn desarrollo…",
    "crumbs": [
      "Análisis Geoestadístico",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis Bivariado</span>"
    ]
  },
  {
    "objectID": "Geo_bi.html#análisis-geoestadístico",
    "href": "Geo_bi.html#análisis-geoestadístico",
    "title": "2  Análisis Bivariado",
    "section": "2.2 Análisis Geoestadístico",
    "text": "2.2 Análisis Geoestadístico\nSe consideran las variables temperatura y velocidad del viento:\n\n\nVer código\nlibrary(readxl)\nlibrary(geoR)\nlibrary(matrixcalc)\nlibrary(dplyr)\nlibrary(geoR)\nlibrary(sp)\nlibrary(readxl)\nlibrary(tidyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(raster)\nlibrary(stars)\nlibrary(gstat)\n\n\ncov_cos &lt;- function(sigma, h, phi){\n  sigma * cos(h/phi)\n}\n\ncos_sv &lt;- function(nugget, sigma, h, phi){\n  nugget +  sigma *(1 - cos(h/phi))\n}\n\n#Variable Temperatura ---------------------------------------\n\nTemp &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Temperatura\")\ncolnames(Temp)[-1] &lt;- as.numeric(colnames(Temp)[-1])\nEstacionesT &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesT &lt;- EstacionesT %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesT &lt;- EstacionesT %&gt;% filter(AQSID %in% colnames(Temp)[-1])\n\ny_T &lt;- Temp[1,] #Tomar una fecha\ny_T &lt;- cbind(colnames(y_T),t(y_T[1,]))\ny_T &lt;- y_T[-1,]\ny_T &lt;- as.data.frame(y_T)\ny_T &lt;- na.omit(y_T)\ny_T &lt;- y_T[-which.min(y_T$V2),]\ny_T$V1 &lt;- as.numeric(y_T$V1)\ny_T &lt;- inner_join(y_T, EstacionesT, by=c(\"V1\"=\"AQSID\"))\ndatosT &lt;- y_T[,c(13,14,2)]\ncolnames(datosT)=c(\"Este\",\"Norte\",\"Temperatura\")\ndatosT$Temperatura &lt;- as.numeric(datosT$Temperatura)\n\ntemp &lt;- as.geodata(datosT)\n\n\n\n#Variable Velocidad del viento ------------------------------\n\nWS &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"WindSpeed\")\ncolnames(WS)[-1] &lt;- as.numeric(colnames(WS)[-1])\nEstacionesWS &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesWS &lt;- EstacionesWS %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesWS &lt;- EstacionesWS %&gt;% filter(AQSID %in% colnames(WS)[-1])\n\ny_WS &lt;- WS[1,] #Tomar una fecha\ny_WS &lt;- cbind(colnames(y_WS),t(y_WS[1,]))\ny_WS &lt;- y_WS[-1,]\ny_WS &lt;- as.data.frame(y_WS)\ny_WS &lt;- na.omit(y_WS)\ny_WS$V1 &lt;- as.numeric(y_WS$V1)\ny_WS &lt;- inner_join(y_WS, EstacionesWS, by=c(\"V1\"=\"AQSID\"))\ndatosWS &lt;- y_WS[,c(13,14,2)]\ncolnames(datosWS)=c(\"Este\",\"Norte\",\"WindSpeed\")\ndatosWS$WindSpeed &lt;- as.numeric(datosWS$WindSpeed)\n\nws &lt;- as.geodata(datosWS)\n\n\n\nTemperaturaVelocidad del viento\n\n\n\n\nVer código\npander::pander(summary(temp))\n\n\n\nn: 122\ncoords.summary:\n\n\n\n\n\n\n\n\n \nEste\nNorte\n\n\n\n\nmin\n-325701\n-580919\n\n\nmax\n387270\n281577\n\n\n\ndistances.summary:\n\n\n\n\n\n\n\nmin\nmax\n\n\n\n\n609.2\n1e+06\n\n\n\ndata.summary:\n\n\n\n\n\n\n\n\n\n\n\nMin.\n1st Qu.\nMedian\nMean\n3rd Qu.\nMax.\n\n\n\n\n-3.2\n13.15\n15.8\n14.43\n17.2\n24.5\n\n\n\n\n\n\n\n\n\n\n\nVer código\npander::pander(summary(ws))\n\n\n\nn: 89\ncoords.summary:\n\n\n\n\n\n\n\n\n \nEste\nNorte\n\n\n\n\nmin\n-276541\n-543973\n\n\nmax\n415574\n281577\n\n\n\ndistances.summary:\n\n\n\n\n\n\n\nmin\nmax\n\n\n\n\n2216\n987994\n\n\n\ndata.summary:\n\n\n\n\n\n\n\n\n\n\n\nMin.\n1st Qu.\nMedian\nMean\n3rd Qu.\nMax.\n\n\n\n\n0.8\n2.5\n3.8\n4.375\n5.5\n14.1\n\n\n\n\n\n\n\n\n\n\n\n2.2.1 Modelos Univariados\n\n2.2.1.1 Estacionariedad en Media\n\nTemperaturaVelocidad del viento\n\n\nEl modelo es: Temperatura = \\beta_0 + \\beta_1 \\times Norte + \\beta_2 \\times Norte^2\n\n\nVer código\nplot(temp, qt.col = c(\"purple\",\n                    \"pink\",\n                    \"green\",\n                    \"yellow\"),\n     scatter3d=T, trend=~Norte+I(Norte^2))\n\n\n\n\n\n\n\n\n\nVer código\nfitT &lt;- lm(Temperatura~Norte+I(Norte^2), data = datosT) \npander::pander(summary(fitT))\n\n\n\n\n\n\n\n\n\n\n\n\n \nEstimate\nStd. Error\nt value\nPr(&gt;|t|)\n\n\n\n\n(Intercept)\n13.26\n0.5352\n24.77\n8.812e-49\n\n\nNorte\n-2.229e-05\n3.23e-06\n-6.901\n2.676e-10\n\n\nI(Norte^2)\n-3.754e-11\n8.551e-12\n-4.39\n2.469e-05\n\n\n\n\nFitting linear model: Temperatura ~ Norte + I(Norte^2)\n\n\n\n\n\n\n\n\nObservations\nResidual Std. Error\nR^2\nAdjusted R^2\n\n\n\n\n122\n4.049\n0.3199\n0.3084\n\n\n\n\n\n\n\nEl modelo es: WindSpeed = \\beta_0 + \\beta_1 \\times Este + \\beta_2 \\times Norte + + \\beta_3 \\times Este \\times Norte\n\n\nVer código\nplot(temp, qt.col = c(\"purple\",\n                      \"pink\",\n                      \"green\",\n                      \"yellow\"),\n     scatter3d=T, trend=~Norte*Este)\n\n\n\n\n\n\n\n\n\nVer código\nfitWS &lt;- lm(WindSpeed~Este*Norte, data = datosWS) \npander::pander(summary(fitWS))\n\n\n\n\n\n\n\n\n\n\n\n\n \nEstimate\nStd. Error\nt value\nPr(&gt;|t|)\n\n\n\n\n(Intercept)\n6.398\n0.3639\n17.58\n4.751e-30\n\n\nEste\n2.069e-05\n2.674e-06\n7.739\n1.895e-11\n\n\nNorte\n1.159e-05\n1.808e-06\n6.411\n7.746e-09\n\n\nEste:Norte\n2.558e-11\n7.483e-12\n3.419\n0.000968\n\n\n\n\nFitting linear model: WindSpeed ~ Este * Norte\n\n\n\n\n\n\n\n\nObservations\nResidual Std. Error\nR^2\nAdjusted R^2\n\n\n\n\n89\n1.938\n0.4851\n0.4669\n\n\n\n\n\n\n\n\n\n\n2.2.1.2 Variogramas\n\n2.2.1.2.1 Temperatura\nPara esta variable ya se analizo y encontró un modelo apropiado en el Capítulo 1.\n\n\n2.2.1.2.2 Velocidad del viento\nPara esta variable ya se analizo y encontró un modelo apropiado en el Capítulo 1.\n\n\n\n\n2.2.2 Modelo cruzado de semivarianza\nConsiderando un modelo esférico para Temperatura y un modelo Wave para WS, las matrices para el modelo de coregionalización son:\n\nmat1 &lt;- cbind(c(8, 3.5),\n              c(3.5, 1))\n\nmat2 &lt;-cbind(c(8, 3.5),\n             c(3.5, 1))\n\n\n\nVer código\ndatosT1 &lt;- datosT\ndatosWS1 &lt;- datosWS\ninvisible(coordinates(datosT1) &lt;- ~ Este + Norte)\ninvisible(coordinates(datosWS1) &lt;- ~ Este + Norte)\n\n\nvgmntemp &lt;- vgm(psill = mat1[1, 1],\n              model = \"Sph\",\n              range = 2e5,\n              nugget = .5,\n              add.to = vgm(psill = mat2[1, 1],\n                           model = \"Wav\",\n                           range = .5e5, nugget = 2))\n\nvgmws &lt;- vgm(psill = mat1[2, 2],\n             model = \"Sph\",\n             range = 2e5,\n             nugget = .5,\n             add.to = vgm(psill = mat2[2, 2],\n                          model = \"Wav\",\n                          range = .5e5, nugget = 2))\n\n\nvgmntemp_sv &lt;- vgm(psill = mat1[1, 2], model = \"Sph\",\n                 range = 2e5,\n                 nugget = .5,\n                 add.to = vgm(psill = mat2[1, 2],\n                              model = \"Wav\",\n                              range = .5e5, nugget = 2))\n\n\n\ng &lt;- gstat(NULL, id=\"Temp\", formula=Temperatura~Norte+I(Norte^2),\n           data=datosT1, model = vgmntemp)\ng &lt;- gstat(g, id=\"W_speed\", formula=WindSpeed~Norte*Este,\n           data=datosWS1, model = vgmws)\ng &lt;- gstat(g, c(\"Temp\",\"W_speed\"), model = vgmntemp_sv)\n\nplot(variogram(g),\n     model = g$model,\n     pl = F,\n     xlab = \"Distancias\",\n     ylab = \"Semivarianza\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEn desarrollo…\n\n\n\n\n\n\n\n\n2.2.3 Cokriging\n\n\n\n\n\n\nEn desarrollo…",
    "crumbs": [
      "Análisis Geoestadístico",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis Bivariado</span>"
    ]
  },
  {
    "objectID": "Geo_bi.html#conclusiones",
    "href": "Geo_bi.html#conclusiones",
    "title": "2  Análisis Bivariado",
    "section": "2.3 Conclusiones",
    "text": "2.3 Conclusiones\n\n\n\n\n\n\nEn desarrollo…",
    "crumbs": [
      "Análisis Geoestadístico",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis Bivariado</span>"
    ]
  }
]