[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Estadística Espacial",
    "section": "",
    "text": "Contenido\nEn este documento tiene como objetivo ilustrar el recorrido de la implementación de la metodología y teoría vista durante el curso de Estadística Espacial. Se implementaran modelos de análisis geoestadístico univariados y bivariados, modelos de análisis espacio-temporal y de datos funcionales.",
    "crumbs": [
      "Contenido"
    ]
  },
  {
    "objectID": "Geo_uni.html",
    "href": "Geo_uni.html",
    "title": "1  Análisis Univariado",
    "section": "",
    "text": "1.1 Planteamiento del problema",
    "crumbs": [
      "Geoestadística",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Análisis Univariado</span>"
    ]
  },
  {
    "objectID": "Geo_uni.html#planteamiento-del-problema",
    "href": "Geo_uni.html#planteamiento-del-problema",
    "title": "1  Análisis Univariado",
    "section": "",
    "text": "1.1.1 Introducción\nLa calidad del aire influye directamente en la salud de las personas, en su bienestar y en el equilibrio del entorno. En California, este tema cobra especial relevancia: es uno de los estados más afectados por la contaminación atmosférica en Estados Unidos. Su alta densidad de población, el tráfico vehicular, la actividad industrial y fenómenos naturales como los incendios forestales hacen que muchas de sus ciudades enfrenten niveles preocupantes de contaminación.\nEl comportamiento de los contaminantes atmosféricos, como el ozono troposférico (O_3), depende en gran medida de las condiciones meteorológicas, entre ellas la temperatura, la velocidad del viento y la presión barométrica. Estas variables influyen en la dispersión y concentración de los contaminantes, generando patrones espaciales que pueden variar significativamente en función del tiempo y la ubicación. En este contexto, el análisis geoestadístico se presenta como una herramienta fundamental para identificar y modelar dichas dependencias espaciales, permitiendo estimar tendencias, ajustar modelos teóricos de variabilidad y construir mapas de predicción que aporten una comprensión más precisa de su comportamiento.\n\n\n1.1.2 Descripción de los datos\nLos datos objeto de este estudio provienen de la Agencia de Protección Ambiental (EPA) de los Estados Unidos y corresponden a registros horarios obtenidos de las estaciones de monitoreo durante el mes de marzo de 2024. En particular, se analizan las variables Temperatura ambiente (Temp), Ozono (O_3) y Velocidad del viento (WS).\n\n1.1.2.1 Unidades\n\nTemperatura ambiente: Medida en grados celsius (C°) con una intensidad horaria.\nOzono: Medida en partes por billón (ppb) con una intensidad horaria.\nVelocidad del viento: Medida en metros por segundo (m/s) con una intensidad horaria.\n\n\n\n\n1.1.3 Objetivos\n\n1.1.3.1 Objetivo general\nEstudiar e identificar la tendencia y los patrones espaciales de las variables meteorológicas y del ozono troposférico (O_3) mediante el uso de herramientas de análisis geoestadístico, con el propósito de establecer modelos de predicción espacial que permitan caracterizar su comportamiento en el estado de California durante un periodo específico de tiempo de marzo de 2024.\n\n\n1.1.3.2 Objetivos específicos\n\nRealizar un análisis de estacionariedad en media, estudiando para cada variable la estructura de la media, identificando la existencia de dependencia espacial y modelándola en consecuencia.\nConstruir el semivariograma empírico a partir de los datos y ajustar un modelo teórico que describa la dependencia espacial de cada variable.\nAplicar la técnica de Kriging para construir los mapas de predicción espacial y los mapas de incertidumbre asociados, con el fin de representar la distribución esperada de las variables y evaluar la precisión de las estimaciones.",
    "crumbs": [
      "Geoestadística",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Análisis Univariado</span>"
    ]
  },
  {
    "objectID": "Geo_uni.html#análisis-geoestadístico-univariado",
    "href": "Geo_uni.html#análisis-geoestadístico-univariado",
    "title": "1  Análisis Univariado",
    "section": "1.2 Análisis Geoestadístico Univariado",
    "text": "1.2 Análisis Geoestadístico Univariado\nEn el análisis se consideran los datos de todas las variables registrados a las 00:00 horas del 1 de marzo de 2024.\n\n\nVer código\n#Librerias necesarias ------------------------------------\n\nset.seed(123)\n\nlibrary(dplyr)\nlibrary(geoR)\nlibrary(sp)\nlibrary(readxl)\nlibrary(tidyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(raster)\nlibrary(stars)\nlibrary(terra)\nlibrary(gstat)\n\n#Variale Temperatura --------------------------------------\n\nTemp &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Temperatura\")\ncolnames(Temp)[-1] &lt;- as.numeric(colnames(Temp)[-1])\nEstacionesT &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesT &lt;- EstacionesT %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesT &lt;- EstacionesT %&gt;% filter(AQSID %in% colnames(Temp)[-1])\n\n#Variable Ozono ------------------------------------------\n\nOzono &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Ozono\")\ncolnames(Ozono)[-1] &lt;- as.numeric(colnames(Ozono)[-1])\nEstacionesOz &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesOz &lt;- EstacionesOz %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesOz &lt;- EstacionesOz %&gt;% filter(AQSID %in% colnames(Ozono)[-1])\n\n#Variable velocidad del viento ----------------------------\n\nWS &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"WindSpeed\")\ncolnames(WS)[-1] &lt;- as.numeric(colnames(WS)[-1])\nEstacionesWS &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesWS &lt;- EstacionesWS %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesWS &lt;- EstacionesWS %&gt;% filter(AQSID %in% colnames(WS)[-1])\n\n#Para el mapa de California -------------------------------\n\nsh_mundos&lt;-st_read(\"admin00.shp\",quiet=TRUE)\nsh_mundos &lt;- sh_mundos %&gt;% filter(CNTRY_NAME==\"United States\")\nsh_mundos &lt;- sh_mundos %&gt;% filter(ADMIN_NAME==\"California\")\n\nCRS_UTM_NY = \"+init=epsg:3310\"\n\nsh_mundos_wgs84 &lt;- st_transform(sh_mundos, crs = 4326)\n\nsh_mundos_utm &lt;- st_transform(sh_mundos, crs = CRS(\"EPSG:3310\"))\n\nsh_mundos_sp_utm &lt;- as(sh_mundos_utm, \"Spatial\")\n\nsh_mundos_utm_simple &lt;- st_union(sh_mundos_utm)\nsh_mundos_sp_utm_simple &lt;- as(sh_mundos_utm_simple, \"Spatial\")\n\n#Grilla para hacer kriging ------------------------------\n\nnew &lt;- sp::spsample(as(sh_mundos_utm, \"Spatial\"), n = 50000, type = \"regular\")\n\nproj4string(new) &lt;- CRS(\"EPSG:3310\")\ninvisible(coordinates(new) ~ Este + Norte)\ncolnames(new@coords) &lt;- c(\"Este\", \"Norte\")\n\n#Gráficos de dispersión ----------------------------------\n\nsimple_scatter_plot &lt;- function(datos, variable1, variable2) {\n\n    plot1 &lt;- ggplot(as.data.frame(datos),\n                    aes(x = .data[[variable1]], y = .data[[variable2]],\n                               color = as.factor(1))) +\n                    geom_point() +\n                    scale_colour_viridis_d() +\n                    labs(\n                        x = variable1,\n                        y = variable2\n                        ) +\n                    theme_light() +\n                    theme(legend.position = \"none\")\n\n    return(plot1)\n\n}\n\n#1. Funciones de correlación, covarianza y semivarianza: ------------------------\n\n#1.1 Modelo exponencial ----\n\nrho_exp &lt;- function(h, phi){\n  exp(-(h/phi)) #Correlacion espacial\n}\n\ncov_exp &lt;- function(sigma, h, phi){\n  sigma*rho_exp(h, phi) #Covarianza espacial\n}\n\nsv_exp &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_exp(sigma, h, phi) #Semivarianza espacial\n} \n\n#1.2 Modelo Gaussianio ----\n\nrho_gauss &lt;- function(h, phi){\n  exp(-(h/phi)^2)\n}\n\ncov_gauss &lt;- function(sigma, h, phi){\n  sigma*rho_gauss(h, phi) #Covarianza espacial\n}\n\nsv_gauss &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_gauss(sigma, h, phi) #Semivarianza espacial\n}\n#1.3 Modelo Gneting ----\n\ncov_gneiting &lt;- function(sigma, h, phi){\n  s &lt;- 1/phi\n  x &lt;- h *s\n  cov &lt;- ifelse(\n    0 &lt;= x & x &lt;= 1,\n    sigma*(1 + 8*x + 25*x^2 + 32*x^3) * (1 - x)^8,\n    0\n  )\n  return(cov)\n}\n\nsv_gneiting &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_gneiting(sigma, h, phi) #Semivarianza espacial\n}\n\n#1.4 Modelo Spherical ----\n\nrho_spherical &lt;- function(h, phi){\n  ifelse(h&lt;phi,\n         1 - 1.5*(h/phi) + 0.5*(h/phi)^3,\n         0)\n}\n\ncov_spherical &lt;- function(sigma, h, phi){\n  sigma*rho_spherical(h, phi) #Covarianza espacial\n}\n\nsv_spherical &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_spherical(sigma, h, phi) #Semivarianza espacial\n}\n\n#1.5 Modelo Matern ----\n\nrho_matern &lt;- function(h, phi, kappa){\n  (1/(2*gamma(kappa))) * (h/phi)^kappa * besselK((h/phi), kappa)\n}\n\ncov_matern &lt;- function(sigma, h, phi, kappa){\n  sigma*rho_matern(h, phi, kappa) #Covarianza espacial\n}\n\nsv_matern &lt;- function(nugget, sigma, h, phi, kappa){\n  nugget + sigma - cov_matern(sigma, h, phi, kappa) #Semivarianza espacial\n}\n\n#1.6 Modelo Coseno -----------------\n\ncov_cos &lt;- function(sigma, h, phi){\n  sigma * cos(h/phi)\n}\n\ncos_sv &lt;- function(nugget, sigma, h, phi){\n  nugget +  sigma *(1 - cos(2*pi*h/phi))\n}\n\n#1.7 Modelo wave ------\n\n\nrho_wave &lt;- function(h, sigma, phi){\n  ifelse(h == 0,\n         1,\n         (phi / h) * sin(h / phi))\n}\n\nsv_wave &lt;- function(nugget, sigma, h, phi) {\n  ifelse(h == 0,\n         nugget,\n         nugget + sigma - sigma * (phi / h) * sin(h / phi))\n}\n\ncov_wave &lt;- function(h, sigma, phi, nugget) {\n  ifelse(h == 0,\n         sigma,\n         sigma * (phi / h) * sin(h / phi))\n}\n\n\n#2. Función para estimar por WLS----\n\nMSE_ponderados &lt;- function(par, h, gamma,kappa=NA,w, model, n, pesos){\n  nugget &lt;- par[1]\n  sigma &lt;- par[2]\n  phi &lt;- par[3]\n  \n  gamma_hat &lt;- switch(model,\n                      \"exponencial\" = sv_exp(nugget, sigma, h, phi),\n                      \"gaussian\"    = sv_gauss(nugget, sigma, h, phi),\n                      \"gneiting\"    = sv_gneiting(nugget, sigma, h, phi),\n                      \"spherical\"   = sv_spherical(nugget, sigma, h, phi),\n                      \"matern\"      = sv_matern(nugget, sigma, h, phi, kappa),\n                      \"cos\"         = cos_sv(nugget, sigma, h, phi)\n  )\n  \n  w &lt;- switch(pesos,\n              \"Cressie\" = 1/(2*(2*gamma_hat)^2/n),\n              \"n\" = 1/n,\n              \"h/n\" = 1/(h/n),\n              \"I\" = 1)\n  \n  sum(w*(gamma - gamma_hat)^2)\n}\n\n\nest_sev_WLS &lt;- function(par, kappa = NA, model, h, gamma, n){\n  sigma_0 &lt;- par[1]\n  phi_0 &lt;- par[2]\n  nugget_0 &lt;- par[3]\n  kappa_0 &lt;- kappa\n  \n  # Selección de función\n  sv &lt;- switch(model,\n               \"exponencial\" = sv_exp,\n               \"gaussian\"    = sv_gauss,\n               \"spherical\"   = sv_spherical,\n               \"gneiting\"    = sv_gneiting,\n               \"matern\"      = sv_matern,\n               \"cos\" = cos_sv\n  )\n  \n  args_sv &lt;- names(formals(sv))\n  \n  args_list &lt;- list(\n    nugget = nugget_0,\n    sigma  = sigma_0,\n    h      = h,\n    phi    = phi_0,\n    kappa  = kappa_0\n  )\n  \n  args_list &lt;- args_list[names(args_list) %in% args_sv]\n  \n  sv_ini &lt;- do.call(sv, args_list)\n  \n  formula_sv &lt;- switch(model,\n                       \"gneiting\" = gamma ~ sv(nugget, sigma, h),\n                       \"matern\" = gamma ~ sv(nugget, sigma, h, phi, kappa),\n                       gamma ~ sv(nugget, sigma, h, phi)\n  )\n  \n  start_list &lt;- switch(model,\n                       \"gneting\" = list(nugget = nugget_0, sigma = sigma_0),\n                       \"matern\" = list(nugget = nugget_0, sigma = sigma_0, phi = phi_0, kappa = kappa_0),\n                       list(nugget = nugget_0, sigma = sigma_0, phi = phi_0)\n  )\n    \n    #1. Ponderación de Bessel\n    \n    WW &lt;- (2*(2*sv_ini)^2/n)\n    \n    Bessel &lt;- nls(formula = formula_sv,\n                  start = start_list,\n                  weights = 1/WW,\n                  lower = c(0, rep(1e-6, length(start_list)-1)),\n                  control = nls.control(maxiter = 500, warnOnly = TRUE))\n    \n    ini_Bessel&lt;-coef(Bessel)\n    \n    #1.1 Optim Bessel\n    \n    optim_bessel &lt;- optim(\n      par = coef(Bessel),\n      fn = MSE_ponderados,\n      h = h,\n      gamma = gamma,\n      pesos = \"Cressie\",\n      model = model,\n      n = n,\n      method = \"L-BFGS-B\",\n      lower = c(0, rep(1e-6, length(start_list)-1))\n    )\n    \n    par_optim_Bess &lt;- optim_bessel$par[c(\"nugget\", \"sigma\", \"phi\")]\n    \n    #2. Ponderación 1/n\n    \n    W1 &lt;- n\n    \n    n_pond &lt;- nls(formula = formula_sv,\n                  start = start_list,\n                  weights = 1/W1,\n                  lower = c(0, rep(1e-6, length(start_list)-1)),\n                  control = nls.control(maxiter = 500, warnOnly = TRUE))\n    \n    ini_n&lt;-coef(n_pond)\n    \n    #2.1 Optimización 1/n\n    \n    optim_n &lt;- optim(\n      par = coef(n_pond),\n      fn = MSE_ponderados,\n      h = h,\n      gamma = gamma,\n      pesos = \"n\",\n      n = n,\n      model = model,\n      method = \"L-BFGS-B\",\n      lower = c(0, rep(1e-6, length(start_list)-1))\n    )    \n    \n    par_optim_n &lt;- optim_n$par[c(\"nugget\", \"sigma\", \"phi\")]\n    \n    \n    #3. Ponderación h/n\n    \n    W2 &lt;- h/n\n    \n    h_n_pond &lt;- nls(formula = formula_sv,\n                    start = start_list,\n                    weights = 1/W2,\n                    lower = c(0, rep(1e-6, length(start_list)-1)),\n                    control = nls.control(maxiter = 500, warnOnly = TRUE))\n    \n    ini_h_n&lt;-coef(h_n_pond)\n    \n    optim_h_n &lt;- optim(\n      par = coef(h_n_pond),\n      fn = MSE_ponderados,\n      h = h,\n      gamma = gamma,\n      pesos = \"h/n\",\n      model = model,\n      n = n,\n      method = \"L-BFGS-B\",\n      lower = c(0, rep(1e-6, length(start_list)-1))\n    )    \n    \n    par_optim_h_n &lt;- optim_h_n$par[c(\"nugget\", \"sigma\", \"phi\")]\n    \n\nres &lt;- list(Bessel = list(Iniciales = ini_Bessel,\n                           Optimizados = par_optim_Bess),\n            `1/n` = list(Iniciales = ini_n,\n                          Optimizados = par_optim_n),\n            `h/n` = list(Iniciales = ini_h_n,\n                          Optimizados = par_optim_h_n))    \nreturn(res)\n}\n\nMSE_sv &lt;- function(gamma_hat, par, kappa, model, h){\n  sigma_0 &lt;- par[[2]]\n  phi_0 &lt;- par[[3]]\n  nugget_0 &lt;- par[[1]]\n  kappa_0 &lt;- kappa\n  \n  sv &lt;- switch(model,\n               \"exponencial\" = sv_exp,\n               \"gaussian\"    = sv_gauss,\n               \"spherical\"   = sv_spherical,\n               \"gneiting\"    = sv_gneiting,\n               \"matern\"      = sv_matern,\n               \"cos\" = cos_sv,\n               \"wave\" = sv_wave\n  )\n  \n  args_sv &lt;- names(formals(sv))\n  \n  args_list &lt;- list(\n    nugget = nugget_0,\n    sigma  = sigma_0,\n    h      = h,\n    phi    = phi_0,\n    kappa  = kappa_0\n  )\n  \n  args_list &lt;- args_list[names(args_list) %in% args_sv]\n  \n  sv_est &lt;- do.call(sv, args_list)\n  \n  return(mean((sv_est-gamma_hat)^2))\n}\n\n#3. Función para etimar por máxima verosimilitud\n\nloglik &lt;- function(par, kappa=NA, z, dist_matrix, model){\n  sigma_0 &lt;- par[1]\n  phi_0 &lt;- par[2]\n  nugget_0 &lt;- par[3]\n  kappa_0 &lt;- kappa\n  \n  cov &lt;- switch(model,\n               \"exponencial\" = cov_exp,\n               \"gaussian\"    = cov_gauss,\n               \"spherical\"   = cov_spherical,\n               \"gneiting\"    = cov_gneiting,\n               \"matern\"      = cov_matern\n  )\n  \n  args_cov &lt;- names(formals(cov))\n  \n  args_list &lt;- list(\n    sigma  = sigma_0,\n    nugget = nugget_0,\n    h      = dist_matrix,\n    phi    = phi_0,\n    kappa  = kappa_0\n  )\n  \n  args_list &lt;- args_list[names(args_list) %in% args_cov]\n  \n  Sigma &lt;- do.call(cov, args_list) \n  diag(Sigma) = diag(Sigma) + nugget_0\n  \n  # Descomposición de Cholesky (más estable que solve o det)\n  inv_Sigma &lt;- solve(Sigma)\n  det &lt;- log(det(Sigma))\n  \n  # Log-verosimilitud del modelo Gaussiano\n  z &lt;- z \n  n &lt;- length(z)\n  ll &lt;- -0.5 * (n * log(2 * pi) + det + crossprod(z, inv_Sigma %*% z))  # Log-verosimilitud (negativa porque optim minimiza)\n  return(-ll)\n}\n\n#Función para presentar las métricas de predicción----\n\nmetricas_cv &lt;- function(cv) {\n  data.frame(\n    ME = mean(cv$residual),\n    MAE = mean(abs(cv$residual)),\n    RMSE = sqrt(mean(cv$residual^2)),\n    R2 = 1 - var(cv$residual) / var(cv$observed),\n    MPSE = mean(cv@data$residual^2 / cv@data$var1.var),\n    COR = cor(cv@data$var1.pred, cv@data$observed)\n  )\n}\n\n\n\n1.2.1 Variable Ozono\nEn el siguiente mapa se presenta la distribución territorial de las estaciones de Ozono, así mismo como sus valores muestrales:\n\n\nVer código\ny_oz &lt;- Ozono[1,] #Tomar una fecha\ny_oz &lt;- cbind(colnames(y_oz),t(y_oz[1,]))\ny_oz &lt;- y_oz[-1,]\ny_oz &lt;- as.data.frame(y_oz)\ny_oz &lt;- na.omit(y_oz)\ny_oz$V1 &lt;- as.numeric(y_oz$V1)\ny_oz &lt;- inner_join(y_oz, EstacionesOz, by=c(\"V1\"=\"AQSID\"))\ndatosOZ &lt;- y_oz[,c(13,14,2)] #DatosOz es la base con coordenadas + variable\ncolnames(datosOZ)=c(\"Este\",\"Norte\",\"Ozono\")\ndatosOZ$Ozono &lt;- as.numeric(datosOZ$Ozono)\n\ndatosOZ_sf &lt;- st_as_sf(datosOZ, coords = c(\"Este\", \"Norte\"), crs = 3310)\n\ndatosO_sf_wgs84 &lt;- st_transform(datosOZ_sf, crs = 4326)\n\npalO &lt;- colorNumeric(palette = \"viridis\", domain = datosO_sf_wgs84$Ozono)\n\nleaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = \"black\", weight = 2) %&gt;%\n  addCircleMarkers(data = datosO_sf_wgs84,\n                   fillColor = ~palO(Ozono),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"Ozono:\", Ozono, \"°C\")) %&gt;%\n  addLegend(pal = palO, values = datosO_sf_wgs84$Ozono, title = \"Ozono (ppb)\")\n\n\n\n\n\n\nLos datos observados son trabajados en el formato geodata mediante el uso de la función as.geodata() del paquete GeoR. El resumen de las coordenadas y la variable Ozono se presenta tabularmente en seguida:\n\n\nVer código\nozone &lt;- as.geodata(datosOZ) \npander::pander(summary(ozone))\n\n\n\nn: 139\ncoords.summary:\n\n\n\n\n\n\n\n\n \nEste\nNorte\n\n\n\n\nmin\n-276541\n-598934\n\n\nmax\n500862\n415184\n\n\n\ndistances.summary:\n\n\n\n\n\n\n\nmin\nmax\n\n\n\n\n6305\n1187480\n\n\n\ndata.summary:\n\n\n\n\n\n\n\n\n\n\n\nMin.\n1st Qu.\nMedian\nMean\n3rd Qu.\nMax.\n\n\n\n\n20\n35\n38\n37.48\n40.5\n53\n\n\n\n\n\n\n\n\n1.2.1.1 Análisis de Estacionariedad en Media\nAhora, se procede a revisar el comportamiento de la media de la variable con respecto a las coordenadas Este y Norte. Para entender de mejor manera la distribución de la variable ozono se presentan la matriz de correlación muestral y los siguientes gráficos:\n\nMatrizGráficos de dispersiónGeoR\n\n\n\n\nVer código\npander::pander(cor(datosOZ))\n\n\n\n\n\n\n\n\n\n\n\n \nEste\nNorte\nOzono\n\n\n\n\nEste\n1\n-0.8322\n0.5718\n\n\nNorte\n-0.8322\n1\n-0.4797\n\n\nOzono\n0.5718\n-0.4797\n1\n\n\n\n\n\n\n\n\n\nVer código\npO1 &lt;- simple_scatter_plot(datosOZ, \"Este\", \"Ozono\")\npO2 &lt;- simple_scatter_plot(datosOZ, \"Norte\", \"Ozono\")\n\ncowplot::plot_grid(pO1,pO2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(ozone, qt.col = c(\"purple\",\n                          \"pink\",\n                          \"green\",\n                          \"yellow\"),\n     scatter3d=T)\n\n\n\n\n\n\n\n\n\n\n\n\nEn el gráfico se observa una relación polinomial de la variable Ozono con respecto a las coordenadas en Norte, mientras que con respecto a las coordenadas en Este se observa una correlación lineal. Se prueba con varios modelos hasta encontrar aquel que mitigue el efecto espacial de mejor manera.\n\n1.2.1.1.1 Ajuste del Modelo\nEl modelo que mejor atrapa el efecto de la media es:\nOzono = \\beta_0+\\beta_1 \\times Norte^2 + \\beta_2 \\times Norte^3 + \\beta_3 \\times Este\n\n\nVer código\nfitO &lt;- lm(Ozono~I(Norte^2)+I(Norte^3)+Este, data = datosOZ) \npander::pander(summary(fitO))\n\n\n\n\n\n\n\n\n\n\n\n\n \nEstimate\nStd. Error\nt value\nPr(&gt;|t|)\n\n\n\n\n(Intercept)\n34.99\n0.6033\n58\n2.656e-97\n\n\nI(Norte^2)\n5.085e-11\n1.078e-11\n4.716\n5.931e-06\n\n\nI(Norte^3)\n7.94e-17\n1.922e-17\n4.131\n6.297e-05\n\n\nEste\n1.416e-05\n3.326e-06\n4.257\n3.855e-05\n\n\n\n\nFitting linear model: Ozono ~ I(Norte^2) + I(Norte^3) + Este\n\n\n\n\n\n\n\n\nObservations\nResidual Std. Error\nR^2\nAdjusted R^2\n\n\n\n\n139\n3.984\n0.4223\n0.4094\n\n\n\n\n\nSe observa que todos los coeficientes del modelo resultan estadísticamente significativos. Además, aunque el valor de R^2 (0.42) no es particularmente alto, es lo suficientemente representativo como para considerar que el ajuste del modelo fue adecuado y aporta información relevante sobre el fenómeno analizado.\n\nGráficos de dispersiónGeoR\n\n\n\n\nVer código\ndatosOZ$Residuos &lt;- fitO$residuals\n\npO1 &lt;- simple_scatter_plot(datosOZ, \"Este\", \"Residuos\")\npO2 &lt;- simple_scatter_plot(datosOZ, \"Norte\", \"Residuos\")\n\ncowplot::plot_grid(pO1,pO2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(ozone, qt.col = c(\"purple\",\n                          \"pink\",\n                          \"green\",\n                          \"yellow\"),\n     scatter3d=T, trend = ~ poly(Norte,3))\n\n\n\n\n\n\n\n\n\n\n\n\nEn los gráficos de dispersión, usando ggplot y geoR, se aprecia también una notable mitigación del efecto de las coordenadas sobre la variable ozono, lo que sugiere que la estructura espacial de la media fue modelada de manera adecuada..\n\n\n\n1.2.1.2 Estudio del Semivariograma\n\n1.2.1.2.1 Estimación Empírica del Semivariograma\nA continuación, se presenta la estimación del semivariograma obtenida con la función variog(). Para asegurar la fiabilidad de los resultados, se especifican los argumentos estimator.type = \"modulus\" y pairs.min=50, con el fin de utilizar un estimador robusto y garantizar un número mínimo adecuado de pares en cada intervalo de distancia.\n\n\nVer código\nvg_O &lt;- variog(ozone,estimator.type = \"modulus\", pairs.min=50) #Sin tendencia espacial\n\nvg1_O &lt;- variog(ozone, trend = ~I(Norte^2)+I(Norte^3)+Este, estimator.type = \"modulus\", pairs.min=50)\n\n\n\nCon tendenciaRemoviendo Tendencia\n\n\n\n\nVer código\nplot(vg_O,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Sin remover tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(vg1_O,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Removiendo tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\nSe observa que la estimación de la varianza de la variable incrementos es más estable y presenta valores más bajos al remover la tendencia, lo que indica que en este caso el semivariograma refleja de manera más adecuada la verdadera estructura espacial del fenómeno.\n\n\n1.2.1.2.2 Estimación del Modelo Teórico de Semivariograma\nPara obtener unos valores iniciales de los modelos teóricos se usa la función EyeFit() de la librería GeoR.\nLos modelos obtenidos ajustando por EyeFit(), son:\n\ncov.model sigmasq phi tausq kappa kappa2 practicalRange\n1 matern 17.0 440676.0 5 0.5 NA 1320147\n2 gneiting 17.5 803585.6 9 NA NA 1371348\n3 exponential 10 6e5 10 NA NA 1320147\n\n\nMaternGneitingExponencial\n\n\n\n\nVer código\nvariog_O &lt;- data.frame(h = vg1_O$u, gamma_hat = vg1_O$v,\n                       n = vg1_O$n)\n\nsigma_0_mO &lt;- 12.0\nphi_0_mO &lt;- 224249.7\nnugget_0_mO &lt;- 2.00 \nkappa_0_mO &lt;- 0.2\n\nini1_mat_O &lt;- c(sigma_0_mO, phi_0_mO)\nfitvar1_mat_O &lt;- variofit(vg1_O,\n                    cov.model = \"matern\",\n                    ini1_mat_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_mO,\n                    kappa = kappa_0_mO,\n                    wei = \"equal\")\n\nfitvar2_mat_O &lt;- variofit(vg1_O,\n                    cov.model = \"matern\",\n                    ini1_mat_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_mO,\n                    kappa = kappa_0_mO,\n                    wei = \"npairs\")\n\nfitvar3_mat_O &lt;- variofit(vg1_O,\n                    cov.model = \"matern\",\n                    ini1_mat_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_mO,\n                    kappa = kappa_0_mO,\n                    wei = \"cressie\")\n\nfitvar4_mat_O &lt;- likfit(ozone,\n                  coords = ozone$coords,\n                  data = ozone$data,\n                  trend = ~ I(Norte^2) + I(Norte^3) + Este,\n                  ini.cov.pars = ini1_mat_O,\n                  fix.nugget = F,\n                  nugget = nugget_0_mO,\n                  kappa = kappa_0_mO,\n                  cov.model = \"matern\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_O,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_mat_O, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_mat_O, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_mat_O, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_mat_O, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Om &lt;- c(fitvar1_mat_O$nugget, fitvar1_mat_O$cov.pars[1], fitvar1_mat_O$cov.pars[2], fitvar1_mat_O$kappa)\npar2Om &lt;- c(fitvar2_mat_O$nugget, fitvar2_mat_O$cov.pars[1], fitvar2_mat_O$cov.pars[2],fitvar2_mat_O$kappa)\npar3Om &lt;- c(fitvar3_mat_O$nugget, fitvar3_mat_O$cov.pars[1], fitvar3_mat_O$cov.pars[2],fitvar3_mat_O$kappa)\npar4Om &lt;- c(fitvar4_mat_O$nugget, fitvar4_mat_O$cov.pars[1], fitvar4_mat_O$cov.pars[2],fitvar4_mat_O$kappa)\n\nresumen_O_m &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1Om,\n    par2Om,\n    par3Om,\n    par4Om\n  ),\n  MSE = c(\n    mean((par1Om[1]+par1Om[2]-cov.spatial(variog_O$h, cov.model = \"matern\", cov.pars = par1Om[c(2,3)], kappa = par1Om[4])-variog_O$gamma_hat)^2),\n    mean((par2Om[1]+par2Om[2]-cov.spatial(variog_O$h, cov.model = \"matern\", cov.pars = par2Om[c(2,3)], kappa = par2Om[4])-variog_O$gamma_hat)^2),\n    mean((par3Om[1]+par3Om[2]-cov.spatial(variog_O$h, cov.model = \"matern\", cov.pars = par3Om[c(2,3)], kappa = par3Om[4])-variog_O$gamma_hat)^2),\n     mean((par4Om[1]+par4Om[2]-cov.spatial(variog_O$h, cov.model = \"matern\", cov.pars = par4Om[c(2,3)], kappa = par4Om[4])-variog_O$gamma_hat)^2)\n  )\n)\n\nresumen_O_m &lt;- as.data.frame(resumen_O_m)\nresumen_O_m[ , -1] &lt;- lapply(resumen_O_m[ , -1], function(x) round(as.numeric(x), 3))\nkable(resumen_O_m, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"Kappa\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nKappa\nMSE\n\n\n\n\nMCO\n1.863\n53.490\n13147381.6\n0.2\n5.475\n\n\n1/n\n3.789\n35.449\n8696936.7\n0.2\n7.114\n\n\nCressie\n2.872\n12.025\n224249.7\n0.2\n14.639\n\n\nMLE\n0.000\n68.806\n224249.7\n0.2\n2216.497\n\n\n\n\n\n\n\n\n\nVer código\nsigma_0_gO &lt;- 17.5\nphi_0_gO &lt;- 803585.6\nnugget_0_gO &lt;- 9\n\nini1_g_O &lt;- c(sigma_0_gO, phi_0_gO)\nfitvar1_g_O &lt;- variofit(vg1_O,\n                    cov.model = \"gneiting\",\n                    ini1_g_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_gO,\n                    wei = \"equal\")\n\nfitvar2_g_O &lt;- variofit(vg1_O,\n                    cov.model = \"gneiting\",\n                    ini1_g_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_gO,\n                    wei = \"npairs\")\n\nfitvar3_g_O &lt;- variofit(vg1_O,\n                    cov.model = \"gneiting\",\n                    ini1_g_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_gO,\n                    wei = \"cressie\")\n\nfitvar4_g_O &lt;- likfit(ozone,\n                  coords = ozone$coords,\n                  data = ozone$data,\n                  trend = ~ I(Norte^2) + I(Norte^3) + Este,\n                  ini.cov.pars = ini1_g_O,\n                  fix.nugget = F,\n                  nugget = nugget_0_gO,\n                  cov.model = \"gneiting\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_O,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_g_O, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_g_O, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_g_O, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_g_O, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Og &lt;- c(fitvar1_g_O$nugget, fitvar1_g_O$cov.pars[1], fitvar1_g_O$cov.pars[2])\npar2Og &lt;- c(fitvar2_g_O$nugget, fitvar2_g_O$cov.pars[1], fitvar2_g_O$cov.pars[2])\npar3Og &lt;- c(fitvar1_g_O$nugget, fitvar3_g_O$cov.pars[1], fitvar3_g_O$cov.pars[2])\npar4Og &lt;- c(fitvar4_g_O$nugget, fitvar4_g_O$cov.pars[1], fitvar4_g_O$cov.pars[2])\n\nresumen_O_g &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1Og,\n    par2Og,\n    par3Og,\n    par4Og\n  ),\n  MSE = c(\n    mean((par1Og[1]+par1Og[2]-cov.spatial(variog_O$h, cov.model = \"gneiting\", cov.pars = par1Og[c(2,3)])-variog_O$gamma_hat)^2),\n    mean((par2Og[1]+par2Og[2]-cov.spatial(variog_O$h, cov.model = \"gneiting\", cov.pars = par2Og[c(2,3)])-variog_O$gamma_hat)^2),\n    mean((par3Og[1]+par3Og[2]-cov.spatial(variog_O$h, cov.model = \"gneiting\", cov.pars = par3Og[c(2,3)])-variog_O$gamma_hat)^2),\n     mean((par4Og[1]+par4Og[2]-cov.spatial(variog_O$h, cov.model = \"gneiting\", cov.pars = par4Og[c(2,3)])-variog_O$gamma_hat)^2)\n  )\n)\n\nresumen_O_g &lt;- as.data.frame(resumen_O_g)\nresumen_O_g[ , -1] &lt;- lapply(resumen_O_g[ , -1], function(x) round(as.numeric(x), 3))\nkable(resumen_O_g, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n9.591\n17.140\n855834.6\n2.836\n\n\n1/n\n10.024\n172.640\n3276275.0\n3.696\n\n\nCressie\n9.591\n14.366\n803585.6\n3.260\n\n\nMLE\n14.000\n506.520\n803587.0\n45739.365\n\n\n\n\n\n\n\n\n\nVer código\nsigma_0_lO &lt;- 10\nphi_0_lO &lt;- 6e5\nnugget_0_lO &lt;- 10\n\nini1_l_O &lt;- c(sigma_0_lO, phi_0_lO)\nfitvar1_l_O &lt;- variofit(vg1_O,\n                    cov.model = \"exponential\",\n                    ini1_l_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_lO,\n                    wei = \"equal\")\n\nfitvar2_l_O &lt;- variofit(vg1_O,\n                    cov.model = \"exponential\",\n                    ini1_l_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_lO,\n                    wei = \"npairs\")\n\nfitvar3_l_O &lt;- variofit(vg1_O,\n                    cov.model = \"exponential\",\n                    ini1_l_O,\n                    fix.nugget = F,\n                    nugget = nugget_0_lO,\n                    wei = \"cressie\")\n\nfitvar4_l_O &lt;- likfit(ozone,\n                  coords = ozone$coords,\n                  data = ozone$data,\n                  trend = ~ I(Norte^2) + I(Norte^3) + Este,\n                  ini.cov.pars = ini1_l_O,\n                  fix.nugget = F,\n                  nugget = nugget_0_lO,\n                  cov.model = \"exponential\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_O,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_l_O, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_l_O, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_l_O, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_l_O, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Oexp &lt;- c(fitvar1_l_O$nugget, fitvar1_l_O$cov.pars[1], fitvar1_l_O$cov.pars[2])\npar2Oexp &lt;- c(fitvar2_l_O$nugget, fitvar2_l_O$cov.pars[1], fitvar2_l_O$cov.pars[2])\npar3Oexp &lt;- c(fitvar1_l_O$nugget, fitvar3_l_O$cov.pars[1], fitvar3_l_O$cov.pars[2])\npar4Oexp &lt;- c(fitvar4_l_O$nugget, fitvar4_l_O$cov.pars[1], fitvar4_l_O$cov.pars[2])\n\nresumen_O_exp &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1Oexp,\n    par2Oexp,\n    par3Oexp,\n    par4Oexp\n  ),\n  MSE = c(\n    mean((par1Oexp[1]+par1Oexp[2]-cov.spatial(variog_O$h, cov.model = \"exponential\", cov.pars = par1Oexp[c(2,3)])-variog_O$gamma_hat)^2),\n    mean((par2Oexp[1]+par2Oexp[2]-cov.spatial(variog_O$h, cov.model = \"exponential\", cov.pars = par2Oexp[c(2,3)])-variog_O$gamma_hat)^2),\n    mean((par3Oexp[1]+par3Oexp[2]-cov.spatial(variog_O$h, cov.model = \"exponential\", cov.pars = par3Oexp[c(2,3)])-variog_O$gamma_hat)^2),\n     mean((par4Oexp[1]+par4Oexp[2]-cov.spatial(variog_O$h, cov.model = \"exponential\", cov.pars = par4Oexp[c(2,3)])-variog_O$gamma_hat)^2)\n  )\n)\n\nresumen_O_exp &lt;- as.data.frame(resumen_O_exp)\nresumen_O_exp[ , -1] &lt;- lapply(resumen_O_exp[ , -1], function(x) round(as.numeric(x), 3))\nkable(resumen_O_exp, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n7.838\n121.907\n8214726.4\n3.560\n\n\n1/n\n7.388\n13.033\n600000.0\n6.737\n\n\nCressie\n7.838\n11.486\n600000.0\n8.208\n\n\nMLE\n4.317\n128.551\n599998.9\n3740.136\n\n\n\n\n\n\n\n\nSe observa que los modelos Exponencial y Gneiting presentan un menor error cuadrático medio, sin embargo, ambos modelos presentan un nugget considerablemente alto en relación a la magnitud de la semivarianza observada. Por esta razón se opta por utilizar el modelo Matern para realizar la predicción.\n\n\n\n1.2.1.3 Kriging\nEl modelo Matern, con los parámetros obtenidos por MCO, que se usará para realizar Kriging es el siguiente:\n\n\n\n\n\n\n\n\n\nPara realizar la predicción, se genera una muestra aleatoria de puntos dentro del polígono que delimita el estado de California mediante la función spsample() del paquete sp. Sobre estos puntos se estiman los valores esperados aplicando el método de Kriging de vecinos cercanos, con el fin de mejorar la precisión de las estimaciones al considerar las grandes distancias características del territorio californiano. El procedimiento se implementa mediante la función krige() de gstat, especifícando la opción nmin=20 y utilizando la función predict() de base de R.\n\n\nVer código\n#Se ajusta el mejor modelo -------------------------------\n\nbest_model_O &lt;- gstat::vgm(psill = fitvar1_mat_O$cov.pars[1],\n                           model = \"Mat\",\n                           range = fitvar1_mat_O$cov.pars[2],\n                           nugget = fitvar1_mat_O$nugget,\n                           kappa = fitvar1_mat_O$kappa\n                           \n)\n\n# Se crea un objeto en gstat ------------------------------\n\ncoordinates(datosOZ) &lt;- ~Este + Norte\nproj4string(datosOZ) &lt;- CRS(\"EPSG:3310\")\n\ng_obj&lt;-gstat::gstat(id=\"Ozono\",\n             formula = Ozono ~ I(Norte^2) + I(Norte^3) + Este,\n             model = best_model_O,\n             data = datosOZ)\n\n#Kriging ------------------------------------------------\n\ninvisible(predic &lt;- predict(g_obj, newdata = new, nmin = 20))\n\n\n#Mapas de predicción -------------------------------------\n\ngridded(predic) &lt;- TRUE\n\n#1. Mapa de Kriging --------------------------------------\n\npredic_raster_utm &lt;- raster(predic, layer = \"Ozono.pred\")\n\ncrs(predic_raster_utm) &lt;- \"+init=epsg:3310\"\n\npredic_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        predic_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmin_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='min')\nmax_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='max')\n\npred_range &lt;- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))\n\nstep_pred &lt;- (max_pred-min_pred)/ 6\n\nbins &lt;- round(seq(min_pred, max_pred, by=step_pred),0)\n\npal_pred &lt;- colorBin(\n  palette = \"viridis\", # La paleta de colores\n  domain = pred_range,\n  bins = bins,\n  na.color = \"transparent\"\n)\n\nmapa_kriging_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    predic_raster_wgs84, \n    colors = pal_pred, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n    addCircleMarkers(data = datosO_sf_wgs84,\n                   fillColor = ~palO(Ozono),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"Ozn:\", Ozono, \"ppb\")) %&gt;% \n  \n  addLegend(\n    pal = pal_pred, \n    values = pred_range,\n    title = \"Predicción Oz ppb\",\n    position = \"topright\"\n  ) %&gt;%\n  \n  addLegend(pal = palO,\n            values = datosO_sf_wgs84$Ozono,\n            title = \"Ozono Observado\",\n    position = \"topleft\"\n  ) \n\n#2 Mapa Varianza------------------------------------------\n\nvar_raster_utm &lt;- raster(predic, layer = \"Ozono.var\")\n\ncrs(var_raster_utm) &lt;- \"+init=epsg:3310\"\n\nvar_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        var_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmax_var &lt;- raster::cellStats(var_raster_wgs84, stat='max')\nstep_var &lt;- max_var / 6\n\nbinsv &lt;- round(seq(0, max_var, by=step_var),2)\n\nvar_range &lt;- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))\npal_var &lt;- colorBin(\n  palette = \"Spectral\", # La paleta de colores\n  domain = var_range,\n  bins = binsv,\n  na.color = \"transparent\"\n)\n\nmapa_var_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    var_raster_wgs84,\n    colors = pal_var, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  addLegend(\n    pal = pal_var, \n    values = var_range,\n    title = \"Varianza\",\n    position = \"topright\"\n  ) \n\n#3. Mapa Cv ----------------------------------------------\n\ncv_raster_utm &lt;- sqrt(var_raster_utm) / abs(predic_raster_utm)\n\nmapa_mayor_a_uno &lt;- cv_raster_utm &gt; 1\ncv_raster_utm[mapa_mayor_a_uno] &lt;- 1\n\ncrs(cv_raster_utm) &lt;- \"+init=epsg:3310\"\n\ncv_terra &lt;- terra::rast(cv_raster_utm)\nsh_terra &lt;- terra::vect(sh_mundos_sp_utm_simple)\n\nmasked_cv_terra &lt;- terra::mask(cv_terra, sh_terra)\n\ncv_raster_wgs84_terra &lt;- terra::project(\n    masked_cv_terra, \n    y = \"epsg:4326\", \n    method = \"bilinear\" # Similar a projectRaster\n)\n\ncv_raster_wgs84 &lt;- raster::raster(cv_raster_wgs84_terra)\n\nmax_cv &lt;- raster::cellStats(cv_raster_wgs84, stat='max')\nstep_cv &lt;- max_cv / 10\n\nbincv &lt;- seq(0,max_cv, by=step_cv)\n\ncv_range &lt;- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))\n\npal_cv &lt;- colorBin(\n  palette = \"RdYlGn\", # Rojo-Amarillo-Verde\n  domain = cv_range,\n  na.color = \"transparent\",\n  bins = bincv,\n  reverse = TRUE\n)\n\nmapa_cv_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    cv_raster_wgs84,\n    colors = pal_cv, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  addLegend(\n    pal = pal_cv, \n    values = cv_range,\n    title = \"Coeficiente de Variación\",\n    position = \"topright\"\n  )\n\n\nEn el siguiente panel se presentan 3 mapas que resumen el proceso de predicción:\n\nPredicciónVarianzaCoeficiente de variación\n\n\n\n\nVer código\nmapa_kriging_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_var_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_cv_leaflet\n\n\n\n\n\n\n\n\n\nLos resultados del Kriging indican que la calidad del aire tiende a ser más deficiente en el sur de California y en el Valle Central, donde se observan las concentraciones predichas más altas de ozono. Dado que estas regiones cuentan con una alta densidad de estaciones de monitoreo, se cuenta con una mayor confiabilidad y precisión en las estimaciones del modelo (reflejada en valores bajos de varianza o coeficiente de variación). En contraste, las predicciones sobre la concentración de ozono presentan mayor incertidumbre (varianza o CV elevados) en las zonas rurales y fronterizas del norte y este del estado, debido a la menor disponibilidad de estaciones de observación en esas áreas.\nA pesar de que los coeficientes de variación presentan valores muy bajos, todos inferiores al 11%, es importante interpretar estos resultados con cautela. Aunque se aplicó un Kriging de vecinos cercanos para mitigar el efecto de las grandes distancias entre puntos, es posible que aún persista cierto nivel de ruido o variabilidad residual asociado a la extensión geográfica del área californiana.\n\n1.2.1.3.1 Métricas de Validación Cruzada\nA continuación se presentan las métricas de validación cruzada obtenidas mediante la función krige.cv() del paquete gstat:\n\n\nVer código\ninvisible(cv_oz &lt;- krige.cv(Ozono ~ I(Norte^2) + I(Norte^3) + Este,\n                  datosOZ,\n                  model = best_model_O))\n\npander::pander(metricas_cv(cv_oz), digits=3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nME\nMAE\nRMSE\nR2\nMPSE\nCOR\n\n\n\n\n0.0255\n2.52\n3.62\n0.509\n1.66\n0.715\n\n\n\n\n\nEl modelo de Kriging muestra un desempeño sólido y equilibrado. El sesgo es bastante bajo, como se puede evidenciar en el valor del ME, de maneta similar los errores promedio ponderados se mantienen en un rango aceptable y se alcanza una correlación alta entre lo observado y lo predicho. Aun así, el R^2 indica que el modelo explica alrededor del 50% de la variabilidad (algo coherente con la pepita observada en el semivariograma empírico). Los resultados en conjunto sugieren que el modelo captura bien los patrones espaciales generales del ozono y ofrece predicciones confiables en la mayor parte del territorio.\nEstos indicadores coinciden con lo observado en los mapas: las predicciones son más precisas en el sur de California y el Valle Central, donde la mayor densidad de estaciones reduce la incertidumbre, mientras que en zonas rurales y fronterizas la falta de información aumenta la variabilidad de las estimaciones. Aun cuando los coeficientes de variación son bajos, es importante interpretar con cautela las áreas con poca cobertura, ya que pueden conservar algo de ruido residual debido a la extensión y heterogeneidad del estado.\n\n\n\n\n1.2.2 Variable Temperatura\nEn el siguiente mapa se presenta la distribución territorial de las estaciones de Temperatura, así mismo como sus valores muestrales:\n\n\nVer código\ny_T &lt;- Temp[1,] #Tomar una fecha\ny_T &lt;- cbind(colnames(y_T),t(y_T[1,]))\ny_T &lt;- y_T[-1,]\ny_T &lt;- as.data.frame(y_T)\ny_T &lt;- na.omit(y_T)\ny_T &lt;- y_T[-which.min(y_T$V2),]\ny_T$V1 &lt;- as.numeric(y_T$V1)\ny_T &lt;- inner_join(y_T, EstacionesT, by=c(\"V1\"=\"AQSID\"))\ndatosT &lt;- y_T[,c(13,14,2)]\ncolnames(datosT)=c(\"Este\",\"Norte\",\"Temperatura\")\ndatosT$Temperatura &lt;- as.numeric(datosT$Temperatura)\n\ndatosT_sf &lt;- st_as_sf(datosT, coords = c(\"Este\", \"Norte\"), crs = 3310)\n\ndatosT_sf_wgs84 &lt;- st_transform(datosT_sf, crs = 4326)\n\npal &lt;- colorNumeric(palette = \"viridis\", domain = datosT_sf_wgs84$Temperatura)\n\nleaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = \"black\", weight = 2) %&gt;%\n  addCircleMarkers(data = datosT_sf_wgs84,\n                   fillColor = ~pal(Temperatura),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"Temp:\", Temperatura, \"°C\")) %&gt;%\n  addLegend(pal = pal, values = datosT_sf_wgs84$Temperatura, title = \"Temperatura (°C)\")\n\n\n\n\n\n\nLos datos observados son trabajados en el formato geodata mediante el uso de la función as.geodata() del paquete GeoR. El resumen de las coordenadas y la variable Ozono se presenta tabularmente en seguida:\n\n\nVer código\ntemp &lt;- as.geodata(datosT) \npander::pander(summary(temp))\n\n\n\nn: 122\ncoords.summary:\n\n\n\n\n\n\n\n\n \nEste\nNorte\n\n\n\n\nmin\n-325701\n-580919\n\n\nmax\n387270\n281577\n\n\n\ndistances.summary:\n\n\n\n\n\n\n\nmin\nmax\n\n\n\n\n609.2\n1e+06\n\n\n\ndata.summary:\n\n\n\n\n\n\n\n\n\n\n\nMin.\n1st Qu.\nMedian\nMean\n3rd Qu.\nMax.\n\n\n\n\n-3.2\n13.15\n15.8\n14.43\n17.2\n24.5\n\n\n\n\n\n\n\n\n1.2.2.1 Análisis de Estacionariedad en Media\nAhora, se procede a revisar el comportamiento de la media de la variable con respecto a las coordenadas Este y Norte. Para entender de mejor manera la distribución de la variable ozono se presentan la matriz de correlación muestral y los siguientes gráficos:\n\nMatrizGráficos de dispersiónGeoR\n\n\n\n\nVer código\npander::pander(cor(datosT))\n\n\n\n\n\n\n\n\n\n\n\n \nEste\nNorte\nTemperatura\n\n\n\n\nEste\n1\n-0.7668\n0.3464\n\n\nNorte\n-0.7668\n1\n-0.458\n\n\nTemperatura\n0.3464\n-0.458\n1\n\n\n\n\n\n\n\n\n\nVer código\npT1 &lt;- simple_scatter_plot(datosT, \"Este\", \"Temperatura\")\npT2 &lt;- simple_scatter_plot(datosT, \"Norte\", \"Temperatura\")\n\ncowplot::plot_grid(pT1,pT2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(temp, qt.col = c(\"purple\",\n                    \"pink\",\n                    \"green\",\n                    \"yellow\"),\n     scatter3d=T)\n\n\n\n\n\n\n\n\n\n\n\n\nEn la matriz de correlaciones se observa una asociación notable entre la temperatura con la coordenada Norte. No obstante, esta relación no se aprecia de forma claramente lineal en el gráfico de dispersión, por lo que se opta por ajustar un polinomio con el fin de corregir la tendencia y capturar mejor la variación espacial de la variable.\n\n1.2.2.1.1 Ajuste del Modelo\nEl modelo que mejor atrapa el efecto de la media es:\n\nTemperatura = \\beta_0 + \\beta_1 \\times Norte + \\beta_2 \\times Norte^2\n\n\n\nVer código\nfitT &lt;- lm(Temperatura~Norte+I(Norte^2), data = datosT) \npander::pander(summary(fitT))\n\n\n\n\n\n\n\n\n\n\n\n\n \nEstimate\nStd. Error\nt value\nPr(&gt;|t|)\n\n\n\n\n(Intercept)\n13.26\n0.5352\n24.77\n8.812e-49\n\n\nNorte\n-2.229e-05\n3.23e-06\n-6.901\n2.676e-10\n\n\nI(Norte^2)\n-3.754e-11\n8.551e-12\n-4.39\n2.469e-05\n\n\n\n\nFitting linear model: Temperatura ~ Norte + I(Norte^2)\n\n\n\n\n\n\n\n\nObservations\nResidual Std. Error\nR^2\nAdjusted R^2\n\n\n\n\n122\n4.049\n0.3199\n0.3084\n\n\n\n\n\nTodos los coeficientes del modelo son significativos. Sin embargo, el R^2 es relativamente bajo, por lo que se considera necesario verificar gráficamente si la tendencia espacial fue efectivamente mitigada.\n\nGráficos de dispersiónGeoR\n\n\n\n\nVer código\ndatosT$Residuos &lt;- fitT$residuals\n\npT1 &lt;- simple_scatter_plot(datosT, \"Este\", \"Residuos\")\npT2 &lt;- simple_scatter_plot(datosT, \"Norte\", \"Residuos\")\n\ncowplot::plot_grid(pT1,pT2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(temp, qt.col = c(\"purple\",\n                    \"pink\",\n                    \"green\",\n                    \"yellow\"),\n     scatter3d=T, trend=~Norte+I(Norte^2))\n\n\n\n\n\n\n\n\n\n\n\n\nLos gráficos evidencian que la tendencia existente entre la variable y la coordenada Norte ha sido mitigada, lo que indica que se ha logrado un ajuste adecuado del modelo.\n\n\n\n1.2.2.2 Estudio del Semivariograma\n\n1.2.2.2.1 Estimación Empírica del Semivariograma\nA continuación, se presenta la estimación del semivariograma obtenida con la función variog(). Para asegurar la fiabilidad de los resultados, se especifican los argumentos estimator.type = \"modulus\" y pairs.min=50, con el fin de utilizar un estimador robusto y garantizar un número mínimo adecuado de pares en cada intervalo de distancia.\n\n\nVer código\nvg_T &lt;- variog(temp, estimator.type = \"modulus\", pairs.min=50) #Sin tendencia espacial\n\nvg1_T &lt;- variog(temp, trend = ~Norte+I(Norte^2),\n                estimator.type = \"modulus\", pairs.min=50)\n\n\n\nCon tendenciaRemoviendo tendencia\n\n\n\n\nVer código\nplot(vg_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Sin remover tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Removiendo tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\nCuando no se remueve la tendencia, la semivarianza alcanza valores más altos y presenta una forma aparentemente más regular, aunque dicha regularidad está influenciada por la tendencia global de los datos. En cambio, al eliminar la tendencia, los valores de semivarianza disminuyen y el patrón pierde suavidad, pero el variograma refleja con mayor fidelidad la verdadera dependencia espacial.\n\n\n1.2.2.2.2 Estimación del Modelo Teórico de Semivariograma\nPara obtener unos valores iniciales de los modelos teóricos se usa la función EyeFit() de la librería GeoR.\nLos modelos obtenidos ajustando por EyeFit(), son:\n\ncov.model sigmasq phi tausq kappa kappa2 practicalRange\n1 exponential 10.74 109166.3 2.07 NA NA 327033.0\n2 gaussian 10.00 80000.0 2.07 NA NA 138465.5\n3 spherical 10.00 157832.8 2.07 NA NA 157832.8\n\n\n\nVer código\ndist_matrix_T &lt;- as.matrix(dist(temp$coords))\n\nvariog_T &lt;- data.frame(h = vg1_T$u, gamma_hat = vg1_T$v,\n                       n = vg1_T$n)\n\nrange_sv_T &lt;- seq(1,max(variog_T$h), by=1000)\n\n# Modelo exponencial ----\n\nsigma_0_eT &lt;- 10.74\nphi_0_eT &lt;- 109166.3\nnugget_0_eT &lt;- 2.07\n\npar_eT &lt;- c(sigma_0_eT, phi_0_eT, nugget_0_eT)\n\nres_e_T &lt;- est_sev_WLS(par=par_eT, kappa = NA,\n                       model=\"exponencial\",\n                       h=variog_T$h,\n                       gamma = variog_T$gamma_hat,\n                       n = variog_T$n)\n\nMLE_eT &lt;- optim(fn = loglik,\n             par = par_eT,\n             kappa=NA,\n             z = datosT$Residuos, \n             dist_matrix=dist_matrix_T,\n             model = \"exponencial\",\n             method = \"L-BFGS-B\",\n             lower = c(0, 0, 0))\n\nestsv_exp_Bess_T &lt;- do.call(sv_exp, c(as.list(res_e_T$Bessel$Optimizados), list(h = range_sv_T)))\nestsv_exp_n_T &lt;- do.call(sv_exp, c(as.list(res_e_T$`1/n`$Optimizados), list(h = range_sv_T)))\nestsv_exp_h_n_T &lt;- do.call(sv_exp, c(as.list(res_e_T$`h/n`$Optimizados), list(h = range_sv_T)))\nestsv_exp_MLE_T &lt;- do.call(sv_exp, c(list(nugget = MLE_eT$par[3], phi = MLE_eT$par[2] , sigma = MLE_eT$par[1],h = range_sv_T)))\n\n# Modelo Gaussiano ----\n\nsigma_0_gT &lt;- 10.00    \nphi_0_gT &lt;- 80000.0\nnugget_0_gT &lt;- 2.07\n\npar_gT &lt;- c(sigma_0_gT, phi_0_gT, nugget_0_gT)\n\nres_g_T &lt;- est_sev_WLS(par=par_gT, kappa = NA,\n                       model=\"gaussian\",\n                       h=variog_T$h,\n                       gamma = variog_T$gamma_hat,\n                       n = variog_T$n)\n\nestsv_g_Bess_T &lt;- do.call(sv_gauss, c(as.list(res_g_T$Bessel$Optimizados), list(h = range_sv_T)))\nestsv_g_n_T &lt;- do.call(sv_gauss, c(as.list(res_g_T$`1/n`$Optimizados), list(h = range_sv_T)))\nestsv_g_h_n_T &lt;- do.call(sv_gauss, c(as.list(res_g_T$`h/n`$Optimizados), list(h = range_sv_T)))\n\n# Modelo esférico\n\nsigma_0_esT &lt;- 10.00   \nphi_0_esT &lt;- 157832.8\nnugget_0_esT &lt;- 2.07\n\npar_esT &lt;- c(sigma_0_esT, phi_0_esT, nugget_0_esT)\n\nres_es_T &lt;- est_sev_WLS(par=par_esT, kappa = NA,\n                       model=\"spherical\",\n                       h=variog_T$h,\n                       gamma = variog_T$gamma_hat,\n                       n = variog_T$n)\n\nMLE_esT &lt;- optim(fn = loglik,\n             par = par_esT,\n             kappa=NA,\n             z = datosT$Residuos, \n             dist_matrix=dist_matrix_T,\n             model = \"spherical\",\n             method = \"L-BFGS-B\",\n             lower = c(0, 0, 0))\n\n\nestsv_es_Bess_T &lt;- do.call(sv_spherical, c(as.list(res_es_T$Bessel$Optimizados), list(h = range_sv_T)))\nestsv_es_n_T &lt;- do.call(sv_spherical, c(as.list(res_es_T$`1/n`$Optimizados), list(h = range_sv_T)))\nestsv_es_h_n_T &lt;- do.call(sv_spherical, c(as.list(res_es_T$`h/n`$Optimizados), list(h = range_sv_T)))\nestsv_es_MLE_T &lt;- do.call(sv_spherical, c(list(nugget = MLE_esT$par[3], phi = MLE_esT$par[2] , sigma = MLE_esT$par[1],h = range_sv_T)))\n\n\n\nExponencialGaussianoEsférico\n\n\n\nOptimGeoR\n\n\n\n\nVer código\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (optim)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(range_sv_T, estsv_exp_Bess_T, col=\"#FF4040\", lwd=1.5)\nlines(range_sv_T, estsv_exp_n_T, col=\"#4169E1\", lwd=1.5)\nlines(range_sv_T, estsv_exp_h_n_T, col=\"#008B00\", lwd=1.5)\nlines(range_sv_T, estsv_exp_MLE_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"Cressie\", \"1/n\", \"n/h\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\nVer código\nresumen_exp_T &lt;- cbind(\n  c(\"Cressie\", \"1/n\", \"n/h\", \"MLE\"),\n  rbind(\n    t(res_e_T$Bessel$Optimizados),\n    t(res_e_T$`1/n`$Optimizados),\n    t(res_e_T$`h/n`$Optimizados),\n    MLE_eT$par[c(3,1,2)]\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, res_e_T$Bessel$Optimizados, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_e_T$`1/n`$Optimizados, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_e_T$`h/n`$Optimizados, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, list(nugget = MLE_eT$par[3], phi = MLE_eT$par[2] , sigma = MLE_eT$par[1]), NA, model = \"exponencial\", variog_T$h)\n  )\n)\n\nresumen_exp_T &lt;- as.data.frame(resumen_exp_T)\nresumen_exp_T[ , -1] &lt;- lapply(resumen_exp_T[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_exp_T, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nCressie\n0\n12.944\n98216.22\n3.591000e+00\n\n\n1/n\n0\n11.178\n74809.83\n3.867000e+00\n\n\nn/h\n0\n12.797\n98765.50\n3.465000e+00\n\n\nMLE\n0\n31.706\n109166.30\n1.191489e+10\n\n\n\n\n\n\n\n\n\nVer código\nini1_exp_T &lt;- c(sigma_0_eT, phi_0_eT)\nfitvar1_exp_T &lt;- variofit(vg1_T,\n                    cov.model = \"exponential\",\n                    ini1_exp_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_eT,\n                    wei = \"equal\")\n\nfitvar2_exp_T &lt;- variofit(vg1_T,\n                    cov.model = \"exponential\",\n                    ini1_exp_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_eT,\n                    wei = \"npairs\")\n\nfitvar3_exp_T &lt;- variofit(vg1_T,\n                    cov.model = \"exponential\",\n                    ini1_exp_T,\n                    fix.nugget =F,\n                    nugget = nugget_0_eT,\n                    wei = \"cressie\")\n\nfitvar4_exp_T &lt;- likfit(temp,\n                  coords = temp$coords,\n                  data = temp$data,\n                  trend = ~ poly(Norte, 2, raw = FALSE),\n                  ini.cov.pars = ini1_exp_T,\n                  fix.nugget = F,\n                  nugget = nugget_0_eT,\n                  cov.model = \"exponential\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_exp_T, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_exp_T, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_exp_T, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_exp_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Texp &lt;- c(fitvar1_exp_T$nugget, fitvar1_exp_T$cov.pars[1], fitvar1_exp_T$cov.pars[2])\npar2Texp &lt;- c(fitvar2_exp_T$nugget, fitvar2_exp_T$cov.pars[1], fitvar2_exp_T$cov.pars[2])\npar3Texp &lt;- c(fitvar3_exp_T$nugget, fitvar3_exp_T$cov.pars[1], fitvar3_exp_T$cov.pars[2])\npar4Texp &lt;- c(fitvar4_exp_T$nugget, fitvar4_exp_T$cov.pars[1], fitvar4_exp_T$cov.pars[2])\n\nresumen_exp_T2 &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1Texp,\n    par2Texp,\n    par3Texp,\n    par4Texp\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, par1Texp, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par2Texp, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par3Texp, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par4Texp, NA, model = \"exponencial\", variog_T$h)\n  )\n)\n\nresumen_exp_T2 &lt;- as.data.frame(resumen_exp_T2)\nresumen_exp_T2[ , -1] &lt;- lapply(resumen_exp_T2[ , -1], function(x) round(as.numeric(x), 3))\nkable(resumen_exp_T2, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n0\n12.141\n82253.47\n3.184\n\n\n1/n\n0\n12.423\n83939.28\n3.243\n\n\nCressie\n0\n13.298\n109166.30\n4.009\n\n\nMLE\n0\n23.536\n75307.83\n117.551\n\n\n\n\n\n\n\n\n\n\n\nOptimGeoR\n\n\n\n\nVer código\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (optim)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(range_sv_T, estsv_g_Bess_T, col=\"#FF4040\", lwd=1.5)\nlines(range_sv_T, estsv_g_n_T, col=\"#4169E1\", lwd=1.5)\nlines(range_sv_T, estsv_g_h_n_T, col=\"#008B00\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"Cressie\", \"1/n\", \"n/h\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\nVer código\nresumen_g_T &lt;- cbind(\n  c(\"Cressie\", \"1/n\", \"n/h\"),\n  rbind(\n    t(res_g_T$Bessel$Optimizados),\n    t(res_g_T$`1/n`$Optimizados),\n    t(res_g_T$`h/n`$Optimizados)\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, res_g_T$Bessel$Optimizados, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_g_T$`1/n`$Optimizados, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_g_T$`h/n`$Optimizados, NA, model = \"gaussian\", variog_T$h)\n  )\n)\n\nresumen_g_T &lt;- as.data.frame(resumen_g_T)\nresumen_g_T[ , -1] &lt;- lapply(resumen_g_T[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_g_T, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nCressie\n0\n12.053\n74520.08\n2.809\n\n\n1/n\n0\n11.126\n69275.08\n3.233\n\n\nn/h\n0\n11.620\n72540.06\n2.825\n\n\n\n\n\n\n\n\n\nVer código\nini1_g_T &lt;- c(sigma_0_gT, phi_0_gT)\nfitvar1_g_T &lt;- variofit(vg1_T,\n                    cov.model = \"gaussian\",\n                    ini1_g_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_gT,\n                    wei = \"equal\")\n\nfitvar2_g_T &lt;- variofit(vg1_T,\n                    cov.model = \"gaussian\",\n                    ini1_g_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_gT,\n                    wei = \"npairs\")\n\nfitvar3_g_T &lt;- variofit(vg1_T,\n                    cov.model = \"gaussian\",\n                    ini1_g_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_gT,\n                    wei = \"cressie\")\n\nfitvar4_g_T &lt;- likfit(temp,\n                  coords = temp$coords,\n                  data = temp$data,\n                  trend = ~ poly(Norte, 2, raw = FALSE),\n                  ini.cov.pars = ini1_g_T,\n                  fix.nugget = F,\n                  nugget = nugget_0_gT,\n                  cov.model = \"gaussian\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_g_T, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_g_T, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_g_T, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_g_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Tg &lt;- c(fitvar1_g_T$nugget, fitvar1_g_T$cov.pars[1], fitvar1_g_T$cov.pars[2])\npar2Tg &lt;- c(fitvar2_g_T$nugget, fitvar2_g_T$cov.pars[1], fitvar2_g_T$cov.pars[2])\npar3Tg &lt;- c(fitvar3_g_T$nugget, fitvar3_g_T$cov.pars[1], fitvar3_g_T$cov.pars[2])\npar4Tg &lt;- c(fitvar4_g_T$nugget, fitvar4_g_T$cov.pars[1], fitvar4_g_T$cov.pars[2])\n\nresumen_g_T2 &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1Tg,\n    par2Tg,\n    par3Tg,\n    par4Tg\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, par1Tg, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par2Tg, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par3Tg, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par4Tg, NA, model = \"gaussian\", variog_T$h)\n  )\n)\n\nresumen_g_T2 &lt;- as.data.frame(resumen_g_T2)\nresumen_g_T2[ , -1] &lt;- lapply(resumen_g_T2[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_g_T2, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n0.000\n11.862\n74341.87\n2.776\n\n\n1/n\n0.000\n11.884\n74607.88\n2.777\n\n\nCressie\n0.349\n11.781\n80000.00\n2.835\n\n\nMLE\n3.589\n21.264\n80000.00\n155.000\n\n\n\n\n\n\n\n\n\n\n\nOptimGeoR\n\n\n\n\nVer código\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (optim)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(range_sv_T, estsv_es_Bess_T, col=\"#FF4040\", lwd=1.5)\nlines(range_sv_T, estsv_es_n_T, col=\"#4169E1\", lwd=1.5)\nlines(range_sv_T, estsv_es_h_n_T, col=\"#008B00\", lwd=1.5)\nlines(range_sv_T, estsv_es_MLE_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"Cressie\", \"1/n\", \"n/h\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\nVer código\nresumen_es_T &lt;- cbind(\n  c(\"Cressie\", \"1/n\", \"n/h\",\"MLE\"),\n  rbind(\n    t(res_es_T$Bessel$Optimizados),\n    t(res_es_T$`1/n`$Optimizados),\n    t(res_es_T$`h/n`$Optimizados),\n    MLE_esT$par[c(3,1,2)]\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, res_es_T$Bessel$Optimizados, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_es_T$`1/n`$Optimizados, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_es_T$`h/n`$Optimizados, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, list(nugget = MLE_esT$par[3], phi = MLE_esT$par[2] , sigma = MLE_esT$par[1]), NA, model = \"spherical\", variog_T$h)\n  )\n)\n\nresumen_es_T &lt;- as.data.frame(resumen_es_T)\nresumen_es_T[ , -1] &lt;- lapply(resumen_es_T[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_es_T, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nCressie\n0\n12.165\n191573.0\n3.044000e+00\n\n\n1/n\n0\n11.128\n165974.5\n3.417000e+00\n\n\nn/h\n0\n11.692\n175441.2\n2.976000e+00\n\n\nMLE\n0\n27.958\n157832.8\n2.490774e+10\n\n\n\n\n\n\n\n\n\nVer código\nini1_es_T &lt;- c(sigma_0_esT, phi_0_esT)\nfitvar1_es_T &lt;- variofit(vg1_T,\n                    cov.model = \"spherical\",\n                    ini1_es_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_esT,\n                    wei = \"equal\")\n\nfitvar2_es_T &lt;- variofit(vg1_T,\n                    cov.model = \"spherical\",\n                    ini1_es_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_esT,\n                    wei = \"npairs\")\n\nfitvar3_es_T &lt;- variofit(vg1_T,\n                    cov.model = \"spherical\",\n                    ini1_es_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_esT,\n                    wei = \"cressie\")\n\nfitvar4_es_T &lt;- likfit(temp,\n                  coords = temp$coords,\n                  data = temp$data,\n                  trend = ~ poly(Norte, 2, raw = FALSE),\n                  ini.cov.pars = ini1_es_T,\n                  fix.nugget = F,\n                  nugget = nugget_0_esT,\n                  cov.model = \"spherical\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_es_T, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_es_T, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_es_T, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_es_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Tes &lt;- c(fitvar1_es_T$nugget, fitvar1_es_T$cov.pars[1], fitvar1_es_T$cov.pars[2])\npar2Tes &lt;- c(fitvar2_es_T$nugget, fitvar2_es_T$cov.pars[1], fitvar2_es_T$cov.pars[2])\npar3Tes &lt;- c(fitvar3_es_T$nugget, fitvar3_es_T$cov.pars[1], fitvar3_es_T$cov.pars[2])\npar4Tes &lt;- c(fitvar4_es_T$nugget, fitvar4_es_T$cov.pars[1], fitvar4_es_T$cov.pars[2])\n\nresumen_es_T2 &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1Tes,\n    par2Tes,\n    par3Tes,\n    par4Tes\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, par1Tes, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par2Tes, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par3Tes, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par4Tes, NA, model = \"spherical\", variog_T$h)\n  )\n)\n\nresumen_es_T2 &lt;- as.data.frame(resumen_es_T2)\nresumen_es_T2[ , -1] &lt;- lapply(resumen_es_T2[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_es_T2, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n0\n11.878\n171733.0\n2.938\n\n\n1/n\n0\n11.898\n166427.4\n2.944\n\n\nCressie\n0\n11.860\n157832.8\n2.977\n\n\nMLE\n0\n25.641\n144147.3\n179.276\n\n\n\n\n\n\n\n\n\n\n\nEl modelo con menor MSE corresponde al modelo Gaussiano. No obstante, debido a la inestabilidad numérica observada durante el proceso de predicción, se opta por emplear el modelo Esférico ajustado mediante mínimos cuadrados ponderados con la ponderación h/n, el cual representa la segunda mejor alternativa en términos del MSE.\n\n\n\n1.2.2.3 Kriging\nEl modelo Esférico, con los parámetros obtenidos por WLS usando la ponderación h/n, que se usará para realizar Kriging es el siguiente:\n\n\n\n\n\n\n\n\n\nPara realizar la predicción, se genera una muestra aleatoria de puntos dentro del polígono que delimita el estado de California mediante la función spsample() del paquete sp. Sobre estos puntos se estiman los valores esperados aplicando el método de Kriging de vecinos cercanos, con el fin de mejorar la precisión de las estimaciones al considerar las grandes distancias características del territorio californiano. El procedimiento se implementa mediante la función krige() de gstat, especifícando la opción nmin=20 y utilizando la función predict() de base de R.\n\n\nVer código\n#Se escoge el mejor modelo --------------------------------\n\nbest_model_T &lt;- gstat::vgm(psill = res_es_T$`h/n`$Optimizados[2],\n                           model = \"Sph\",\n                           range = res_es_T$`h/n`$Optimizados[3],\n                           nugget = res_es_T$`h/n`$Optimizados[1]\n)\n\n#Se crea un objeto en gstat -------------------------------\n\ncoordinates(datosT) &lt;- ~Este + Norte\nproj4string(datosT) &lt;- CRS(\"EPSG:3310\")\n\ng_obj&lt;-gstat::gstat(id=\"Temperatura\",\n             formula = Temperatura ~ Norte + I(Norte^2),\n             model = best_model_T,\n             data = datosT)\n\n#Kriging -------------------------------------------------\n\nsuppressMessages(predic &lt;- predict(g_obj, newdata = new, nmin = 20))\n\n#Mapas de predicción --------------------------------------\n\ngridded(predic) &lt;- TRUE\n\n#1. Mapa de Kriging ---------------------------------------\n\npredic_raster_utm &lt;- raster(predic, layer = \"Temperatura.pred\")\n\ncrs(predic_raster_utm) &lt;- \"+init=epsg:3310\"\n\npredic_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        predic_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmin_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='min')\nmax_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='max')\n\npred_range &lt;- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))\n\nstep_pred &lt;- (max_pred-min_pred)/ 6\n\nbins &lt;- round(seq(min_pred, max_pred, by=step_pred),0)\n\npal_pred &lt;- colorBin(\n  palette = \"viridis\", # La paleta de colores\n  domain = pred_range,\n  bins = bins,\n  na.color = \"transparent\"\n)\n\nmapa_kriging_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    predic_raster_wgs84,\n    colors = pal_pred, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n    addCircleMarkers(data = datosT_sf_wgs84,\n                   fillColor = ~pal(Temperatura),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"Temp:\", Temperatura, \"°C\")) %&gt;% \n  addLegend(\n    pal = pal_pred, \n    values = pred_range,\n    title = \"Predicción T (°C)\",\n    position = \"topright\"\n  ) %&gt;%\n  addLegend(pal = pal,\n            values = datosT_sf_wgs84$Temperatura,\n            title = \"Temperatura Observada\",\n    position = \"topleft\"\n  ) \n\n#2 Mapa Varianza------------------------------------------\n\nvar_raster_utm &lt;- raster(predic, layer = \"Temperatura.var\")\n\ncrs(var_raster_utm) &lt;- \"+init=epsg:3310\"\n\nvar_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        var_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmax_var &lt;- raster::cellStats(var_raster_wgs84, stat='max')\nstep_var &lt;- max_var / 6\n\nbinsv &lt;- round(seq(0, max_var, by=step_var),2)\n\nvar_range &lt;- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))\npal_var &lt;- colorBin(\n  palette = \"Spectral\", # La paleta de colores\n  domain = var_range,\n  bins = binsv,\n  na.color = \"transparent\"\n)\n\nmapa_var_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    var_raster_wgs84, \n    colors = pal_var, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  addLegend(\n    pal = pal_var, \n    values = var_range,\n    title = \"Varianza\",\n    position = \"topright\"\n  ) \n\n#3. Mapa Cv ----------------------------------------------\n\ncv_raster_utm &lt;- sqrt(var_raster_utm) / abs(predic_raster_utm)\n\nmapa_mayor_a_uno &lt;- cv_raster_utm &gt; 1\ncv_raster_utm[mapa_mayor_a_uno] &lt;- 1\n\ncrs(cv_raster_utm) &lt;- \"+init=epsg:3310\"\n\ncv_terra &lt;- terra::rast(cv_raster_utm)\n\nmasked_cv_terra &lt;- terra::mask(cv_terra, sh_terra)\n\ncv_raster_wgs84_terra &lt;- terra::project(\n    masked_cv_terra, \n    y = \"epsg:4326\", \n    method = \"bilinear\" # Similar a projectRaster\n)\n\ncv_raster_wgs84 &lt;- raster::raster(cv_raster_wgs84_terra)\n\nmax_cv &lt;- raster::cellStats(cv_raster_wgs84, stat='max')\nstep_cv &lt;- max_cv / 10\n\nbincv &lt;- seq(0,max_cv, by=step_cv)\n\ncv_range &lt;- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))\n\npal_cv &lt;- colorBin(\n  palette = \"RdYlGn\", # Rojo-Amarillo-Verde\n  domain = cv_range,\n  na.color = \"transparent\",\n  bins = bincv,\n  reverse = TRUE \n)\n\nmapa_cv_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    cv_raster_wgs84, \n    colors = pal_cv, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  \n  addLegend(\n    pal = pal_cv, \n    values = cv_range,\n    title = \"Coeficiente de Variación\",\n    position = \"topright\"\n  )\n\n\nEn el siguiente panel se presentan 3 mapas que resumen el proceso de predicción:\n\nPredicciónVarianzaCoeficiente de variación\n\n\n\n\nVer código\nmapa_kriging_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_var_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_cv_leaflet\n\n\n\n\n\n\n\n\n\nLos mapas de kriging para la temperatura muestran que las zonas más cálidas y con predicciones más confiables se concentran en el sur de California y en el Valle Central. En contraste, las regiones con mayor incertidumbre (alta varianza y coeficiente de variación) se ubican principalmente en el extremo norte y a lo largo de las fronteras del estado.\nEsta menor fiabilidad en el norte se debe a la escasa presencia de estaciones de monitoreo en esas extensas áreas. El modelo de semivarianza empleado (Esférico) presenta un rango de influencia de aproximadamente 175 km, lo que implica que las mediciones dejan de ser útiles para la predicción más allá de esa distancia. Aunque se aplicó un Kriging de vecinos cercanos para mitigar el efecto de estas grandes distancias, persiste un nivel considerable de incertidumbre en las zonas con baja densidad de observaciones\n\n1.2.2.3.1 Métricas de Validación Cruzada\nA continuación se presentan las métricas de validación cruzada obtenidas mediante la función krige.cv() del paquete gstat:\n\n\nVer código\ninvisible(cv_t &lt;- krige.cv(Temperatura ~ Norte + I(Norte^2),\n                  datosT,\n                  model = best_model_T))\n\npander::pander(metricas_cv(cv_t), digits=3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nME\nMAE\nRMSE\nR2\nMPSE\nCOR\n\n\n\n\n-0.164\n1.85\n3.19\n0.568\n3.44\n0.761\n\n\n\n\n\nEl ME cercano a cero indica que el Kriging no presenta un sesgo sistemático, lo cual es coherente con las zonas donde el modelo predice bien, especialmente en el sur y en el Valle Central. Los valores de MAE y RMSE muestran que el error promedio es moderado y aceptable para un fenómeno con alta variabilidad espacial como la temperatura. Sin embargo, estos valores sugieren que, en las regiones con poca densidad de estaciones, como el norte del estado, los errores tienden a aumentar debido a la mayor incertidumbre.\nEl R^2de 0.568 y la correlación de 0.715 reflejan una relación sólida entre las predicciones y los valores observados, lo cual concuerda con la mayor confiabilidad del modelo en las áreas bien monitoreadas. Sin embargo, estos indicadores también sugieren que aún queda una parte importante de variabilidad sin capturar, algo consistente con las zonas rurales y fronterizas donde la distancia entre estaciones supera con frecuencia el rango del modelo esférico. En conjunto, las métricas confirman un buen desempeño general, pero también respaldan la necesidad de interpretar con cautela las predicciones en las áreas con baja cobertura.\n\n\n\n\n1.2.3 Variable Velocidad del viento\nEn el siguiente mapa se presenta la distribución territorial de las estaciones de Velocidad del Viento, así mismo como sus valores muestrales:\n\n\nVer código\ny_WS &lt;- WS[1,] #Tomar una fecha\ny_WS &lt;- cbind(colnames(y_WS),t(y_WS[1,]))\ny_WS &lt;- y_WS[-1,]\ny_WS &lt;- as.data.frame(y_WS)\ny_WS &lt;- na.omit(y_WS)\ny_WS$V1 &lt;- as.numeric(y_WS$V1)\ny_WS &lt;- inner_join(y_WS, EstacionesWS, by=c(\"V1\"=\"AQSID\"))\ndatosWS &lt;- y_WS[,c(13,14,2)]\ncolnames(datosWS)=c(\"Este\",\"Norte\",\"WindSpeed\")\ndatosWS$WindSpeed &lt;- as.numeric(datosWS$WindSpeed)\n\ndatosWS_sf &lt;- st_as_sf(datosWS, coords = c(\"Este\", \"Norte\"), crs = 3310)\n\ndatosWS_sf_wgs84 &lt;- st_transform(datosWS_sf, crs = 4326)\n\npalWS &lt;- colorNumeric(palette = \"viridis\", domain = datosWS_sf_wgs84$WindSpeed)\n\nleaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = \"black\", weight = 2) %&gt;%\n  addCircleMarkers(data = datosWS_sf_wgs84,\n                   fillColor = ~palWS(WindSpeed),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"WindSpeed:\", WindSpeed, \"m/s\")) %&gt;%\n  addLegend(pal = palWS, values = datosWS_sf_wgs84$WindSpeed, title = \"WindSpeed (m/s)\")\n\n\n\n\n\n\nLos datos observados son trabajados en el formato geodata mediante el uso de la función as.geodata() del paquete GeoR. El resumen de las coordenadas y la variable Ozono se presenta tabularmente en seguida:\n\n\nVer código\nws &lt;- as.geodata(datosWS)\npander::pander(summary(ws))\n\n\n\nn: 89\ncoords.summary:\n\n\n\n\n\n\n\n\n \nEste\nNorte\n\n\n\n\nmin\n-276541\n-543973\n\n\nmax\n415574\n281577\n\n\n\ndistances.summary:\n\n\n\n\n\n\n\nmin\nmax\n\n\n\n\n2216\n987994\n\n\n\ndata.summary:\n\n\n\n\n\n\n\n\n\n\n\nMin.\n1st Qu.\nMedian\nMean\n3rd Qu.\nMax.\n\n\n\n\n0.8\n2.5\n3.8\n4.375\n5.5\n14.1\n\n\n\n\n\n\n\n\n1.2.3.1 Análisis de Estacionariedad en Media\nAhora, se procede a revisar el comportamiento de la media de la variable con respecto a las coordenadas Este y Norte. Para entender de mejor manera la distribución de la variable ozono se presentan la matriz de correlación muestral y los siguientes gráficos:\n\nMatrizGráficos de dispersiónGeoR\n\n\n\n\nVer código\npander::pander(cor(datosWS))\n\n\n\n\n\n\n\n\n\n\n\n \nEste\nNorte\nWindSpeed\n\n\n\n\nEste\n1\n-0.7654\n0.1151\n\n\nNorte\n-0.7654\n1\n0.3195\n\n\nWindSpeed\n0.1151\n0.3195\n1\n\n\n\n\n\n\n\n\n\nVer código\npWS1 &lt;- simple_scatter_plot(datosWS, \"Este\", \"WindSpeed\")\npWS2 &lt;- simple_scatter_plot(datosWS, \"Norte\", \"WindSpeed\")\n\ncowplot::plot_grid(pWS1,pWS2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(ws, qt.col = c(\"purple\",\n                          \"pink\",\n                          \"green\",\n                          \"yellow\"),\n     scatter3d=T)\n\n\n\n\n\n\n\n\n\n\n\n\nEn la matriz de correlaciones no se aprecia una asociación fuerte ni evidente entre la velocidad del viento y las coordenadas espaciales. Sin embargo, los gráficos sugieren una posible relación, aunque débil, por lo que se explorarán distintos modelos hasta identificar aquel que describa mejor la tendencia observada.\n\n1.2.3.1.1 Ajuste del Modelo\nEl modelo que mejor atrapa el efecto de la media es:\nWindSpeed = \\beta_0 + \\beta_1 \\times Este + \\beta_2 \\times Norte + \\beta_3 \\times Este \\times Norte\n\n\nVer código\nfitWS &lt;- lm(WindSpeed~Este*Norte, data = datosWS) \npander::pander(summary(fitWS))\n\n\n\n\n\n\n\n\n\n\n\n\n \nEstimate\nStd. Error\nt value\nPr(&gt;|t|)\n\n\n\n\n(Intercept)\n6.398\n0.3639\n17.58\n4.751e-30\n\n\nEste\n2.069e-05\n2.674e-06\n7.739\n1.895e-11\n\n\nNorte\n1.159e-05\n1.808e-06\n6.411\n7.746e-09\n\n\nEste:Norte\n2.558e-11\n7.483e-12\n3.419\n0.000968\n\n\n\n\nFitting linear model: WindSpeed ~ Este * Norte\n\n\n\n\n\n\n\n\nObservations\nResidual Std. Error\nR^2\nAdjusted R^2\n\n\n\n\n89\n1.938\n0.4851\n0.4669\n\n\n\n\n\nSe observa que todos los coeficientes del modelo resultan estadísticamente significativos, y que el ajuste presenta un R^2 de 0.48, lo cual indica un nivel de explicación adecuado de la variabilidad de la velocidad del viento.\n\nGráficos de dispersiónGeoR\n\n\n\n\nVer código\ndatosWS$Residuos &lt;- fitWS$residuals\n\npWS1 &lt;- simple_scatter_plot(datosWS, \"Este\", \"Residuos\")\npWS2 &lt;- simple_scatter_plot(datosWS, \"Norte\", \"Residuos\")\n\ncowplot::plot_grid(pWS1,pWS2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(temp, qt.col = c(\"purple\",\n                      \"pink\",\n                      \"green\",\n                      \"yellow\"),\n     scatter3d=T, trend=~Norte*Este)\n\n\n\n\n\n\n\n\n\n\n\n\nEn los gráficos se observa que el patrón asociado a las coordenadas se ha atenuado considerablemente, lo que sugiere que el modelo se ajustó de manera adecuada.\n\n\n\n1.2.3.2 Estudio del Semivariograma\nA continuación, se presenta la estimación del semivariograma obtenida con la función variog(). Para asegurar la fiabilidad de los resultados, se especifican los argumentos estimator.type = \"modulus\" y pairs.min=50, con el fin de utilizar un estimador robusto y garantizar un número mínimo adecuado de pares en cada intervalo de distancia.\n\n1.2.3.2.1 Estimación Empírica del Semivariograma\n\n\nVer código\nvgO_WS &lt;- variog(ws,estimator.type = \"modulus\", pairs.min=50) \n\nvg1_WS &lt;- variog(ws, trend = ~Norte*Este,\n                estimator.type = \"modulus\", pairs.min=50)\n\n\n\nCon tendenciaRemoviendo Tendencia\n\n\n\n\nVer código\nplot(vgO_WS,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Sin remover tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(vg1_WS,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Removiendo tendencia\",\n     col.main = \"#36648B\", cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\nSe observa que la estimación de la varianza de la variable incrementos presenta valores más bajos al remover la tendencia, lo que indica que en este caso el semivariograma refleja de manera más adecuada la verdadera estructura espacial del fenómeno.\n\n\n1.2.3.2.2 Estimación del Modelo Teórico de Semivariograma\nPara obtener unos valores iniciales de los modelos teóricos se usa la función EyeFit() de la librería GeoR. Por su parte, para el modelo coseno se realizo una estimación a ojo mediante la construcción de una función sv_cos() basada en la literatura.\nLos modelos obtenidos ajustando por EyeFit() y sv_cos(), son:\n\ncov.model sigmasq phi tausq kappa kappa2 practicalRange\n1 cos 1.5 .6e5 1.5 NA NA NA\n2 wave 3.5 .6e5 1.5 NA NA NA\n\nLa estimación de los parámetros del modelo Wave se hizo haciendo uso de las funciones nls() y optim() de R.\n\n\nVer código\nvariog_WS &lt;- data.frame(h = vg1_WS$u, gamma_hat = vg1_WS$v,\n                       n = vg1_WS$n)\n\nrange_sv_WS &lt;- seq(1,max(variog_WS$h), by=1000)\n\n#Modelo Coseno---------------------------------------------\n\nsigma_0_cosWS &lt;- 1.5\nphi_0_cosWS &lt;- .6e5\nnugget_0_cosWS &lt;- 1.5\n\n#MCO -------\nI_pond_WS &lt;- nls(formula = gamma_hat ~cos_sv(nugget, sigma, h, phi),\n              start = c(nugget = nugget_0_cosWS, sigma = sigma_0_cosWS, phi = phi_0_cosWS),\n              lower = rep(1e-6,3),\n              data = variog_WS,\n              control = nls.control(maxiter = 500, warnOnly = TRUE))\n\noptim_I_WS &lt;- optim(\n  par = coef(I_pond_WS),\n  fn = MSE_ponderados,\n  h = variog_WS$h,\n  gamma = variog_WS$gamma_hat,\n  pesos = \"I\",\n  model = \"cos\",\n  n = n,\n  method = \"L-BFGS-B\",\n  lower = rep(1e-6,3)\n)\n\npar_optim_I_WS &lt;- optim_I_WS$par[c(\"nugget\", \"sigma\", \"phi\")]\n\nestsv_cos_I_WS &lt;- do.call(cos_sv, c(as.list(par_optim_I_WS), list(h = range_sv_WS)))\n\n\n#WLS -------\n\npar_cosWS &lt;- c(sigma_0_cosWS, phi_0_cosWS, nugget_0_cosWS)\n\nres_cos_WS &lt;- est_sev_WLS(par=par_cosWS, kappa = NA,\n                       model=\"cos\",\n                       h=variog_WS$h,\n                       gamma = variog_WS$gamma_hat,\n                       n = variog_WS$n)\n\nestsv_cos_Bess_WS &lt;- do.call(cos_sv, c(as.list(res_cos_WS$Bessel$Optimizados), list(h = range_sv_WS)))\nestsv_cos_n_WS &lt;- do.call(cos_sv, c(as.list(res_cos_WS$`1/n`$Optimizados), list(h = range_sv_WS)))\nestsv_cos_h_n_WS &lt;- do.call(cos_sv, c(as.list(res_cos_WS$`h/n`$Optimizados), list(h = range_sv_WS)))\n\n#Modelo Wave ---------------------------------------------\n\nnugget_0_wvWS &lt;- 1.5\n\npar_wvWS &lt;- c(3.5,.6e5)\n\nfitvar1_cos_WS &lt;- variofit(vg1_WS,\n                    cov.model = \"wave\",\n                    par_wvWS,\n                    fix.nugget = F,\n                    nugget = nugget_0_wvWS,\n                    wei = \"equal\")\nfitvar2_cos_WS &lt;- variofit(vg1_WS,\n                    cov.model = \"wave\",\n                    par_wvWS,\n                    fix.nugget = F,\n                    nugget = nugget_0_wvWS,\n                    wei = \"npairs\")\n\nfitvar3_cos_WS &lt;- variofit(vg1_WS,\n                    cov.model = \"wave\",\n                    par_wvWS,\n                    fix.nugget = F,\n                    nugget = nugget_0_wvWS,\n                    wei = \"cressie\")\n\nfitvar4_cos_WS &lt;- likfit(ws,\n                       coords = ws$coords,\n                       data = ws$data,\n                       trend = ~ Este*Norte,\n                       ini.cov.pars = par_wvWS,\n                       fix.nugget = F,\n                       nugget = nugget_0_wvWS,\n                       cov.model = \"wave\",\n                       lik.method = \"ML\")\n\n\n\nCoseno (Optim)Wave (GeoR)\n\n\n\n\nVer código\nplot(vg1_WS,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (optim)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(range_sv_WS, estsv_cos_Bess_WS, col=\"#FF4040\", lwd=1.5)\nlines(range_sv_WS, estsv_cos_n_WS, col=\"#4169E1\", lwd=1.5)\nlines(range_sv_WS, estsv_cos_h_n_WS, col=\"#008B00\", lwd=1.5)\nlines(range_sv_WS, estsv_cos_I_WS, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"Cressie\", \"1/n\", \"n/h\", \"MCO\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\nVer código\nresumen_cos_SV &lt;- cbind(\n  c(\"Cressie\", \"1/n\", \"n/h\", \"MCO\"),\n  rbind(\n    t(res_cos_WS$Bessel$Optimizados),\n    t(res_cos_WS$`1/n`$Optimizados),\n    t(res_cos_WS$`h/n`$Optimizados),\n    par_optim_I_WS\n  ),\n  MSE = c(\n    MSE_sv(variog_WS$gamma_hat, res_cos_WS$Bessel$Optimizados, NA, model = \"cos\", variog_WS$h),\n    MSE_sv(variog_WS$gamma_hat, res_cos_WS$`1/n`$Optimizados, NA, model = \"cos\", variog_WS$h),\n    MSE_sv(variog_WS$gamma_hat, res_cos_WS$`h/n`$Optimizados, NA, model = \"cos\", variog_WS$h),\n    MSE_sv(variog_WS$gamma_hat, par_optim_I_WS, NA, model = \"cos\", variog_WS$h)\n  )\n)\n\nresumen_cos_SV &lt;- as.data.frame(resumen_cos_SV)\nresumen_cos_SV[ , -1] &lt;- lapply(resumen_cos_SV[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_cos_SV, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nCressie\n2.988\n0.513\n59341.12\n1.288\n\n\n1/n\n1.397\n1.316\n59754.77\n1.324\n\n\nn/h\n2.581\n0.000\n64723.22\n1.389\n\n\nMCO\n2.321\n0.694\n59631.92\n0.999\n\n\n\n\n\n\n\n\n\nVer código\nplot(vg1_WS,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\n\nlines(fitvar1_cos_WS, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_cos_WS, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_cos_WS, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_cos_WS, col=\"#FFA500\", lwd=1.5)\n\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1WScos &lt;- c(fitvar1_cos_WS$nugget, fitvar1_cos_WS$cov.pars[1], fitvar1_cos_WS$cov.pars[2])\npar2WScos &lt;- c(fitvar2_cos_WS$nugget, fitvar2_cos_WS$cov.pars[1], fitvar2_cos_WS$cov.pars[2])\npar3WScos &lt;- c(fitvar3_cos_WS$nugget, fitvar3_cos_WS$cov.pars[1], fitvar3_cos_WS$cov.pars[2])\npar4WScos &lt;- c(fitvar4_cos_WS$nugget, fitvar4_cos_WS$cov.pars[1], fitvar4_cos_WS$cov.pars[2])\n\nresumen_wv_WS &lt;- cbind(\n  c(\"MCO\", \"1/n\", \"Cressie\",\"MLE\"),\n  rbind(\n    par1WScos,\n    par2WScos,\n    par3WScos,\n    par4WScos\n  ),\n  MSE = c(\n    MSE_sv(variog_WS$gamma_hat, par1WScos, NA, model = \"wave\", variog_WS$h),\n    MSE_sv(variog_WS$gamma_hat, par2WScos, NA, model = \"wave\", variog_WS$h),\n    MSE_sv(variog_WS$gamma_hat, par3WScos, NA, model = \"wave\", variog_WS$h),\n    MSE_sv(variog_WS$gamma_hat, par4WScos, NA, model = \"wave\", variog_WS$h)\n  )\n)\n\nresumen_wv_WS &lt;- as.data.frame(resumen_wv_WS)\nresumen_wv_WS[ , -1] &lt;- lapply(resumen_wv_WS[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_wv_WS, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n1.692\n1.447\n60000.00\n1.014\n\n\n1/n\n1.069\n2.467\n50139.56\n0.864\n\n\nCressie\n1.300\n2.284\n50724.55\n0.908\n\n\nMLE\n2.819\n0.890\n60000.00\n1.450\n\n\n\n\n\n\n\n\nAl comparar los valores del MSE, se determinó que el modelo más adecuado es el Wave, ajustado mediante el método de WSL con ponderación basada en el número de pares por distancia en el semivariograma.\n\n\n\n1.2.3.3 Kriging\nEl modelo Wave, con los parámetros obtenidos por WLS usando la ponderación 1/n, que se usará para realizar Kriging es el siguiente:\n\n\n\n\n\n\n\n\n\nPara realizar la predicción, se genera una muestra aleatoria de puntos dentro del polígono que delimita el estado de California mediante la función spsample() del paquete sp. Sobre estos puntos se estiman los valores esperados aplicando el método de Kriging de vecinos cercanos, con el fin de mejorar la precisión de las estimaciones al considerar las grandes distancias características del territorio californiano. El procedimiento se implementa mediante la función krige() de gstat, especifícando la opción nmin=20 y utilizando la función predict() de base de R.\n\n\nVer código\n#Se escoge el mejor modelo --------------------------------\n\nbest_model_WS &lt;- gstat::vgm(psill = par2WScos[2],\n                           model = \"Wav\",\n                           range = par2WScos[3],\n                           nugget = par2WScos[1]\n)\n\n#Se crea un objeto en gstat -------------------------------\n\ncoordinates(datosWS) &lt;- ~Este + Norte\nproj4string(datosWS) &lt;- CRS(\"EPSG:3310\")\n\ng_obj&lt;-gstat::gstat(id=\"WindSpeed\",\n             formula = WindSpeed ~ Norte*Este,\n             model = best_model_WS,\n             data = datosWS)\n\n#Kriging -------------------------------------------------\n\nsuppressMessages(predic &lt;- predict(g_obj, newdata = new, nmin = 20))\n\n#Mapas de predicción --------------------------------------\n\ngridded(predic) &lt;- TRUE\n\n#1. Mapa de Kriging ---------------------------------------\n\npredic_raster_utm &lt;- raster(predic, layer = \"WindSpeed.pred\")\n\ncrs(predic_raster_utm) &lt;- \"+init=epsg:3310\"\n\npredic_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        predic_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmin_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='min')\nmax_pred &lt;- raster::cellStats(predic_raster_wgs84, stat='max')\n\npred_range &lt;- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))\n\nstep_pred &lt;- (max_pred-min_pred)/ 6\n\nbins &lt;- round(seq(min_pred, max_pred, by=step_pred),0)\n\npal_pred &lt;- colorBin(\n  palette = \"viridis\", # La paleta de colores\n  domain = pred_range,\n  bins = bins,\n  na.color = \"transparent\"\n)\n\nmapa_kriging_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    predic_raster_wgs84,\n    colors = pal_pred, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n    addCircleMarkers(data = datosWS_sf_wgs84,\n                   fillColor = ~palWS(WindSpeed),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"WS:\", WindSpeed, \"m/s\")) %&gt;% \n  addLegend(\n    pal = pal_pred, \n    values = pred_range,\n    title = \"Predicción WS (m/s)\",\n    position = \"topright\"\n  ) %&gt;%\n  addLegend(pal = palWS,\n            values = datosWS_sf_wgs84$WindSpeed,\n            title = \"WS Observada\",\n    position = \"topleft\"\n  ) \n\n#2 Mapa Varianza------------------------------------------\n\nvar_raster_utm &lt;- raster(predic, layer = \"WindSpeed.var\")\n\ncrs(var_raster_utm) &lt;- \"+init=epsg:3310\"\n\nvar_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        var_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nmax_var &lt;- raster::cellStats(var_raster_wgs84, stat='max')\nstep_var &lt;- max_var / 6\n\nbinsv &lt;- round(seq(0, max_var, by=step_var),2)\n\nvar_range &lt;- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))\npal_var &lt;- colorBin(\n  palette = \"Spectral\", # La paleta de colores\n  domain = var_range,\n  bins = binsv,\n  na.color = \"transparent\"\n)\n\nmapa_var_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    var_raster_wgs84, \n    colors = pal_var, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  addLegend(\n    pal = pal_var, \n    values = var_range,\n    title = \"Varianza\",\n    position = \"topright\"\n  ) \n\n#3. Mapa Cv ----------------------------------------------\n\npredic$cv &lt;- sqrt(predic$WindSpeed.var) / pmax(abs(predic$WindSpeed.pred), 1e-6)\n\npredic$cv[predic$cv &gt; 1] &lt;- 1\n\ncv_raster_utm &lt;- raster(predic, layer = \"cv\")\n\ncrs(cv_raster_utm) &lt;- \"+init=epsg:3310\"\n\ncv_terra &lt;- terra::rast(cv_raster_utm)\n\nmasked_cv_terra &lt;- terra::mask(cv_terra, sh_terra)\n\ncv_raster_wgs84_terra &lt;- terra::project(\n    masked_cv_terra, \n    y = \"epsg:4326\", \n    method = \"bilinear\" # Similar a projectRaster\n)\n\ncv_raster_wgs84 &lt;- raster::raster(cv_raster_wgs84_terra)\n\nmax_cv &lt;- raster::cellStats(cv_raster_wgs84, stat='max')\nstep_cv &lt;- max_cv / 10\n\nbincv &lt;- seq(0,max_cv, by=step_cv)\n\ncv_range &lt;- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))\n\n\npal_cv &lt;- colorBin(\n  palette = \"RdYlGn\", # Rojo-Amarillo-Verde\n  domain = cv_range,\n  na.color = \"transparent\",\n  bins = bincv,\n  reverse = TRUE \n)\n\nmapa_cv_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addRasterImage(\n    cv_raster_wgs84, \n    colors = pal_cv, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  \n  addLegend(\n    pal = pal_cv, \n    values = cv_range,\n    title = \"Coeficiente de Variación\",\n    position = \"topright\"\n  )\n\n\nEn el siguiente panel se presentan 3 mapas que resumen el proceso de predicción:\n\nPredicciónVarianzaCoeficiente de variación\n\n\n\n\nVer código\nmapa_kriging_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_var_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_cv_leaflet\n\n\n\n\n\n\n\n\n\nLa velocidad del viento es más elevada en el Valle Central y en el interior sur de California, y, en general, las predicciones en la mitad sur del estado muestran buena precisión (bajo coeficiente de variación). La incertidumbre más alta se concentra en el extremo norte, debido a la escasez de datos. El modelo Wave se utiliza para capturar la naturaleza variable del viento; sin embargo, la varianza sigue siendo elevada en zonas con baja densidad de estaciones y en algunas áreas muestreadas donde el viento probablemente es más turbulento o errático, lo que dificulta la interpolación. Para mitigar el efecto de las grandes distancias entre estaciones, se aplicó un Kriging de vecinos cercanos, lo que mejora la fiabilidad de las predicciones en puntos aislados.\n\n1.2.3.3.1 Métricas de Validación Cruzada\nA continuación se presentan las métricas de validación cruzada obtenidas mediante la función krige.cv() del paquete gstat:\n\n\nVer código\ninvisible(cv_ws &lt;- krige.cv(WindSpeed ~ Norte*Este,\n                  datosWS,\n                  model = best_model_WS))\n\npander::pander(metricas_cv(cv_ws), digits=3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nME\nMAE\nRMSE\nR2\nMPSE\nCOR\n\n\n\n\n-0.0159\n1.22\n1.67\n0.598\n1.38\n0.774\n\n\n\n\n\nEl ME cercano a cero indica que el Kriging no presenta un sesgo sistemático al estimar la velocidad del viento, lo que es coherente con el buen desempeño del modelo en la mitad sur del estado, donde la mayor disponibilidad de estaciones reduce la incertidumbre. Los errores promedio también son bajos; muestran que las diferencias entre lo observado y lo predicho son relativamente pequeñas, lo cual se ajusta a las zonas donde la variación del viento es más estable y el coeficiente de variación resultó reducido.\nEl valor del R^2 y la correlación, indican que el modelo captura más de la mitad de la variabilidad del viento y mantiene una relación fuerte entre las predicciones y los valores reales. Sin embargo, estos valores también sugieren que existe una parte importante de variabilidad que no logra modelarse del todo, algo que coincide con las zonas del norte donde el viento es más errático y la densidad de estaciones es baja. En conjunto, las métricas reflejan un modelo con buen rendimiento general, pero cuya precisión disminuye inevitablemente en áreas donde el fenómeno es más turbulento o hay grandes distancias entre puntos de observación.",
    "crumbs": [
      "Geoestadística",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Análisis Univariado</span>"
    ]
  },
  {
    "objectID": "Geo_uni.html#conclusiones",
    "href": "Geo_uni.html#conclusiones",
    "title": "1  Análisis Univariado",
    "section": "1.3 Conclusiones",
    "text": "1.3 Conclusiones\n\nSe logró modelar y mitigar la tendencia espacial de todas las variables analizadas. Las correlaciones iniciales con las coordenadas, principalmente para temperatura, se redujeron significativamente tras el ajuste de los modelos de media, evidenciado tanto en los gráficos de dispersión como en los coeficientes significativos de los modelos.\nLos modelos de semivariograma ajustados (Esférico, Wave y Exponencial según la variable) capturaron la dependencia espacial de manera adecuada. El uso del Kriging de vecinos cercanos permitió mitigar el efecto de las grandes distancias entre estaciones de monitoreo, mejorando la precisión en zonas con baja densidad de datos, aunque persistió incertidumbre relativa en el norte y áreas fronterizas.\nLas predicciones son más confiables en regiones con alta densidad de estaciones (sur y Valle Central), mientras que la varianza y el coeficiente de variación son mayores en el norte y en áreas rurales o fronterizas, reflejando la menor disponibilidad de datos y la complejidad local de ciertas variables, como la velocidad del viento.\nLas métricas de validación confirmaron el buen desempeño general de los modelos de Kriging. El sesgo fue prácticamente nulo y los errores promedio se mantuvieron en niveles moderados para todas las variables, mientras que las correlaciones superiores a 0.70 y los valores de R^2 cercanos al 0.60 reflejan una relación sólida entre los valores observados y los predichos.\nLa temperatura es más alta en el sur del estado y en el Valle Central. La velocidad del viento muestra máximos en el Valle Central y el interior sur, reflejando la heterogeneidad espacial del comportamiento atmosférico en California.\nEl enfoque geoestadístico permitió cumplir los objetivos planteados: se identificaron patrones espaciales, se estimaron semivariogramas y se ajustaron modelos teóricos adecuados, y se construyeron mapas de predicción y de incertidumbre que representan de manera confiable la distribución espacial de las variables. Esto demuestra que la metodología es útil para caracterizar la variabilidad espacial de variables meteorológicas y contaminantes como el ozono, incluso en territorios extensos como California",
    "crumbs": [
      "Geoestadística",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Análisis Univariado</span>"
    ]
  },
  {
    "objectID": "Geo_bi.html",
    "href": "Geo_bi.html",
    "title": "2  Análisis Bivariado",
    "section": "",
    "text": "2.1 Planteamiento del problema",
    "crumbs": [
      "Geoestadística",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis Bivariado</span>"
    ]
  },
  {
    "objectID": "Geo_bi.html#planteamiento-del-problema",
    "href": "Geo_bi.html#planteamiento-del-problema",
    "title": "2  Análisis Bivariado",
    "section": "",
    "text": "2.1.1 Introducción\nLa calidad del aire influye directamente en la salud y el bienestar, y en California este tema es especialmente crítico debido a su alta densidad poblacional, el tráfico vehicular, la actividad industrial y fenómenos como los incendios forestales. Estas condiciones favorecen episodios recurrentes de contaminación, cuya intensidad y dispersión dependen en gran medida de factores meteorológicos.\nEntre ellos, la temperatura y la velocidad del viento son variables clave, pues afectan la acumulación y transporte de contaminantes y, además, presentan una fuerte dependencia espacial y correlación entre sí. Para capturar esta relación conjunta y mejorar la precisión de la interpolación espacial, empleamos un modelo de cokriging, que permite analizar simultáneamente las estructuras de variabilidad y covariación entre ambas variables a partir de los datos registrados en estaciones meteorológicas de California.\n\n\n2.1.2 Descripción de los datos\nLos datos objeto de este estudio provienen de la Agencia de Protección Ambiental (EPA) de los Estados Unidos y corresponden a registros horarios obtenidos de las estaciones de monitoreo durante el mes de marzo de 2024. En particular, se analizan las variables Temperatura ambiente (Temp) y Velocidad del viento (WS).\n\n2.1.2.1 Unidades\n\nTemperatura ambiente: Medida en grados celsius (C°) con una intensidad horaria.\nVelocidad del viento: Medida en metros por segundo (m/s) con una intensidad horaria.\n\n\n\n\n2.1.3 Objetivos\n\n2.1.3.1 Objetivo general\nEstudiar e identificar la tendencia y los patrones espaciales de la temperatura y la velocidad del viento mediante herramientas de análisis geoestadístico bivariado, con el propósito de construir un modelo de cokriging que permita caracterizar y predecir su comportamiento espacial en el estado de California durante un periodo específico de tiempo en marzo de 2024.\n\n\n2.1.3.2 Objetivos específicos\n\nConstruir los semivariogramas empíricos directos y cruzados, y ajustar un Modelo Lineal de Corregionalización (LMC) que describa adecuadamente la dependencia espacial conjunta entre ambas variables, garantizando la validez y coherencia del modelo multivariado.\nAplicar la técnica de Cokriging para construir los mapas de predicción espacial y los mapas de incertidumbre asociados, con el fin de representar la distribución esperada de las variables y evaluar la precisión de las estimaciones.\nComparar los resultados del Cokriging con los obtenidos mediante Kriging univariado, evaluando la ganancia en precisión y estabilidad derivada del uso de información cruzada entre las variables",
    "crumbs": [
      "Geoestadística",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis Bivariado</span>"
    ]
  },
  {
    "objectID": "Geo_bi.html#análisis-geoestadístico-bivariado",
    "href": "Geo_bi.html#análisis-geoestadístico-bivariado",
    "title": "2  Análisis Bivariado",
    "section": "2.2 Análisis Geoestadístico Bivariado",
    "text": "2.2 Análisis Geoestadístico Bivariado\nEn este análisis se consideran los datos de temperatura y velocidad del viento registrados a las 00:00 horas del 1 de marzo de 2024.\n\n\nVer código\nlibrary(readxl)\nlibrary(geoR)\nlibrary(matrixcalc)\nlibrary(dplyr)\nlibrary(geoR)\nlibrary(sp)\nlibrary(readxl)\nlibrary(tidyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(raster)\nlibrary(stars)\nlibrary(gstat)\nlibrary(Matrix)\n\n\n#Gráficos de dispersión ----------------------------------\n\nsimple_scatter_plot &lt;- function(datos, variable1, variable2) {\n\n    plot1 &lt;- ggplot(as.data.frame(datos),\n                    aes(x = .data[[variable1]], y = .data[[variable2]],\n                               color = as.factor(1))) +\n                    geom_point() +\n                    scale_colour_viridis_d() +\n                    labs(\n                        x = variable1,\n                        y = variable2\n                        ) +\n                    theme_light() +\n                    theme(legend.position = \"none\")\n\n    return(plot1)\n\n}\n\n#Variable Temperatura ---------------------------------------\n\nTemp &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Temperatura\")\ncolnames(Temp)[-1] &lt;- as.numeric(colnames(Temp)[-1])\nEstacionesT &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesT &lt;- EstacionesT %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesT &lt;- EstacionesT %&gt;% filter(AQSID %in% colnames(Temp)[-1])\n\ny_T &lt;- Temp[1,] #Tomar una fecha\ny_T &lt;- cbind(colnames(y_T),t(y_T[1,]))\ny_T &lt;- y_T[-1,]\ny_T &lt;- as.data.frame(y_T)\ny_T &lt;- na.omit(y_T)\ny_T &lt;- y_T[-which.min(y_T$V2),]\ny_T$V1 &lt;- as.numeric(y_T$V1)\ny_T &lt;- inner_join(y_T, EstacionesT, by=c(\"V1\"=\"AQSID\"))\ndatosT &lt;- y_T[,c(13,14,2)]\ncolnames(datosT)=c(\"Este\",\"Norte\",\"Temperatura\")\ndatosT$Temperatura &lt;- as.numeric(datosT$Temperatura)\n\ntemp &lt;- as.geodata(datosT)\n\n\n\n#Variable Velocidad del viento ------------------------------\n\nWS &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"WindSpeed\")\ncolnames(WS)[-1] &lt;- as.numeric(colnames(WS)[-1])\nEstacionesWS &lt;- read_excel(\"GeoEst_Cali.xlsx\", sheet = \"Estaciones\")\nEstacionesWS &lt;- EstacionesWS %&gt;% mutate(AQSID = as.numeric(AQSID))\nEstacionesWS &lt;- EstacionesWS %&gt;% filter(AQSID %in% colnames(WS)[-1])\n\ny_WS &lt;- WS[1,] #Tomar una fecha\ny_WS &lt;- cbind(colnames(y_WS),t(y_WS[1,]))\ny_WS &lt;- y_WS[-1,]\ny_WS &lt;- as.data.frame(y_WS)\ny_WS &lt;- na.omit(y_WS)\ny_WS$V1 &lt;- as.numeric(y_WS$V1)\ny_WS &lt;- inner_join(y_WS, EstacionesWS, by=c(\"V1\"=\"AQSID\"))\ndatosWS &lt;- y_WS[,c(13,14,2)]\ncolnames(datosWS)=c(\"Este\",\"Norte\",\"WindSpeed\")\ndatosWS$WindSpeed &lt;- as.numeric(datosWS$WindSpeed)\n\nws &lt;- as.geodata(datosWS)\n\n#Para el mapa de California -------------------------------\n\nsh_mundos&lt;-st_read(\"admin00.shp\",quiet=TRUE)\nsh_mundos &lt;- sh_mundos %&gt;% filter(CNTRY_NAME==\"United States\")\nsh_mundos &lt;- sh_mundos %&gt;% filter(ADMIN_NAME==\"California\")\n\nCRS_UTM_NY = \"+init=epsg:3310\"\n\nsh_mundos_wgs84 &lt;- st_transform(sh_mundos, crs = 4326)\n\nsh_mundos_utm &lt;- st_transform(sh_mundos, crs = CRS(\"EPSG:3310\"))\n\nsh_mundos_sp_utm &lt;- as(sh_mundos_utm, \"Spatial\")\n\nsh_mundos_utm_simple &lt;- st_union(sh_mundos_utm)\nsh_mundos_sp_utm_simple &lt;- as(sh_mundos_utm_simple, \"Spatial\")\n\n\n\nTemperaturaVelocidad del viento\n\n\n\n\nVer código\ndatosT_sf &lt;- st_as_sf(datosT, coords = c(\"Este\", \"Norte\"), crs = 3310)\n\ndatosT_sf_wgs84 &lt;- st_transform(datosT_sf, crs = 4326)\n\npal &lt;- colorNumeric(palette = \"viridis\", domain = datosT_sf_wgs84$Temperatura)\n\nleaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = \"black\", weight = 2) %&gt;%\n  addCircleMarkers(data = datosT_sf_wgs84,\n                   fillColor = ~pal(Temperatura),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"Temp:\", Temperatura, \"°C\")) %&gt;%\n  addLegend(pal = pal, values = datosT_sf_wgs84$Temperatura, title = \"Temperatura (°C)\")\n\n\n\n\n\n\nVer código\npander::pander(summary(temp))\n\n\n\nn: 122\ncoords.summary:\n\n\n\n\n\n\n\n\n \nEste\nNorte\n\n\n\n\nmin\n-325701\n-580919\n\n\nmax\n387270\n281577\n\n\n\ndistances.summary:\n\n\n\n\n\n\n\nmin\nmax\n\n\n\n\n609.2\n1e+06\n\n\n\ndata.summary:\n\n\n\n\n\n\n\n\n\n\n\nMin.\n1st Qu.\nMedian\nMean\n3rd Qu.\nMax.\n\n\n\n\n-3.2\n13.15\n15.8\n14.43\n17.2\n24.5\n\n\n\n\n\n\n\n\n\n\n\nVer código\ndatosWS_sf &lt;- st_as_sf(datosWS, coords = c(\"Este\", \"Norte\"), crs = 3310)\n\ndatosWS_sf_wgs84 &lt;- st_transform(datosWS_sf, crs = 4326)\n\npalWS &lt;- colorNumeric(palette = \"viridis\", domain = datosWS_sf_wgs84$WindSpeed)\n\nleaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = \"black\", weight = 2) %&gt;%\n  addCircleMarkers(data = datosWS_sf_wgs84,\n                   fillColor = ~palWS(WindSpeed),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 3,\n                   popup = ~paste(\"WindSpeed:\", WindSpeed, \"m/s\")) %&gt;%\n  addLegend(pal = palWS, values = datosWS_sf_wgs84$WindSpeed, title = \"WindSpeed (m/s)\")\n\n\n\n\n\n\nVer código\npander::pander(summary(ws))\n\n\n\nn: 89\ncoords.summary:\n\n\n\n\n\n\n\n\n \nEste\nNorte\n\n\n\n\nmin\n-276541\n-543973\n\n\nmax\n415574\n281577\n\n\n\ndistances.summary:\n\n\n\n\n\n\n\nmin\nmax\n\n\n\n\n2216\n987994\n\n\n\ndata.summary:\n\n\n\n\n\n\n\n\n\n\n\nMin.\n1st Qu.\nMedian\nMean\n3rd Qu.\nMax.\n\n\n\n\n0.8\n2.5\n3.8\n4.375\n5.5\n14.1\n\n\n\n\n\n\n\n\n\n\n\n2.2.1 Modelos Univariados\n\n2.2.1.1 Análisis de Estacionariedad en Media\nEl estudio de la influencia de las coordenadas espaciales en la media de ambas variables ya se realizó en el Análisis Univariado. A continuación se presenta únicamente un resumen del ajuste.\n\nTemperaturaVelocidad del viento\n\n\nEl modelo es: Temperatura = \\beta_0 + \\beta_1 \\times Norte + \\beta_2 \\times Norte^2\n\n\nVer código\nfitT &lt;- lm(Temperatura~Norte+I(Norte^2), data = datosT) \ndatosT$Residuos &lt;- fitT$residuals\n\npT1 &lt;- simple_scatter_plot(datosT, \"Este\", \"Residuos\")\npT2 &lt;- simple_scatter_plot(datosT, \"Norte\", \"Residuos\")\n\ncowplot::plot_grid(pT1,pT2)\n\n\n\n\n\n\n\n\n\nVer código\npander::pander(summary(fitT))\n\n\n\n\n\n\n\n\n\n\n\n\n \nEstimate\nStd. Error\nt value\nPr(&gt;|t|)\n\n\n\n\n(Intercept)\n13.26\n0.5352\n24.77\n8.812e-49\n\n\nNorte\n-2.229e-05\n3.23e-06\n-6.901\n2.676e-10\n\n\nI(Norte^2)\n-3.754e-11\n8.551e-12\n-4.39\n2.469e-05\n\n\n\n\nFitting linear model: Temperatura ~ Norte + I(Norte^2)\n\n\n\n\n\n\n\n\nObservations\nResidual Std. Error\nR^2\nAdjusted R^2\n\n\n\n\n122\n4.049\n0.3199\n0.3084\n\n\n\n\n\n\n\nEl modelo es: WindSpeed = \\beta_0 + \\beta_1 \\times Este + \\beta_2 \\times Norte + \\beta_3 \\times Este \\times Norte\n\n\nVer código\nfitWS &lt;- lm(WindSpeed~Este*Norte, data = datosWS) \ndatosWS$Residuos &lt;- fitWS$residuals\n\npWS1 &lt;- simple_scatter_plot(datosWS, \"Este\", \"Residuos\")\npWS2 &lt;- simple_scatter_plot(datosWS, \"Norte\", \"Residuos\")\n\ncowplot::plot_grid(pWS1,pWS2)\n\n\n\n\n\n\n\n\n\nVer código\npander::pander(summary(fitWS))\n\n\n\n\n\n\n\n\n\n\n\n\n \nEstimate\nStd. Error\nt value\nPr(&gt;|t|)\n\n\n\n\n(Intercept)\n6.398\n0.3639\n17.58\n4.751e-30\n\n\nEste\n2.069e-05\n2.674e-06\n7.739\n1.895e-11\n\n\nNorte\n1.159e-05\n1.808e-06\n6.411\n7.746e-09\n\n\nEste:Norte\n2.558e-11\n7.483e-12\n3.419\n0.000968\n\n\n\n\nFitting linear model: WindSpeed ~ Este * Norte\n\n\n\n\n\n\n\n\nObservations\nResidual Std. Error\nR^2\nAdjusted R^2\n\n\n\n\n89\n1.938\n0.4851\n0.4669\n\n\n\n\n\n\n\n\n\n\n2.2.1.2 Variogramas\nDado que se hará uso de las herramientas del paquete gstat se consideró necesario revisar cuál de las estimaciones presentadas en el Capítulo 1, mediante GeoR, se ajustan mejor a este entorno.\n\nTemperaturaVelocidad del viento\n\n\n\n\nVer código\ndatosT1 &lt;- datosT\ninvisible(coordinates(datosT1) &lt;- ~ Este + Norte)\nvg_T &lt;-  variogram(Temperatura~Norte+I(Norte^2), datosT1, cressie=T)\nexp_T &lt;- fit.variogram(vg_T, vgm(\"Exp\"),\n                          fit.method = 2)\nplot(vg_T, model = exp_T)\n\n\n\n\n\n\n\n\n\nVer código\npander::pander(exp_T)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nNug\n0\n0\n0\n0\n0\n0\n1\n1\n\n\nExp\n12.88\n109814\n0.5\n0\n0\n0\n1\n1\n\n\n\n\n\n\n\n\n\nVer código\ndatosWS1 &lt;- datosWS\ninvisible(coordinates(datosWS1) &lt;- ~ Este + Norte)\nvg_WS &lt;-  variogram(WindSpeed~Norte*Este, datosWS1,cressie=T)\nexp_WS &lt;- fit.variogram(vg_WS, vgm(\"Wav\"),\n                          fit.method = 7)\nplot(vg_WS, model = exp_WS)\n\n\n\n\n\n\n\n\n\nVer código\npander::pander(exp_WS)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nNug\n1.517\n0\n0\n0\n0\n0\n1\n1\n\n\nWav\n1.678\n115834\n0.5\n0\n0\n0\n1\n1\n\n\n\n\n\n\n\n\n\n\n\n2.2.2 Modelo Lineal de Corregionalización\nConsiderando un modelo Exponencial para Temperatura y un modelo Wave para WS, se proponen los siguientes valores, ajustados por la función nearPD del paquete Matrix con el objetivo de garantizar un modelo válido de coregionalización, para las matrices:\n\n\nVer código\nmat1 &lt;- cbind(c(6, 4),\n              c(4, 0))\n\nmat1 &lt;- nearPD(mat1)$mat\nmat1 &lt;- as.matrix(mat1)\n\ncolnames(mat1) &lt;- rownames(mat1)&lt;- c(\"Temp\",\"WS\")\n\nmat2 &lt;-cbind(c(4.5, 4.2),\n             c(4.2, 0))\n\nmat2 &lt;- nearPD(mat2)$mat\nmat2 &lt;- as.matrix(mat2)\n\ncolnames(mat2) &lt;- rownames(mat2)&lt;- c(\"Temp\",\"WS\")\n\nmat3 &lt;-cbind(c(0, 3),\n             c(3, 0.1))\n\nmat3 &lt;- nearPD(mat3)$mat\nmat3 &lt;- as.matrix(mat3)\n\ncolnames(mat3) &lt;- rownames(mat3)&lt;- c(\"Temp\",\"WS\")\n\n\n\nExponencialWaveNugget\n\n\n\n\nVer código\npander::pander(mat1, caption = \"Matriz para Temperatura\")\n\n\n\nMatriz para Temperatura\n\n\n\n\n\n\n\n \nTemp\nWS\n\n\n\n\nTemp\n6.4\n3.2\n\n\nWS\n3.2\n1.6\n\n\n\n\n\n\n\n\n\nVer código\npander::pander(mat2, caption = \"Matriz para Velocidad del viento\")\n\n\n\nMatriz para Velocidad del viento\n\n\n\n\n\n\n\n \nTemp\nWS\n\n\n\n\nTemp\n5.164\n3.092\n\n\nWS\n3.092\n1.851\n\n\n\n\n\n\n\n\n\nVer código\npander::pander(mat3, caption = \"Matriz para Nugget\")\n\n\n\nMatriz para Nugget\n\n\n\n\n\n\n\n \nTemp\nWS\n\n\n\n\nTemp\n1.5\n1.525\n\n\nWS\n1.525\n1.551\n\n\n\n\n\n\n\n\nPara los valores iniciales se tiene el siguiente ajuste:\n\n\nVer código\nvgmntemp &lt;- vgm(psill = mat1[1, 1],\n              model = \"Exp\",\n              range = exp_T$range[2],\n              nugget = mat3[1,1],\n              add.to = vgm(psill = mat2[1, 1],\n                           model = \"Wav\",\n                           range = exp_WS$range[2]))\n\nvgmws &lt;- vgm(psill = mat1[2, 2],\n             model = \"Exp\",\n             range = exp_T$range[2],\n             nugget = mat3[2,2],\n             add.to = vgm(psill = mat2[2, 2],\n                          model = \"Wav\",\n                          range = exp_WS$range[2]))\n\n\nvgmntemp_sv &lt;- vgm(psill = mat1[1, 2],\n                   model = \"Exp\",\n                 range = exp_T$range[2],\n                 nugget = mat3[1,2],\n                 add.to = vgm(psill = mat2[1, 2],\n                              model = \"Wav\",\n                              range = exp_WS$range[2]))\n\n\n\ng &lt;- gstat(NULL, id=\"Temp\", formula=Temperatura~Norte+I(Norte^2),\n           data=datosT1, model = vgmntemp)\ng &lt;- gstat(g, id=\"W_speed\", formula=WindSpeed~Norte*Este,\n           data=datosWS1, model = vgmws)\ng &lt;- gstat(g, c(\"Temp\",\"W_speed\"), model = vgmntemp_sv)\n\nplot(variogram(g, cressie=T),\n     model = g$model,\n     pl = F,\n     xlab = \"Distancias\",\n     ylab = \"Semivarianza\")\n\n\n\n\n\n\n\n\n\nVer código\npander::pander(g$model)\n\n\n\nTemp:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nWav\n5.164\n115834\n0.5\n0\n0\n0\n1\n1\n\n\nNug\n1.5\n0\n0\n0\n0\n0\n1\n1\n\n\nExp\n6.4\n109814\n0.5\n0\n0\n0\n1\n1\n\n\n\nW_speed:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nWav\n1.851\n115834\n0.5\n0\n0\n0\n1\n1\n\n\nNug\n1.551\n0\n0\n0\n0\n0\n1\n1\n\n\nExp\n1.6\n109814\n0.5\n0\n0\n0\n1\n1\n\n\n\nTemp.W_speed:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nWav\n3.092\n115834\n0.5\n0\n0\n0\n1\n1\n\n\nNug\n1.525\n0\n0\n0\n0\n0\n1\n1\n\n\nExp\n3.2\n109814\n0.5\n0\n0\n0\n1\n1\n\n\n\n\n\n\n\nAhora, realizando el ajuste mediante la función fit.lmc de `gstat:\n\n\nVer código\nvgcross &lt;- gstat(NULL, id = \"Temp\",\n                 form = Temperatura~Norte+I(Norte^2),\n                 data = datosT1)\n\nvgcross &lt;- gstat(vgcross, id = \"W_speed\",\n                 form = WindSpeed~Norte*Este,\n                 data = datosWS1)\n\nvg &lt;- variogram(vgcross, cressie=T)\n\nfit &lt;- fit.lmc(vg, g, fit.method=6, correct.diagonal=1.01)\n\nplot(vg, model = fit$model)\n\n\n\n\n\n\n\n\n\nVer código\npander::pander(fit$model)\n\n\n\nTemp:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nWav\n7.231\n115834\n0.5\n0\n0\n0\n1\n1\n\n\nNug\n2.782\n0\n0\n0\n0\n0\n1\n1\n\n\nExp\n4.2\n109814\n0.5\n0\n0\n0\n1\n1\n\n\n\nW_speed:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nWav\n1.395\n115834\n0.5\n0\n0\n0\n1\n1\n\n\nNug\n3.066\n0\n0\n0\n0\n0\n1\n1\n\n\nExp\n2.079\n109814\n0.5\n0\n0\n0\n1\n1\n\n\n\nTemp.W_speed:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nWav\n3.145\n115834\n0.5\n0\n0\n0\n1\n1\n\n\nNug\n2.892\n0\n0\n0\n0\n0\n1\n1\n\n\nExp\n0.6695\n109814\n0.5\n0\n0\n0\n1\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\nEn desarrollo…\n\n\n\n\n\n\n\n\n2.2.3 Cokriging\n\n\n\n\n\n\nEn desarrollo…",
    "crumbs": [
      "Geoestadística",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis Bivariado</span>"
    ]
  },
  {
    "objectID": "Geo_bi.html#kriging-vs-cokriging",
    "href": "Geo_bi.html#kriging-vs-cokriging",
    "title": "2  Análisis Bivariado",
    "section": "2.3 Kriging vs Cokriging",
    "text": "2.3 Kriging vs Cokriging\n\n\n\n\n\n\nEn desarrollo…",
    "crumbs": [
      "Geoestadística",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis Bivariado</span>"
    ]
  },
  {
    "objectID": "Geo_bi.html#conclusiones",
    "href": "Geo_bi.html#conclusiones",
    "title": "2  Análisis Bivariado",
    "section": "2.4 Conclusiones",
    "text": "2.4 Conclusiones\n\n\n\n\n\n\nEn desarrollo…",
    "crumbs": [
      "Geoestadística",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis Bivariado</span>"
    ]
  },
  {
    "objectID": "Geo_esp_temp.html",
    "href": "Geo_esp_temp.html",
    "title": "3  Análisis Geoestadístico Espacio Temporal",
    "section": "",
    "text": "3.1 Planteamiento del problema",
    "crumbs": [
      "Geoestadística Espacio Temporal",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Análisis Geoestadístico Espacio Temporal</span>"
    ]
  },
  {
    "objectID": "Geo_esp_temp.html#planteamiento-del-problema",
    "href": "Geo_esp_temp.html#planteamiento-del-problema",
    "title": "3  Análisis Geoestadístico Espacio Temporal",
    "section": "",
    "text": "3.1.1 Introducción\nLa calidad del aire es un elemento fundamental para la salud pública, el bienestar de las comunidades y el equilibrio de los ecosistemas. El deterioro de este recurso no solo incrementa el riesgo de enfermedades respiratorias y cardiovasculares, sino que también afecta la productividad, la calidad de vida y el funcionamiento de los sistemas naturales. En los últimos años, la preocupación por la contaminación atmosférica ha crecido debido a la combinación de factores antropogénicos y ambientales que intensifican la presencia de compuestos dañinos en la atmósfera, entre ellos el ozono troposférico y las variaciones extremas de temperatura.\nEn el estado de California, esta problemática adquiere una dimensión particular. Su elevada densidad poblacional, el tránsito vehicular, la actividad industrial y ciertos fenómenos naturales, como los incendios forestales, cada vez más frecuentes, contribuyen a que numerosas ciudades presenten niveles críticos de contaminación. Estas condiciones hacen necesario un análisis más profundo de la dinámica espacial y temporal de los contaminantes atmosféricos. En este contexto, el uso de herramientas estadísticas avanzadas, como el análisis espacio temporal, se convierte en un enfoque útil para comprender los patrones subyacentes y apoyar la toma de decisiones en materia ambiental.\n\n\n3.1.2 Descripción de los datos\nLos datos objeto de este estudio provienen de la Agencia de Protección Ambiental (EPA) de los Estados Unidos y corresponden a registros horarios obtenidos de las estaciones de monitoreo durante el mes de marzo de 2024. En particular, se analiza las variable Temperatura ambiente (Temp).\n\n3.1.2.1 Unidades\n\nTemperatura ambiente: Medida en grados celsius (C°) con una intensidad horaria.\n\n\n\n\n3.1.3 Objetivos\n\n3.1.3.1 Objetivo general\nModelar y predecir la distribución tridimensional (espacio y tiempo) de la Temperatura en el estado de California durante el periodo de 24 horas del 3 de marzo de 2024. Este análisis se realizará mediante el Kriging Espacio-Temporal, utilizando datos de 127 estaciones, con el fin de caracterizar la variabilidad espacio-temporal de la variable y generar un modelo de predicción.\n\n\n3.1.3.2 Objetivos específicos\n\nAnalizar la autocorrelación espacio-temporal de la Temperatura en California a lo largo de 24 horas mediante la construcción y análisis del semivariograma espacio-temporal empírico, y ajustar un modelo de semivariograma Teorico separable o no separable, que permita definir explícitamente la estructura de dependencia combinada entre las distancias espaciales y temporales.\nImplementar Kriging Espacio Temporal para generar mapas de predicción espacial y mapas de incertidumbre, utilizando l estructura de covarianza estimada, con el fin de representar la distribución esperada de las variables y evaluar la precisión de las estimaciones.",
    "crumbs": [
      "Geoestadística Espacio Temporal",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Análisis Geoestadístico Espacio Temporal</span>"
    ]
  },
  {
    "objectID": "Geo_esp_temp.html#análisis-geoestadístico-espacio-temporal",
    "href": "Geo_esp_temp.html#análisis-geoestadístico-espacio-temporal",
    "title": "3  Análisis Geoestadístico Espacio Temporal",
    "section": "3.2 Análisis Geoestadístico Espacio Temporal",
    "text": "3.2 Análisis Geoestadístico Espacio Temporal\nEn el análisis se consideran los datos de la Temperatura del periodo de 24 horas del 3 de marzo de 2024.\n\n\nVer código\nset.seed(123)\n\n#Librerias necesarias ------\nlibrary(dplyr)\nlibrary(geoR)\nlibrary(sp)\nlibrary(readxl)\nlibrary(tidyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(spacetime)\nlibrary(gstat)\nlibrary(GeoModels)\nlibrary(rcartocolor)\n\n#Variable Temperatura--------------------\n\nTemp &lt;- read_excel(\"Temp_imp.xlsx\", sheet = \"Temperatura\")\nTemp &lt;- as.data.frame(Temp)\nEstacionesT &lt;- read_excel(\"Temp_imp.xlsx\", sheet = \"Estaciones\")\nEstacionesT$AQSID&lt;-as.character(EstacionesT$AQSID)\nEstacionesT &lt;- EstacionesT[,c(1,12,13)]\nTemp_long &lt;- Temp %&gt;% pivot_longer(cols = -DateTime, names_to = \"AQSID\",\n                                   values_to = \"value\") %&gt;%  mutate(AQSID = as.character(AQSID))\nTemp_long&lt;-Temp_long %&gt;% \n  filter(as.Date(dmy_hms(Temp_long$DateTime)) == as.Date(\"2024-01-03\"))\nData_ST &lt;- Temp_long %&gt;% left_join(EstacionesT, by = \"AQSID\")\nData_ST$DateTime &lt;- dmy_hms(Data_ST$DateTime)\nData_ST$Hora &lt;- hour(Data_ST$DateTime)\n\n#Para el mapa de California -------------------------------\n\nsh_mundos&lt;-st_read(\"admin00.shp\",quiet=TRUE)\nsh_mundos &lt;- sh_mundos %&gt;% filter(CNTRY_NAME==\"United States\")\nsh_mundos &lt;- sh_mundos %&gt;% filter(ADMIN_NAME==\"California\")\n\nCRS_UTM_NY = \"+init=epsg:3310\"\n\nsh_mundos_wgs84 &lt;- st_transform(sh_mundos, crs = 4326)\n\nsh_mundos_utm &lt;- st_transform(sh_mundos, crs = CRS(\"EPSG:3310\"))\n\nsh_mundos_sp_utm &lt;- as(sh_mundos_utm, \"Spatial\")\n\nsh_mundos_utm_simple &lt;- st_union(sh_mundos_utm)\nsh_mundos_sp_utm_simple &lt;- as(sh_mundos_utm_simple, \"Spatial\")\n\n#Grilla para hacer kriging ------------------------------\n\nnew &lt;- sp::spsample(as(sh_mundos_utm, \"Spatial\"), n = 5000, type = \"regular\")\n\nproj4string(new) &lt;- CRS(\"EPSG:3310\")\ninvisible(coordinates(new) ~ Este + Norte)\ncolnames(new@coords) &lt;- c(\"Este\", \"Norte\")\n\n\n\n3.2.1 Variable Temperatura\nEn el siguiente bloque se muestra el código utilizado para imputar los valores faltantes en las 127 estaciones de California a lo largo de las 744 observaciones temporales. A partir de los modelos ajustados en el Análisis Univariado, se estimó un semivariograma para cada instante en el tiempo, seleccionando el modelo adecuado según el criterio de MSE. Finalmente, la predicción espacial se llevó a cabo mediante la función krige() del paquete gstat.\n\nkrig_list &lt;- list()\n\nProgress &lt;- txtProgressBar(min = 0, max = nrow(Temp), style = 3)\n\nfor (i in 1:nrow(Temp)){\n  \n  y_T &lt;- Temp[i,] #Tomar una fecha\n  y_T &lt;- cbind(colnames(y_T),t(y_T[1,]))\n  y_T &lt;- y_T[-1,]\n  y_T &lt;- as.data.frame(y_T)\n  y_T &lt;- na.omit(y_T)\n  y_T$V1 &lt;- as.numeric(y_T$V1)\n  y_T &lt;- inner_join(y_T, EstacionesT, by=c(\"V1\"=\"AQSID\"))\n  datosT &lt;- y_T[,c(13,14,2)]\n  colnames(datosT)=c(\"Este\",\"Norte\",\"Temperatura\")\n  datosT$Temperatura &lt;- as.numeric(datosT$Temperatura)\n  temp &lt;- as.geodata(datosT)\n  vg &lt;- quiet(\n        variog(temp, trend = ~Norte+Este+I(Este^2)+I(Este^3),\n               estimator.type = \"modulus\", pairs.min=50,\n               max.dist=7e5))\n  \n  est1 &lt;- quiet(\n          variofit(vg, cov.model = \"exponential\", ini=ini1_exp_T,\n                   fix.nugget = F,\n                   wei = \"cressie\"))\n\n  est3 &lt;- quiet(\n          variofit(vg, cov.model = \"spherical\", ini=ini1_es_T,\n                   fix.nugget = F,\n                   wei = \"cressie\"))\n  \n  par1 &lt;- c(est1$nugget, est1$cov.pars[1], est1$cov.pars[2])\n  par3 &lt;- c(est3$nugget, est3$cov.pars[1], est3$cov.pars[2])\n  \n  mse1 &lt;- MSE_sv(vg$v, par1, NA, model = \"exponencial\", vg$u)\n  mse3 &lt;- MSE_sv(vg$v, par3, NA, model = \"spherical\", vg$u)\n  \n  mse_values &lt;- c(exponential = mse1, spherical = mse3)\n  best_model &lt;- names(which.min(mse_values))\n  \n  best_fit &lt;- switch(best_model,\n                     exponential = est1,\n                     gaussian = est2,\n                     spherical = est3)\n  \n  model_gstat &lt;- switch(best_model,\n                        exponential = \"Exp\",\n                        gaussian = \"Gau\",\n                        spherical = \"Sph\")\n  \n  vgm_best &lt;- gstat::vgm(psill = best_fit$cov.pars[1],\n                  model = model_gstat,\n                  range = best_fit$cov.pars[2],\n                  nugget = best_fit$nugget)\n\n  y_T_NA &lt;- Temp[i, ]\n  y_T_NA &lt;- cbind(colnames(y_T_NA), t(y_T_NA[1,]))\n  y_T_NA &lt;- y_T_NA[-1,]\n  y_T_NA &lt;- as.data.frame(y_T_NA)\n  y_T_NA &lt;- y_T_NA[is.na(y_T_NA$V2), ]  # Filtrar las estaciones sin dato\n  y_T_NA$V1 &lt;- as.numeric(y_T_NA$V1)\n  Estaciones &lt;- y_T_NA$V1 \n  y_T_NA &lt;- inner_join(y_T_NA, EstacionesT, by = c(\"V1\" = \"AQSID\"))\n  y_T_NA &lt;- y_T_NA[,c(13,14,2)]\n  colnames(y_T_NA)=c(\"Este\",\"Norte\",\"Temperatura\")\n  \n  if (nrow(y_T_NA)==0) {\n    warning(paste(\"No valores faltantes a estimar\", i))\n    next\n  }\n                       \n  pred_grid &lt;- y_T_NA[, c(\"Este\", \"Norte\")]\n  coordinates(datosT) &lt;- ~Este+Norte\n  coordinates(pred_grid) &lt;- ~Este + Norte\n  \n  krig_result &lt;- quiet(gstat::krige(\n    formula = Temperatura ~ Norte + Este + I(Este^2) + I(Este^3),\n    locations = ~ Norte + Este,\n    data = as.data.frame(datosT),\n    newdata = pred_grid,\n    model = vgm_best,\n    nmin =20\n  ))\n  \n  Temp[i, as.character(Estaciones)] &lt;- t(krig_result@data[[\"var1.pred\"]])\n  \n  setTxtProgressBar(Progress, i)\n}\n\nTemp[,-1] &lt;- lapply(Temp[ , -1], function(x) round(as.numeric(x), 1))\n\n\n3.2.1.1 Análisis de Estacionariedad en Media\nPara mitigar el efecto espacial en la media de la variable se uso el mismo modelo de regresión que se encontro en el Análisis Univariado:\nTemperatura = \\beta_0 + \\beta_1 \\times Norte + \\beta_2 \\times Norte^2\n\n\nVer código\nTemp.st.res &lt;- as.data.frame(Data_ST) %&gt;%\n  group_by(DateTime) %&gt;% \n  mutate(value = resid(lm(value ~ Norte+I(Norte^2)))) %&gt;%\n  ungroup()\n\ndataTemp.ST &lt;- Data_ST%&gt;% \n  arrange(AQSID, DateTime) %&gt;%\n  dplyr::select(value)\n\n\ntime.index &lt;- sort(unique(Data_ST$DateTime))\n\nTemp.stations.sp &lt;- EstacionesT %&gt;% arrange(AQSID)\n\nTemp.stations.sp &lt;- SpatialPoints(Temp.stations.sp[,c(\"Este\", \"Norte\")])\n\n\ndatostime &lt;- STFDF(Temp.stations.sp, time.index, dataTemp.ST)\nstplot(datostime, main = \"Temperatura en las 24 horas de 2024-01-03\")\n\n\n\n\n\n\n\n\n\nVer código\nIDs &lt;- unique(EstacionesT$AQSID)\nsel &lt;- NULL; for(i in 1:20) sel&lt;-c(sel,which(IDs==IDs[i]))\n\nstplot(datostime[sel, \"2024-01-03\", \"value\"], mode=\"xt\", scaleX=0,\n       col.regions=terrain.colors(100), main = \"Temperatura\")\n\n\n\n\n\n\n\n\n\nVer código\nstplot(datostime[sel, \"2024-01-03\", \"value\"], mode=\"ts\",\n       main = \"Temperatura\")\n\n\n\n\n\n\n\n\n\n\n\n3.2.1.2 Estudio del Semivariograma\n\n3.2.1.2.1 Estimación Empírica del Semivariograma\nMediante la función GeoVariogram() del paquete GeoModels se estimó el semivariograma empírico, su versión suavizada y los correspondientes semivariogramas marginales. Los resultados se presentan a continuación.\n\n\nVer código\ngeoMatrix &lt;- Temp.st.res %&gt;% \n  dplyr::select(DateTime, AQSID, value) %&gt;%\n  tidyr::pivot_wider(names_from = AQSID, values_from = value) %&gt;%\n  arrange(DateTime) %&gt;%  \n  dplyr::select(-DateTime) %&gt;%  \n  as.matrix()\n\ngeovgm &lt;- GeoVariogram(data = geoMatrix, \n                       coordx = as.matrix(EstacionesT[,c(\"Este\", \"Norte\")]),\n                       coordt = unique(Data_ST$Hora - min(Data_ST$Hora)),\n                       distance = \"Eucl\", \n                       type= \"variogram\", \n                       maxdist = 8e+05)\n\nplot(geovgm)\n\n\n\n\n\n\n\n\n\n\n\n3.2.1.2.2 Estimación del Modelo Teórico de Semivariograma\nMediante la función GeoFit() de la libreria GeoModels() se llevó a cabo la estimación del modelo teórico para el semivariograma espacio–temporal. Debido a las altas demandas computacionales asociadas al proceso de optimización, se decidió almacenar el resultado final en un archivo .RData. No obstante, en el siguiente bloque se presenta el código empleado para obtener dicha estimación.\n\n#Parámetros iniciales\n\ninit.ST_gne &lt;- list(\n  scale_s = 1e5,\n  power_s = 1,\n  scale_t = 1,\n  power_t = 1,\n  sep     = 0.5,\n  sill    = 9,\n  nugget  = 0.1\n)\n\n#Mínimos de la grilla para la estimación\nlower.ST_gne &lt;- list(\n  scale_s = 0.001,\n  power_s = 0.1,\n  scale_t = 0.001,\n  power_t = 0.1,\n  sep     = 0.01,\n  sill    = 0.001,\n  nugget  = 0\n)\n\n#Máximos de la grilla para la estimación\nupper.ST_gne &lt;- list(\n  scale_s = 3e6,\n  power_s = 2,\n  scale_t = 12,\n  power_t = 2,\n  sep     = 0.99,\n  sill    = 20,\n  nugget  = 1\n)\n\ngeofit_gne &lt;- GeoFit(data = geoMatrix, \n                     coordx = as.matrix(EstacionesT[,c(\"Este\", \"Norte\")]),\n                     coordt = unique(Data_ST$Hora - min(Data_ST$Hora)),\n                     distance = \"Eucl\", \n                     maxdist = 8e+05, \n                     maxtime =7, \n                     model = \"Gaussian\", \n                     corrmodel = \"Gneiting\", \n                     start = init.ST_gne, \n                     optimizer = \"L-BFGS-B\",\n                     fixed = fixed.ST_gne,\n                     lower = lower.ST_gne,\n                     upper = upper.ST_gne)\n\n\n\nVer código\n#Carga del Optim\n\nload(\"geofitST3.RData\")\ngeocgvm&lt;- GeoCovariogram(fitted = geofitST$Gneiting3, \n                         answer.vario = TRUE,\n                         show.vario = TRUE, \n                         add.vario = TRUE,\n                         vario = geovgm, \n                         invisible = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n3.2.1.3 Kriging Espacio Temporal\nPara calcular las predicciones se hizo uso de la función GeoKrig de GeoModels. Debido a las altas demandas computacionales asociadas al proceso de optimización, se decidió almacenar el resultado final en un archivo .xlsx. No obstante, en el siguiente bloque se presenta el código empleado para obtener las predicciones:\n\npr &lt;- GeoKrig(geofitST$Gneiting3, \n              loc = as.matrix(new@coords[,]), \n              time = c(24:29),\n              mse = TRUE)\n\npred &lt;- pr$pred #Exportar los residuos predichos\n\n#Tomar todos los coeficientes de la regresión para cada tiempo\n\ncoefs &lt;- as.data.frame(Data_ST) %&gt;%\n  group_by(DateTime) %&gt;%\n  do({\n    mod &lt;- lm(value ~ Norte + I(Norte^2), data = .)\n    \n    # Residuales + fitted + datos originales\n    aug &lt;- augment(mod)\n    \n    # Coeficientes\n    coef &lt;- tidy(mod) %&gt;%\n      mutate(DateTime = unique(.$DateTime))\n    \n    # Empaquetar: residuales + coeficientes replicados por fila\n    cbind(aug,\n          coef_intercept = coef$estimate[coef$term == \"(Intercept)\"],\n          coef_Norte     = coef$estimate[coef$term == \"Norte\"],\n          coef_Norte2    = coef$estimate[coef$term == \"I(Norte^2)\"])\n  }) %&gt;%\n  ungroup()\n\ncoefs &lt;- coefs %&gt;% distinct(coef_intercept, coef_Norte, coef_Norte2)\n\n#Juntar todo en una misma matriz\n\nmelt_s &lt;- data.frame(\n  t1 = pred[1,],\n  t2 = pred[2,],\n  t3 = pred[3,],\n  t4 = pred[4,],\n  t5 = pred[5,],\n  t6 = pred[6,],\n  X = new@coords[,1], \n  Y = new@coords[,2],\n  coef_intercept = mean(coefs$coef_intercept),\n  coef_Norte     = mean(coefs$coef_Norte),\n  coef_Norte2    = mean(coefs$coef_Norte2)\n)\n\n#Transformar a los valores reales\n\nmelt_s &lt;- melt_s %&gt;% mutate(\n                            t1 = t1 + coef_intercept+\n                              coef_Norte * Y + coef_Norte2*Y^2,\n                            t2 = t2 + coef_intercept+\n                              coef_Norte * Y + coef_Norte2*Y^2,\n                            t3 = t3 + coef_intercept+\n                              coef_Norte * Y + coef_Norte2*Y^2,\n                            t4 = t4 + coef_intercept+\n                              coef_Norte * Y + coef_Norte2*Y^2,\n                            t5 = t5 + coef_intercept+\n                              coef_Norte * Y + coef_Norte2*Y^2,\n                            t6 = t6 + coef_intercept+\n                              coef_Norte * Y + coef_Norte2*Y^2,\n)\n\n#Escribir el archivo\nwrite.csv(melt_s, \"pred_funcional.csv\")\n\n## Para el MSE\nMSE&lt;-pr$mse\n\nMSE_s &lt;- data.frame(\n  MSE1 = MSE[1,],\n  MSE2 = MSE[2,],\n  MSE3 = MSE[3,],\n  MSEt4 = MSE[4,],\n  MSE5 = MSE[5,],\n  MSE6 = MSE[6,],\n  X = new@coords[,1], \n  Y = new@coords[,2]\n)\n\nwrite.csv(MSE_s, \"mse_spac_time.csv\")\n\nEn seguida se presentan predicciones para t=6 tiempos a futuro.\n\n\nVer código\npred &lt;- read.csv(\"pred_funcional.csv\")\npred &lt;- st_as_sf(pred,\n                   coords = c(\"X\", \"Y\"),\n                   crs = CRS_UTM_NY)\nerror &lt;- read.csv(\"mse_spac_time.csv\")\nerror &lt;- st_as_sf(error,\n                   coords = c(\"X\", \"Y\"),\n                   crs = CRS_UTM_NY)\n\n\n\nPrimer MomentoSegundo MomentoTercer MomentoCuarto MomentoQuinto MomentoSexto Momento\n\n\n\nPredicciónError de Predicción\n\n\n\n\nVer código\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = pred, \n    aes(col = t1), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_color_carto_c(palette = 'Prism', na.value = '#111111') +\n  labs(\n    title = \"Tiempo 1\",\n    color = \"Temperatura\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = error, \n    aes(col = MSE1), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_fill_viridis_c(option = \"magma\",\n                       direction = -1) +\n  labs(\n    title = \"Tiempo 1\",\n    color = \"Error de predicción\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPredicciónError de Predicción\n\n\n\n\nVer código\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = pred, \n    aes(col = t2), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_color_carto_c(palette = 'Prism', na.value = '#111111') +\n  labs(\n    title = \"Tiempo 2\",\n    color = \"Temperatura\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = error, \n    aes(col = MSE2), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_fill_viridis_c(option = \"magma\",\n                       direction = -1) +\n  labs(\n    title = \"Tiempo 2\",\n    color = \"Error de predicción\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPredicciónError de Predicción\n\n\n\n\nVer código\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = pred, \n    aes(col = t3), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_color_carto_c(palette = 'Prism', na.value = '#111111') +\n  labs(\n    title = \"Tiempo 3\",\n    color = \"Temperatura\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = error, \n    aes(col = MSE3), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_fill_viridis_c(option = \"magma\",\n                       direction = -1) +\n  labs(\n    title = \"Tiempo 3\",\n    color = \"Error de predicción\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPredicciónError de Predicción\n\n\n\n\nVer código\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = pred, \n    aes(col = t4), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_color_carto_c(palette = 'Prism', na.value = '#111111') +\n  labs(\n    title = \"Tiempo 4\",\n    color = \"Temperatura\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = error, \n    aes(col = MSEt4), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_fill_viridis_c(option = \"magma\",\n                       direction = -1) +\n  labs(\n    title = \"Tiempo 4\",\n    color = \"Error de predicción\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPredicciónError de Predicción\n\n\n\n\nVer código\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = pred, \n    aes(col = t5), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_color_carto_c(palette = 'Prism', na.value = '#111111') +\n  labs(\n    title = \"Tiempo 5\",\n    color = \"Temperatura\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = error, \n    aes(col = MSE5), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_fill_viridis_c(option = \"magma\",\n                       direction = -1) +\n  labs(\n    title = \"Tiempo 5\",\n    color = \"Error de predicción\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPredicciónError de Predicción\n\n\n\n\nVer código\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = pred, \n    aes(col = t6), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_color_carto_c(palette = 'Prism', na.value = '#111111') +\n  labs(\n    title = \"Tiempo 6\",\n    color = \"Temperatura\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = error, \n    aes(col = MSE6), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_fill_viridis_c(option = \"magma\",\n                       direction = -1) +\n  labs(\n    title = \"Tiempo 6\",\n    color = \"Error de predicción\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))",
    "crumbs": [
      "Geoestadística Espacio Temporal",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Análisis Geoestadístico Espacio Temporal</span>"
    ]
  },
  {
    "objectID": "Geo_esp_temp.html#conclusiones",
    "href": "Geo_esp_temp.html#conclusiones",
    "title": "3  Análisis Geoestadístico Espacio Temporal",
    "section": "3.3 Conclusiones",
    "text": "3.3 Conclusiones\n\n\n\n\n\n\nEn desarrollo…",
    "crumbs": [
      "Geoestadística Espacio Temporal",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Análisis Geoestadístico Espacio Temporal</span>"
    ]
  },
  {
    "objectID": "Geo_fun.html",
    "href": "Geo_fun.html",
    "title": "4  Análisis Geoestadístico Funcional",
    "section": "",
    "text": "4.1 Planteamiento del problema",
    "crumbs": [
      "Geoestadística Funcional",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Análisis Geoestadístico Funcional</span>"
    ]
  },
  {
    "objectID": "Geo_fun.html#planteamiento-del-problema",
    "href": "Geo_fun.html#planteamiento-del-problema",
    "title": "4  Análisis Geoestadístico Funcional",
    "section": "",
    "text": "4.1.1 Introducción\nLa calidad del aire es un elemento fundamental para la salud pública, el bienestar de las comunidades y el equilibrio de los ecosistemas. El deterioro de este recurso no solo incrementa el riesgo de enfermedades respiratorias y cardiovasculares, sino que también afecta la productividad, la calidad de vida y el funcionamiento de los sistemas naturales. En los últimos años, la preocupación por la contaminación atmosférica ha crecido debido a la combinación de factores antropogénicos y ambientales que intensifican la presencia de compuestos dañinos en la atmósfera, entre ellos el ozono troposférico y las variaciones extremas de temperatura.\nEn el estado de California, esta problemática adquiere una dimensión particular. Su elevada densidad poblacional, el tránsito vehicular, la actividad industrial y ciertos fenómenos naturales, como los incendios forestales, cada vez más frecuentes, contribuyen a que numerosas ciudades presenten niveles críticos de contaminación. Estas condiciones hacen necesario un análisis más profundo de la dinámica espacial y temporal de los contaminantes atmosféricos. En este contexto, el uso de herramientas estadísticas avanzadas, como el análisis funcional y la predicción espacial, se convierte en un enfoque útil para comprender los patrones subyacentes y apoyar la toma de decisiones en materia ambiental.\n\n\n4.1.2 Descripción de los datos\nLos datos objeto de este estudio provienen de la Agencia de Protección Ambiental (EPA) de los Estados Unidos y corresponden a registros horarios obtenidos de las estaciones de monitoreo durante el mes de marzo de 2024. En particular, se analizan las variables Temperatura ambiente (Temp) y Ozono (O_3).\n\n4.1.2.1 Unidades\n\nTemperatura ambiente: Medida en grados celsius (C°) con una intensidad horaria.\nOzono: Medida en partes por billón (ppb) con una intensidad horaria.\n\n\n\n\n4.1.3 Objetivos\n\n4.1.3.1 Objetivo general\nAnalizar las estructuras temporales y espaciales de las variables ozono y temperatura en California durante marzo de 2024 mediante técnicas de análisis de datos funcionales (FDA), con el fin de construir un modelo de covarianza espacial basado en componentes principales funcionales (FPCA) que permita realizar predicciones espacialmente coherentes de ambas variables.\n\n\n4.1.3.2 Objetivos específicos\n\nConstruir las curvas funcionales de ozono y temperatura mediante un proceso de suavizamiento apropiado, empleando bases de B-splines cúbicas y estimando el parámetro de penalización (\\lambda) por validación cruzada.\nAplicar el análisis de componentes principales funcionales (FPCA) y obtener los scores funcionales, para luego estudiar y modelar la dependencia espacial mediante la construcción del semivariograma empírico y el ajuste de modelos teóricos.\nImplementar Kriging Funcional para generar mapas de predicción espacial y mapas de incertidumbre, utilizando los componentes principales y la estructura espacial estimada, con el fin de representar la distribución esperada de las variables y evaluar la precisión de las estimaciones.",
    "crumbs": [
      "Geoestadística Funcional",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Análisis Geoestadístico Funcional</span>"
    ]
  },
  {
    "objectID": "Geo_fun.html#análisis-geoestadístico-funcional",
    "href": "Geo_fun.html#análisis-geoestadístico-funcional",
    "title": "4  Análisis Geoestadístico Funcional",
    "section": "4.2 Análisis Geoestadístico Funcional",
    "text": "4.2 Análisis Geoestadístico Funcional\n\n4.2.1 Variable Temperatura\nEn el siguiente bloque se muestra el código utilizado para imputar los valores faltantes en las 127 estaciones de California a lo largo de las 744 observaciones temporales. A partir de los modelos ajustados en el Análisis Univariado, se estimó un semivariograma para cada instante en el tiempo, seleccionando el modelo adecuado según el criterio de MSE. Finalmente, la predicción espacial se llevó a cabo mediante la función krige() del paquete gstat.\n\nkrig_list &lt;- list()\n\nProgress &lt;- txtProgressBar(min = 0, max = nrow(Temp), style = 3)\n\nfor (i in 1:nrow(Temp)){\n  \n  y_T &lt;- Temp[i,] #Tomar una fecha\n  y_T &lt;- cbind(colnames(y_T),t(y_T[1,]))\n  y_T &lt;- y_T[-1,]\n  y_T &lt;- as.data.frame(y_T)\n  y_T &lt;- na.omit(y_T)\n  y_T$V1 &lt;- as.numeric(y_T$V1)\n  y_T &lt;- inner_join(y_T, EstacionesT, by=c(\"V1\"=\"AQSID\"))\n  datosT &lt;- y_T[,c(13,14,2)]\n  colnames(datosT)=c(\"Este\",\"Norte\",\"Temperatura\")\n  datosT$Temperatura &lt;- as.numeric(datosT$Temperatura)\n  temp &lt;- as.geodata(datosT)\n  vg &lt;- quiet(\n        variog(temp, trend = ~Norte+Este+I(Este^2)+I(Este^3),\n               estimator.type = \"modulus\", pairs.min=50,\n               max.dist=7e5))\n  \n  est1 &lt;- quiet(\n          variofit(vg, cov.model = \"exponential\", ini=ini1_exp_T,\n                   fix.nugget = F,\n                   wei = \"cressie\"))\n\n  est3 &lt;- quiet(\n          variofit(vg, cov.model = \"spherical\", ini=ini1_es_T,\n                   fix.nugget = F,\n                   wei = \"cressie\"))\n  \n  par1 &lt;- c(est1$nugget, est1$cov.pars[1], est1$cov.pars[2])\n  par3 &lt;- c(est3$nugget, est3$cov.pars[1], est3$cov.pars[2])\n  \n  mse1 &lt;- MSE_sv(vg$v, par1, NA, model = \"exponencial\", vg$u)\n  mse3 &lt;- MSE_sv(vg$v, par3, NA, model = \"spherical\", vg$u)\n  \n  mse_values &lt;- c(exponential = mse1, spherical = mse3)\n  best_model &lt;- names(which.min(mse_values))\n  \n  best_fit &lt;- switch(best_model,\n                     exponential = est1,\n                     gaussian = est2,\n                     spherical = est3)\n  \n  model_gstat &lt;- switch(best_model,\n                        exponential = \"Exp\",\n                        gaussian = \"Gau\",\n                        spherical = \"Sph\")\n  \n  vgm_best &lt;- gstat::vgm(psill = best_fit$cov.pars[1],\n                  model = model_gstat,\n                  range = best_fit$cov.pars[2],\n                  nugget = best_fit$nugget)\n\n  y_T_NA &lt;- Temp[i, ]\n  y_T_NA &lt;- cbind(colnames(y_T_NA), t(y_T_NA[1,]))\n  y_T_NA &lt;- y_T_NA[-1,]\n  y_T_NA &lt;- as.data.frame(y_T_NA)\n  y_T_NA &lt;- y_T_NA[is.na(y_T_NA$V2), ]  # Filtrar las estaciones sin dato\n  y_T_NA$V1 &lt;- as.numeric(y_T_NA$V1)\n  Estaciones &lt;- y_T_NA$V1 \n  y_T_NA &lt;- inner_join(y_T_NA, EstacionesT, by = c(\"V1\" = \"AQSID\"))\n  y_T_NA &lt;- y_T_NA[,c(13,14,2)]\n  colnames(y_T_NA)=c(\"Este\",\"Norte\",\"Temperatura\")\n  \n  if (nrow(y_T_NA)==0) {\n    warning(paste(\"No valores faltantes a estimar\", i))\n    next\n  }\n                       \n  pred_grid &lt;- y_T_NA[, c(\"Este\", \"Norte\")]\n  coordinates(datosT) &lt;- ~Este+Norte\n  coordinates(pred_grid) &lt;- ~Este + Norte\n  \n  krig_result &lt;- quiet(gstat::krige(\n    formula = Temperatura ~ Norte + Este + I(Este^2) + I(Este^3),\n    locations = ~ Norte + Este,\n    data = as.data.frame(datosT),\n    newdata = pred_grid,\n    model = vgm_best,\n    nmin =20\n  ))\n  \n  Temp[i, as.character(Estaciones)] &lt;- t(krig_result@data[[\"var1.pred\"]])\n  \n  setTxtProgressBar(Progress, i)\n}\n\nTemp[,-1] &lt;- lapply(Temp[ , -1], function(x) round(as.numeric(x), 1))\n\nEn el siguiente gráfico se presentan las series de tiempo de los valores observados de manera horaria para 127 estaciones en el mes de marzo de 2024.\n\n\nVer código\n#Librerias necesarias ------------------------------------\n\nset.seed(123)\n\nlibrary(dplyr)\nlibrary(geoR)\nlibrary(sp)\nlibrary(readxl)\nlibrary(tidyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(raster)\nlibrary(stars)\nlibrary(fda)\nlibrary(fda.usc)\nlibrary(terra)\nlibrary(SpatFD)\nlibrary(gstat)\nlibrary(rcartocolor)\n\n#Gráficos de dispersión ----------------------------------\n\nsimple_scatter_plot &lt;- function(datos, variable1, variable2) {\n\n    plot1 &lt;- ggplot(as.data.frame(datos),\n                    aes(x = .data[[variable1]], y = .data[[variable2]],\n                               color = as.factor(1))) +\n                    geom_point() +\n                    scale_colour_viridis_d() +\n                    labs(\n                        x = variable1,\n                        y = variable2\n                        ) +\n                    theme_light() +\n                    theme(legend.position = \"none\")\n\n    return(plot1)\n\n}\n\n#-----------------------------------------------------------\n\nTemp &lt;- read_excel(\"Temp_imp.xlsx\", sheet = \"Temperatura\")\nTemp &lt;- as.data.frame(Temp)\nEstacionesT &lt;- read_excel(\"Temp_imp.xlsx\", sheet = \"Estaciones\")\nEstacionesT &lt;- EstacionesT[,c(1,12,13)]\n\n#Para el mapa de California -------------------------------\n\nsh_mundos&lt;-st_read(\"admin00.shp\",quiet=TRUE)\nsh_mundos &lt;- sh_mundos %&gt;% filter(CNTRY_NAME==\"United States\")\nsh_mundos &lt;- sh_mundos %&gt;% filter(ADMIN_NAME==\"California\")\n\nCRS_UTM_NY = \"+init=epsg:3310\"\n\nsh_mundos_wgs84 &lt;- st_transform(sh_mundos, crs = 4326)\n\nsh_mundos_utm &lt;- st_transform(sh_mundos, crs = CRS(\"EPSG:3310\"))\n\nsh_mundos_sp_utm &lt;- as(sh_mundos_utm, \"Spatial\")\n\nsh_mundos_utm_simple &lt;- st_union(sh_mundos_utm)\nsh_mundos_sp_utm_simple &lt;- as(sh_mundos_utm_simple, \"Spatial\")\n\n#Grilla para hacer kriging ------------------------------\n\nnew &lt;- sp::spsample(as(sh_mundos_utm, \"Spatial\"), n = 10000, type = \"regular\")\n\nproj4string(new) &lt;- CRS(\"EPSG:3310\")\ninvisible(coordinates(new) ~ Este + Norte)\ncolnames(new@coords) &lt;- c(\"Este\", \"Norte\")\n\nTemp$DateTime &lt;- as.POSIXct(Temp$DateTime,\n                            format = \"%m/%d/%y %H:%M:%S\",\n                            tz = \"America/Bogota\")\n\ncols &lt;- rainbow(ncol(Temp)-1)\n\nggplot() +\n  lapply(2:ncol(Temp), function(i) {\n    geom_line(aes(x = Temp$DateTime, y = Temp[[i]]), \n              color = cols[i-1],\n              alpha = 0.8)\n  }) +\n  labs(x = \"Fecha\", y = \"Temperatura\")+\n  theme_light()\n\n\n\n\n\n\n\n\n\n\n4.2.1.1 Modelamiento con B-Splines\nPara aplicar la metodología funcional es necesario suavizar previamente los datos. Para ello, se una base de B-Splines conformada por k=64 funciones. Luego de esto, se determinó el valor óptimo del parámetro de penalización \\lambda mediante validación cruzada.\nEn el siguiente gráfico se muestra el comportamiento del GCV a lo largo del rango de valores evaluados para del parámetro de penalización, junto con un resumen tabular de los resultados obtenidos.\n\n\nVer código\ntemp &lt;- as.matrix(Temp[,-1])\n\nk &lt;- round(ncol(temp)/2)\n\nBSpl &lt;- create.bspline.basis(rangeval=c(0,744),\n                                    nbasis=k, norder=4)\nloglam = seq(17.25,18.25,0.01)\nnlam = length(loglam)\ndfsave = rep(NA,nlam)\ngcvsave = rep(NA,nlam)\nfor (ilam in 1:nlam) {\nlambda = loglam[ilam]\nfdParobj = fdPar(BSpl, Lfdobj=NULL, lambda= lambda)\nsmoothlist = smooth.basis(1:nrow(temp), temp, fdParobj)\ndfsave[ilam] = smoothlist$df\ngcvsave[ilam] = sum(smoothlist$gcv)\n}\n\nggplot(data.frame(\n                  loglam = loglam,\n                  gcv = gcvsave\n                  ),\n    aes(x = loglam, y = gcv)) +\n    geom_point(size = .8) +\n    geom_line() +\n    labs(\n        x = expression(lambda),\n        y = expression(GCV(lambda)),\n        title = \"Parámetros de suavizamiento versus GCV\"\n    ) +\n    theme_light()+theme(\n        plot.title = element_text(hjust = 0.5,\n                                  face = \"bold\")\n    )\n\n\n\n\n\n\n\n\n\nVer código\nbest.idx     &lt;- which.min(gcvsave)\nbest.lambda  &lt;- loglam[best.idx]\n\nknitr::kable(data.frame(lambda = best.lambda,\n                         GCV=round(min(gcvsave), 3)),\n             escape = F,\n             col.names = c(\"$$\\\\lambda$$\", \"$$GCV$$\"),\n             align='c')\n\n\n\n\n\n\\lambda\nGCV\n\n\n\n\n17.82\n1307.184\n\n\n\n\n\nCon los valores estimados de k y \\lambda se procede a realizar el suavizamiento mediante B-Splines. En la siguiente figura se muestran las curvas suavizadas obtenidas a partir de esta base.\n\n\nVer código\nFtemp &lt;- Data2fd(y=temp, basisobj=BSpl, lambda = best.lambda)\n\ninicio &lt;- as.POSIXct(\"2024-03-01 00:00:00\", tz = \"America/Bogota\")\ninicio &lt;- inicio + (0:743)*3600\n\nt_eval &lt;- seq(0, 744, length.out = 744)\n\neval_Ftemp &lt;- eval.fd(t_eval, Ftemp)\neval_Ftemp &lt;- as.data.frame(eval_Ftemp)\neval_Ftemp$t &lt;- inicio\neval_Ftemp$t1 &lt;- t_eval\n\neval_Ftemp &lt;- pivot_longer(\n  eval_Ftemp,\n  cols = c(-t,-t1),\n  names_to = \"Estacion\",\n  values_to = \"Temperatura\"\n)\n\nggplot(eval_Ftemp, aes(x = t, y = Temperatura, group = Estacion, col=Estacion)) +\n  geom_line(linewidth = 0.7) + \n  labs(\n    title = \"Datos suavizados de la Temperatura\",\n    x = \"Hora-Día\",\n    y = \"Temperatura C°\"\n  ) +\n  theme_light() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"),  \n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\n\n\nLos resultados muestran que el suavizamiento logra reproducir de forma consistente la tendencia y la variabilidad general de las series de tiempo originales. Por lo tanto, se concluye que los valores de k y \\lambda proporcionan un balance apropiado entre fidelidad y suavidad.\n\n4.2.1.1.1 Estadística descriptiva\nAdicionalmente, con el propósito de caracterizar las tendencias capturadas por el ajuste, se presenta un resumen descriptivo del proceso de suavizamiento.\n\n\nVer código\nmeanfdh &lt;- mean.fd(Ftemp)\nvarfdh &lt;-var.fd(Ftemp)\nstdvfdh &lt;- stddev.fd(Ftemp)\n\n\n\nMediaVarianzaSD\n\n\n\n\nVer código\nggplot(eval_Ftemp, aes(x = t, y = Temperatura, group = Estacion, col=Estacion)) +\n  geom_line(linewidth = 0.7, show.legend = F) + \n  geom_line(data = data.frame(t = eval_Ftemp$t,\n                              Media =  eval.fd(eval_Ftemp$t1, meanfdh)),\n            aes(x = t, y = mean,, group = 1),\n            linewidth = 1.2, col=\"red\",\n            inherit.aes = FALSE )+\n  labs(\n    title = \"Media de los suavizados de la Temperatura\",\n    x = \"Hora-Día\",\n    y = \"Temperatura C°\"\n  ) +\n  theme_light() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"),  \n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(varfdh, main=\" Superficie de varianza\", xlab = \"t\", ylab = \"s\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\ndata.frame(\n  t = eval_Ftemp$t,\n  std = as.vector(eval.fd(eval_Ftemp$t1, stdvfdh))\n) %&gt;% \n  ggplot(aes(x = t, y = std)) +\n  geom_line(color = \"steelblue\", linewidth = 1) +\n  labs(\n    title = \"Desviación estándar\",\n    x = \"Hora-Día\",\n    y = \"Temperatura °C\"\n  ) +\n  theme_light() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.2.1.2 Componentes Principales\nSe lleva a cabo un análisis de componentes funcional (ACPF) con el propóstio de reducir la dimensión de las funciones. Para ello, se emplea la función pca.fd() del paquete fda.\nSe seleccionaron las 10 primeras funciones propias como base para el análisis. A continuación, se presenta de forma gráfica el porcentaje de varianza acumulada explicado por cada componente.\n\n\nVer código\nPCA = pca.fd(Ftemp, 10)\n\ndata.frame(\n  Dim = 1:10,\n  Perc = round(PCA$varprop*100,2)\n) %&gt;% \n  ggplot(aes(x = Dim, y = Perc)) +\n  geom_col(fill = \"#7EC0EE\", width = 0.7, alpha = 0.8) +\n  geom_line(aes(y = Perc), linewidth = 0.8) +\n  geom_point(size = 1.5) +\n  geom_text(aes(label = paste0(round(Perc,1), \"%\")),\n            vjust = -0.5, size = 3) +\n  scale_x_continuous(breaks = 1:10) +\n  labs(\n    title = \"Valores propios del FPCA\",\n    x = \"Dimensiones\",\n    y = \"Porcentaje de varianza explicada\"\n  ) +\n  theme_light() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\nDebido a que los tres primeros componentes principales concentran más del 90 % de la variabilidad total de las funciones, se opta por utilizar únicamente estos componentes en el análisis geoestadístico.\n\n\nVer código\ncoordsT &lt;- EstacionesT[,c(2,3)]\nPC1T &lt;- cbind(Scores=PCA$scores[,1], coordsT)\nPC2T &lt;- cbind(Scores=PCA$scores[,2], coordsT)\nPC3T &lt;- cbind(Scores=PCA$scores[,3], coordsT)\n\n\nPara avanzar con el análisis geoestadístico, se examina primero el comportamiento de la media con el fin de determinar si existe algún efecto espacial que deba corregirse mediante un modelo de regresión adecuado. A continuación, se presentan las matrices de correlación y los gráficos de dispersión para los Scores y las coordenadas, cuyo propósito es identificar patrones que sugieran la presencia de una tendencia espacial en la media.\n\nPrimer ComponenteSegundo ComponenteTercer Componente\n\n\n\nMatrizGráficos de dispersión\n\n\n\n\nVer código\npander::pander(cor(PC1T))\n\n\n\n\n\n\n\n\n\n\n\n \nScores\nEste\nNorte\n\n\n\n\nScores\n1\n0.2639\n-0.1515\n\n\nEste\n0.2639\n1\n-0.7656\n\n\nNorte\n-0.1515\n-0.7656\n1\n\n\n\n\n\n\n\n\n\nVer código\npO1 &lt;- simple_scatter_plot(PC1T, \"Este\", \"Scores\")\npO2 &lt;- simple_scatter_plot(PC1T, \"Norte\", \"Scores\")\n\ncowplot::plot_grid(pO1,pO2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMatrizGráficos de dispersión\n\n\n\n\nVer código\npander::pander(cor(PC2T))\n\n\n\n\n\n\n\n\n\n\n\n \nScores\nEste\nNorte\n\n\n\n\nScores\n1\n-0.2497\n0.06783\n\n\nEste\n-0.2497\n1\n-0.7656\n\n\nNorte\n0.06783\n-0.7656\n1\n\n\n\n\n\n\n\n\n\nVer código\npO1 &lt;- simple_scatter_plot(PC2T, \"Este\", \"Scores\")\npO2 &lt;- simple_scatter_plot(PC2T, \"Norte\", \"Scores\")\n\ncowplot::plot_grid(pO1,pO2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMatrizGráficos de dispersión\n\n\n\n\nVer código\npander::pander(cor(PC3T))\n\n\n\n\n\n\n\n\n\n\n\n \nScores\nEste\nNorte\n\n\n\n\nScores\n1\n-0.02491\n0.1259\n\n\nEste\n-0.02491\n1\n-0.7656\n\n\nNorte\n0.1259\n-0.7656\n1\n\n\n\n\n\n\n\n\n\nVer código\npO1 &lt;- simple_scatter_plot(PC3T, \"Este\", \"Scores\")\npO2 &lt;- simple_scatter_plot(PC3T, \"Norte\", \"Scores\")\n\ncowplot::plot_grid(pO1,pO2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComo se observa, los scores presentan media cero y no se identifica un patrón evidente entre ellos y las coordenadas Este y Norte. En consecuencia, se procede a modelar el semivariograma.\n\n\n4.2.1.3 Estructura de Covarianza Espacial\n\n4.2.1.3.1 Modelos Individuales\nEn segunda instancia, se analiza la variabilidad de la variable incrementos, derivada de los Scores, mediante las función variogram() y fit.variogram(), con el propósito de caracterizar su estructura espacial y ajustar el modelo de semivariograma correspondiente.\n\n\nVer código\npuntaje=PCA$scores[,c(1:3)]\ncolnames(puntaje)=c(\"f1\",\"f2\",\"f3\")\nrownames(puntaje) = EstacionesT$AQSID\npuntajes=as.data.frame(puntaje)\ncoordinates(puntajes)=coordsT\n\nvg_PC1_T &lt;-  variogram(f1~1,puntajes, cressie=T)\nvg_PC2_T &lt;-  variogram(f2~1,puntajes, cressie=T)\nvg_PC3_T &lt;-  variogram(f3~1,puntajes, cressie=T)\n\nvgcross &lt;- gstat(NULL, id = \"f1\", form = f1 ~ 1, data = puntajes)\nvgcross &lt;- gstat(vgcross, id = \"f2\", form = f2 ~ 1, data = puntajes)\nvgcross &lt;- gstat(vgcross, id = \"f3\", form = f3 ~ 1, data = puntajes)\n\nvgm.cross &lt;- variogram(vgcross,, cressie=T)\n\n\n\nPrimer ComponenteSegundo ComponenteTercer Componente\n\n\n\n\nVer código\nexp_pc1T &lt;- fit.variogram(vg_PC1_T, vgm(\"Exp\"),\n                          fit.method = 2)\nplot(vg_PC1_T, model = exp_pc1T)\n\n\n\n\n\n\n\n\n\nVer código\npander::pander(exp_pc1T)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nNug\n0\n0\n0\n0\n0\n0\n1\n1\n\n\nExp\n5615\n18273\n0.5\n0\n0\n0\n1\n1\n\n\n\n\n\n\n\n\n\nVer código\nexp_pc2T &lt;- fit.variogram(vg_PC2_T, vgm(\"Wav\"),\n                          fit.method = 7)\nplot(vg_PC2_T, model = exp_pc2T)\n\n\n\n\n\n\n\n\n\nVer código\npander::pander(exp_pc2T)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nNug\n442.3\n0\n0\n0\n0\n0\n1\n1\n\n\nWav\n109.6\n120168\n0.5\n0\n0\n0\n1\n1\n\n\n\n\n\n\n\n\n\nVer código\nexp_pc3T &lt;- fit.variogram(vg_PC3_T, vgm(\"Exp\"),\n                          fit.method = 7)\nplot(vg_PC3_T, model = exp_pc3T)\n\n\n\n\n\n\n\n\n\nVer código\npander::pander(exp_pc3T)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nNug\n155.4\n0\n0\n0\n0\n0\n1\n1\n\n\nExp\n223.5\n67327\n0.5\n0\n0\n0\n1\n1\n\n\n\n\n\n\n\n\nSe observa un buen ajuste para la primera función propia mediante un modelo Exponencial, incluso con un efecto pepita nulo. ncluso sin requerir un efecto pepita. En contraste, para la segunda función propia se identifica un nugget elevado; aun así, el modelo Wave logra representar adecuadamente su comportamiento oscilatorio. En el caso de la tercera función propia, aunque también presenta un nugget considerable, el modelo Exponencial captura de manera satisfactoria la estructura del semivariograma.\nA partir de estos resultados, se infiere que las estructuras de dependencia son compatibles principalmente con modelos Exponenciales o Wave, por lo que estos resultan los candidatos más adecuados para construir el modelo lineal de corregionalización.\n\n\n4.2.1.3.2 Modelo Lineal de Corregionalización\nEl variograma cruzado se presenta en seguida:\n\n\nVer código\nplot(vgm.cross)\n\n\n\n\n\n\n\n\n\nSe opta por un modelo Wave para realizar el ajuste mediante la función fit.lmc() de gstat:\n\n\nVer código\nvgcross &lt;- gstat(vgcross, id = \"f1\", model = exp_pc2T,\n                 fill.all = T)\n\ng &lt;- fit.lmc(vgm.cross, vgcross, fit.method=6, correct.diagonal=1.01)\n\nplot(vgm.cross, model = g$model)\n\n\n\n\n\n\n\n\n\nEl resumen de los modelos ajustados para el modelo lineal de corregionalización se presenta de forma tabular a continuación:\n\n\nVer código\npander::pander(g$model)\n\n\n\nf1:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nNug\n4378\n0\n0\n0\n0\n0\n1\n1\n\n\nWav\n1314\n120168\n0.5\n0\n0\n0\n1\n1\n\n\n\nf1.f2:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nNug\n1.258\n0\n0\n0\n0\n0\n1\n1\n\n\nWav\n-26.27\n120168\n0.5\n0\n0\n0\n1\n1\n\n\n\nf1.f3:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nNug\n25.81\n0\n0\n0\n0\n0\n1\n1\n\n\nWav\n71.34\n120168\n0.5\n0\n0\n0\n1\n1\n\n\n\nf2:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nNug\n496.1\n0\n0\n0\n0\n0\n1\n1\n\n\nWav\n83.63\n120168\n0.5\n0\n0\n0\n1\n1\n\n\n\nf2.f3:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nNug\n22.78\n0\n0\n0\n0\n0\n1\n1\n\n\nWav\n-56.9\n120168\n0.5\n0\n0\n0\n1\n1\n\n\n\nf3:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nNug\n244.6\n0\n0\n0\n0\n0\n1\n1\n\n\nWav\n123.2\n120168\n0.5\n0\n0\n0\n1\n1\n\n\n\nf3.NA:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nNug\n442.3\n0\n0\n0\n0\n0\n1\n1\n\n\nWav\n109.6\n120168\n0.5\n0\n0\n0\n1\n1\n\n\n\nf3.f3:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel\npsill\nrange\nkappa\nang1\nang2\nang3\nanis1\nanis2\n\n\n\n\nNug\n442.3\n0\n0\n0\n0\n0\n1\n1\n\n\nWav\n109.6\n120168\n0.5\n0\n0\n0\n1\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\nEn desarrollo…\n\n\n\n\n\n\n\n\n\n4.2.1.4 Kriging Funcional\nEn esta sección se presentan los resultados del Kriging Funcional aplicando los distintos métodos estudiados en clase.\n\n4.2.1.4.1 Método de Scores\nA partir de los modelos teóricos ajustados para los semivariogramas de cada función propia, se construyen las predicciones en los puntos no observados. La grilla de ubicaciones se genera mediante la función spsample() del paquete sp, mientras que las predicciones se obtienen utilizando la función krige() de gstat. De manera similar a como se hizo en el Análisis Univariado, se especificíco el parámetro nmin=20 con el fin de mitigar el efecto de las largas distancias que se presentan en el estado de California.\nLos resultados se presentan en la figura siguiente, donde se aprecia que las predicciones obtenidas reproducen adecuadamente el patrón general capturado por el suavizamiento funcional.\n\n\nVer código\nproj4string(puntajes) &lt;- CRS(\"EPSG:3310\")\n\ng_CP1&lt;-gstat(id = \"f1\", form = f1 ~ 1,\n             data = puntajes, model = exp_pc1T)\ng_CP2&lt;-gstat(id = \"f2\", form = f2 ~ 1,\n             data = puntajes, model = exp_pc2T)\ng_CP3&lt;-gstat(id = \"f3\", form = f3 ~ 1,\n             data = puntajes, model = exp_pc3T)\n\n#Kriging ------------------------------------------------\n\ninvisible(predic_CP1 &lt;- predict(g_CP1, newdata = new, nmin = 20))\ninvisible(predic_CP2 &lt;- predict(g_CP2, newdata = new, nmin = 20))\ninvisible(predic_CP3 &lt;- predict(g_CP3, newdata = new, nmin = 20))\n\npred_pca &lt;- cbind(\n  predic_CP1@data[\"f1.pred\"], \n  predic_CP2@data[\"f2.pred\"], \n  predic_CP3@data[\"f3.pred\"]\n)\n\nnames(pred_pca) &lt;- c(\"PC1.pred\", \"PC2.pred\", \"PC3.pred\")\n\nV_matrix &lt;- PCA$harmonics$coefs[,c(1:3)]\n\ncoef_predichos_variacion &lt;- as.matrix(V_matrix) %*% t(pred_pca) \n\nmean_coefs &lt;- PCA$meanfd$coefs\nmean_coefs &lt;- as.vector(mean_coefs)\n\ncoef_predichos_totales &lt;- sweep(x = coef_predichos_variacion, # Matriz de variación (k x N_new)\n                                MARGIN = 1,                     # Sumar por FILAS (cada fila es un coeficiente de base)\n                                STATS = mean_coefs,             # Vector de la media (k x 1)\n                                FUN = \"+\")\n\nfd_temp_pred &lt;- fd(coef = coef_predichos_totales, basisobj = PCA$harmonics$basis)\ntemp_pred_eval &lt;- eval.fd(1:744, fd_temp_pred)\n\ntemp_pred &lt;- as.data.frame(temp_pred_eval)\ntemp_pred$t &lt;- inicio\n\npred_Ftemp &lt;- pivot_longer(\n  temp_pred,\n  cols = -t,\n  names_to = \"Estacion\",\n  values_to = \"Temperatura\"\n)\n\nggplot(pred_Ftemp, aes(x = t, y = Temperatura, group = Estacion, col=Estacion)) +\n  geom_line(linewidth = 0.7) + \n  labs(\n    title = \"Estimaciones por Kriging Funcional \\n para marzo de 2024\",\n    x = \"Hora-Día\",\n    y = \"Temperatura C°\"\n  ) +\n  theme_light() +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"),  \n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\n\n\n\n4.2.1.4.1.1 Mapas de predicción\nSe escogieron cuatro momentos en el tiempo correspondientes (1, 7, 14 y 28 de marzo) a 4 días diferentes para la misma hora (12:00 m).\n\nPrimer momentoSegundo momentoTercer momentoCuarto momento\n\n\n\n\nVer código\nmelt_s &lt;- data.frame(Value = pred_Ftemp[pred_Ftemp$t==\"2024-03-01 12:00:00\",3], \n                     X = new@coords[,1], Y = new@coords[,2])\n\nmelt_s &lt;- st_as_sf(melt_s,\n                coords = c(\"X\", \"Y\"),\n                crs = CRS_UTM_NY)\n\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = melt_s, \n    aes(col = Temperatura), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_color_carto_c(palette = 'Prism', na.value = '#111111') +\n  labs(\n    title = \"1 de marzo de 2024 - 12:00:00\",\n    color = \"Temperatura\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nmelt_s &lt;- data.frame(Value = pred_Ftemp[pred_Ftemp$t==\"2024-03-07 12:00:00\",3], \n                     X = new@coords[,1], Y = new@coords[,2])\n\nmelt_s &lt;- st_as_sf(melt_s,\n                coords = c(\"X\", \"Y\"),\n                crs = CRS_UTM_NY)\n\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = melt_s, \n    aes(col = Temperatura), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_color_carto_c(palette = 'Prism', na.value = '#111111') +\n  labs(\n    title = \"7 de marzo de 2024 - 12:00:00\",\n    color = \"Temperatura\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nmelt_s &lt;- data.frame(Value = pred_Ftemp[pred_Ftemp$t==\"2024-03-14 12:00:00\",3], \n                     X = new@coords[,1], Y = new@coords[,2])\n\nmelt_s &lt;- st_as_sf(melt_s,\n                coords = c(\"X\", \"Y\"),\n                crs = CRS_UTM_NY)\n\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = melt_s, \n    aes(col = Temperatura), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_color_carto_c(palette = 'Prism', na.value = '#111111') +\n  labs(\n    title = \"14 de marzo de 2024 - 12:00:00\",\n    color = \"Temperatura\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nmelt_s &lt;- data.frame(Value = pred_Ftemp[pred_Ftemp$t==\"2024-03-28 12:00:00\",3], \n                     X = new@coords[,1], Y = new@coords[,2])\n\nmelt_s &lt;- st_as_sf(melt_s,\n                coords = c(\"X\", \"Y\"),\n                crs = CRS_UTM_NY)\n\nggplot() +\n  geom_sf(data = sh_mundos, fill = \"gray90\", color = \"gray30\", linewidth = 0.5) +\n  geom_sf(\n    data = melt_s, \n    aes(col = Temperatura), \n    size = 3,          \n    alpha = 0.8 \n  ) +\n  scale_color_carto_c(palette = 'Prism', na.value = '#111111') +\n  labs(\n    title = \"28 de marzo de 2024 - 12:00:00\",\n    color = \"Temperatura\"\n  ) +\n  theme_light()+\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\n\nEl Kriging Funcional muestra un patrón espacial de temperatura notablemente estable en California durante el mes de marzo. Las zonas más cálidas se concentran de forma consistente en el Valle Central y en las regiones interiores del sur, mientras que la franja costera y el norte del estado mantienen valores más templados. Las áreas con temperaturas relativamente más bajas parecen estar asociadas a efectos locales de altitud o microclimas, reflejando la influencia directa de la geografía en la distribución térmica al mediodía.\nLa similitud entre los mapas correspondientes a los días 1, 7, 14 y 28 de marzo constituye uno de los hallazgos principales del análisis. La persistencia de este patrón sugiere que no se presentaron eventos meteorológicos relevantes que modificaran de manera sustancial la estructura espacial de la temperatura durante el mes. En consecuencia, el modelo evidencia una alta estabilidad temporal en la distribución geográfica del calor a lo largo de marzo.\n\n\n\n4.2.1.4.2 Método de los Lambdas\n\n\n\n\n\n\nEn desarrollo…",
    "crumbs": [
      "Geoestadística Funcional",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Análisis Geoestadístico Funcional</span>"
    ]
  },
  {
    "objectID": "Geo_fun.html#conclusiones",
    "href": "Geo_fun.html#conclusiones",
    "title": "4  Análisis Geoestadístico Funcional",
    "section": "4.3 Conclusiones",
    "text": "4.3 Conclusiones\n\n\n\n\n\n\nEn desarrollo…",
    "crumbs": [
      "Geoestadística Funcional",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Análisis Geoestadístico Funcional</span>"
    ]
  }
]