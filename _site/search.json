[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Análisis geoespacial de California durante marzo de 2024",
    "section": "",
    "text": "1 Acerca de\nEste proyecto fue realizado para la materia de Estadística Espacial.",
    "crumbs": [
      "Acerca de"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Geo_uni.html",
    "href": "Geo_uni.html",
    "title": "Análisis geoestadístico del ozono y la temperatura en California durante marzo de 2024",
    "section": "",
    "text": "La calidad del aire es un factor clave para la salud pública, el bienestar social y la sostenibilidad ambiental, y California se destaca como uno de los estados más afectados de Estados Unidos por la contaminación atmosférica. La combinación de una alta densidad poblacional, una intensa actividad industrial y vehicular, junto con fenómenos naturales como los incendios forestales, ha hecho que varias de sus ciudades se ubiquen entre las más contaminadas del país. Al mismo tiempo, la temperatura cumple un papel fundamental en la dinámica atmosférica, ya que influye en la dispersión, concentración y formación de contaminantes, además de constituir en sí misma un aspecto crítico para comprender las condiciones ambientales regionales. Frente a este contexto, resulta necesario llevar a cabo un análisis geoespacial que considere tanto la calidad del aire como la temperatura en California, con el fin de identificar patrones espaciales, contrastes regionales y áreas críticas que permitan orientar acciones de mitigación y gestión ambiental.",
    "crumbs": [
      "Análisis Geoestadístico",
      "Análisis Univariado"
    ]
  },
  {
    "objectID": "Geo_uni.html#unidades",
    "href": "Geo_uni.html#unidades",
    "title": "Análisis geoestadístico del ozono y la temperatura en California durante marzo de 2024",
    "section": "2.1 Unidades",
    "text": "2.1 Unidades\n\nTemperatura: Medido en grados celsius (C°) con una intensidad horaria.\nOzono: Medido en partes por billón (ppb) con una intensidad horaria.\n\n\n\nVer código\n#Librerias necesarias\nlibrary(dplyr)\nlibrary(geoR)\nlibrary(sp)\nlibrary(readxl)\nlibrary(tidyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(plotly)\nlibrary(leaflet)\nlibrary(raster)\nlibrary(stars)\n\n#Carga de datos\nCali_Marz &lt;- read.csv(\"AirNow_Marzo_California.csv\", colClasses = c(\"AQSID\"=\"character\"))\n\nOzone &lt;- Cali_Marz %&gt;% filter(Variable==\"OZONE\") \nNO2 &lt;- Cali_Marz %&gt;% filter(Variable==\"NO2\")\nTemp &lt;- read.csv(\"Temperatura.csv\", colClasses = c(\"AQSID\"=\"character\"))\n\nOzone &lt;- Ozone %&gt;% mutate(DateTime = paste(Date, Hour, sep = \" \"))\nNO2 &lt;- NO2 %&gt;% mutate(DateTime = paste(Date, Hour, sep = \" \"))\nTemp &lt;- Temp[,-1]\n\n#Para el mapa de California\nsh_mundos&lt;-st_read(\"admin00.shp\",quiet=TRUE)\nsh_mundos &lt;- sh_mundos %&gt;% filter(CNTRY_NAME==\"United States\")\nsh_mundos &lt;- sh_mundos %&gt;% filter(ADMIN_NAME==\"California\")\n\n#Datos de las estaciones\ndata &lt;- read.csv(\"HourlyAQObs_2024010101.dat\")\ndata &lt;- data %&gt;% filter(CountryCode==\"US\")\ndata &lt;- data %&gt;% filter(StateName==\"CA\")\n\nCRS_UTM_NY = \"+init=epsg:3310\"\n\nOzone_Matrix &lt;- Ozone %&gt;%\n  dplyr::select(DateTime, AQSID, Value) %&gt;%\n  pivot_wider(names_from = AQSID, values_from = Value) \n\nTemp_Matrix &lt;- Temp %&gt;%\n  dplyr::select(DateTime, AQSID, Value) %&gt;%\n  pivot_wider(names_from = AQSID, values_from = Value) \n\n#Para el mapa\n\nsh_mundos_wgs84 &lt;- st_transform(sh_mundos, crs = 4326)",
    "crumbs": [
      "Análisis Geoestadístico",
      "Análisis Univariado"
    ]
  },
  {
    "objectID": "Geo_uni.html#variable-temperatura",
    "href": "Geo_uni.html#variable-temperatura",
    "title": "Análisis geoestadístico del ozono y la temperatura en California durante marzo de 2024",
    "section": "3.2 Variable Temperatura",
    "text": "3.2 Variable Temperatura\nSe tomaron los datos de Temperatura de la madrugada el primero de marzo de 2024:\n\n\nVer código\nEstacionesT &lt;- data %&gt;% filter(AQSID %in% colnames(Temp_Matrix)[-1])\nEstacionesT &lt;- EstacionesT[,c(1:10,13)]\n\nest_sf_T &lt;- st_as_sf(EstacionesT, \n                      coords = c(\"Longitude\", \"Latitude\"), \n                      crs = 4326)\n\nest_sf_utm_T &lt;- st_transform(est_sf_T, crs = 3310)\ndeci_coord_T = SpatialPoints(cbind(EstacionesT$Longitude,\n                                 EstacionesT$Latitude),\n                           proj4string = CRS(\"+proj=longlat\"))\nutm_coord_T = spTransform(deci_coord_T, CRS(\"EPSG:3310\"))\nutm_coord_df_T = as.data.frame(utm_coord_T)\nEstacionesT$x &lt;- utm_coord_df_T$coords.x1\nEstacionesT$y &lt;- utm_coord_df_T$coords.x2\n\ny_T &lt;- Temp_Matrix[1,] #Tomar una fecha\ny_T &lt;- cbind(colnames(y_T),t(y_T[1,]))\ny_T &lt;- y_T[-1,]\ny_T &lt;- as.data.frame(y_T)\ny_T &lt;- na.omit(y_T)\ny_T &lt;- y_T[-which.min(y_T$V2),]\ny_T &lt;- inner_join(y_T, EstacionesT, by=c(\"V1\"=\"AQSID\"))\ndatosT &lt;- y_T[,c(13,14,2)] #Datos1 es la base con coordenadas + variable\ncolnames(datosT)=c(\"Este\",\"Norte\",\"Temperatura\")\ndatosT$Temperatura &lt;- as.numeric(datosT$Temperatura)\n\ncoords_3310 &lt;- st_coordinates(est_sf_utm_T)\nest_sf_utm_T$Este &lt;- coords_3310[, \"X\"]\nest_sf_utm_T$Norte &lt;- coords_3310[, \"Y\"]\n\n\n# 4. Crear el objeto final de datos (combinando temperatura con las coordenadas UTM)\ndatosT_sf_utm &lt;- merge(est_sf_utm_T, y_T[, c(\"V1\", \"V2\")], by.x = \"AQSID\", by.y = \"V1\")\ndatosT_sf_utm$Temperatura &lt;- as.numeric(datosT_sf_utm$V2)\n\ndatosT_sf_wgs84 &lt;- merge(est_sf_T, y_T[, c(\"V1\", \"V2\")], by.x = \"AQSID\", by.y = \"V1\")\ndatosT_sf_wgs84$Temperatura &lt;- as.numeric(datosT_sf_wgs84$V2)\n\n\n\npal &lt;- colorNumeric(palette = \"viridis\", domain = datosT_sf_wgs84$Temperatura)\n\nleaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  # Contorno de California\n  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = \"black\", weight = 2) %&gt;%\n  # Puntos de temperatura\n  addCircleMarkers(data = datosT_sf_wgs84,\n                   fillColor = ~pal(Temperatura),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 6,\n                   popup = ~paste(\"Temp:\", Temperatura, \"°C\")) %&gt;%\n  addLegend(pal = pal, values = datosT_sf_wgs84$Temperatura, title = \"Temperatura (°C)\")\n\n\n\n\n\n\nVer código\ntemp &lt;- as.geodata(datosT) \nsummary(temp)\n\n\nNumber of data points: 122 \n\nCoordinates summary\n         Este     Norte\nmin -325700.9 -580919.1\nmax  387269.8  281577.0\n\nDistance summary\n         min          max \n    609.2419 1000171.2033 \n\nData summary\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-3.20000 13.15000 15.80000 14.42869 17.20000 24.50000 \n\n\n\nGráficos de dispersiónGeoR\n\n\n\n\nVer código\npar(mfrow=c(1,2))\n\nplot(Temperatura~Este, data = datosT, ylab = \"Temperatura\", xlab=\"Este\")\nplot(Temperatura~Norte, data = datosT, ylab = \"Temperatura\", xlab=\"Norte\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(temp, qt.col = c(\"purple\",\n                    \"pink\",\n                    \"green\",\n                    \"yellow\"),\n     scatter3d=T)\n\n\n\n\n\n\n\n\n\n\n\n\nEn el gráfico se observa un agrupamiento en las coordenadas Norte con respecto a los datos, que puede llegar a corregirse con algún polinomio. Se probará con diferentes modelos a ver si se puede llegar a disminuir el efecto espacial.\n\n3.2.1 Modelo de tendencia espacial\nEl modelo que mejor atrapa el efecto de la media es:\n\nTemperatura = \\beta_0 + \\beta_1 \\times Norte + \\beta_2 \\times Norte^2\n\n\n\nVer código\nfitT &lt;- lm(Temperatura~Norte+I(Norte^2), data = datosT) \nsummary(fitT)\n\n\n\nCall:\nlm(formula = Temperatura ~ Norte + I(Norte^2), data = datosT)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-18.3668  -1.1159   0.9092   2.1923   9.2782 \n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  1.326e+01  5.352e-01  24.766  &lt; 2e-16 ***\nNorte       -2.229e-05  3.230e-06  -6.901 2.68e-10 ***\nI(Norte^2)  -3.754e-11  8.551e-12  -4.390 2.47e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.049 on 119 degrees of freedom\nMultiple R-squared:  0.3199,    Adjusted R-squared:  0.3084 \nF-statistic: 27.98 on 2 and 119 DF,  p-value: 1.094e-10\n\n\nObservamos el comportamiento de sus residuales podemos notar que el modelo ayudo a reducir el efecto espacial.\n\nGráficos de dispersiónGeoR\n\n\n\n\nVer código\ndatosT$Residuos &lt;- fitT$residuals\npar(mfrow=c(1,2))\nplot(Residuos~Este, data = datosT, xlab=\"Este\", ylab=\"Residuos\")\nplot(Residuos~Norte, data = datosT, xlab=\"Norte\", ylab=\"Residuos\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(temp, qt.col = c(\"purple\",\n                    \"pink\",\n                    \"green\",\n                    \"yellow\"),\n     scatter3d=T, trend=~Norte+I(Norte^2))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.2.2 Estimación empírica del semivariograma\np¿Presentamos la estimación del semivariograma obtenida mediante la función variog para la variable temperatura. Se comparan los resultados al calcularlo directamente sobre los datos originales (sin remover la tendencia) y al utilizar los residuales de un modelo de regresión, con el objetivo de analizar cómo influye la presencia de tendencia en la estructura espacial.\n\n\nVer código\nvg_T &lt;- variog(temp, estimator.type = \"modulus\", pairs.min=50) #Sin tendencia espacial\n\n\nvariog: computing omnidirectional variogram\n\n\nVer código\nvg1_T &lt;- variog(temp, trend = ~Norte+I(Norte^2),\n                estimator.type = \"modulus\", pairs.min=50)\n\n\nvariog: computing omnidirectional variogram\n\n\n\nCon tendenciaRemoviendo tendencia\n\n\n\n\nVer código\nplot(vg_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Sin remover tendencia\",\n     col.main = 4, cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Removiendo tendencia\",\n     col.main = 4, cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\nCuando no se remueve la tendencia, la semivarianza alcanza valores más altos y presenta una forma aparentemente más regular, aunque dicha regularidad está influenciada por la tendencia global de los datos. En cambio, al eliminar la tendencia, los valores de semivarianza disminuyen y el patrón pierde suavidad, pero el variograma refleja con mayor fidelidad la verdadera dependencia espacial.\n\n\nVer código\nplot(vg1_T$u, vg1_T$n, type=\"b\",\n     xlab=\"distance\", ylab=\"n pairs\",\n     main=\"Número de pares por bin\")\n\n\n\n\n\n\n\n\n\nEn este caso, el último punto corresponde a menos de 25 pares de observaciones, por lo que su interpretación resulta menos confiable.\n\n\n3.2.3 Estimación del Modelo Teórico de Semivariograma\n\n\nVer código\ndist_matrix_T &lt;- as.matrix(dist(temp$coords))\n\n#1. Funciones de correlación, covarianza y semivarianza: ----\n\n#1.1 Modelo exponencial ----\n\nrho_exp &lt;- function(h, phi){\n  exp(-(h/phi)) #Correlacion espacial\n}\n\ncov_exp &lt;- function(sigma, h, phi){\n  sigma*rho_exp(h, phi) #Covarianza espacial\n}\n\nsv_exp &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_exp(sigma, h, phi) #Semivarianza espacial\n} \n\n#1.2 Modelo Gaussianio ----\n\nrho_gauss &lt;- function(h, phi){\n  exp(-(h/phi)^2)\n}\n\ncov_gauss &lt;- function(sigma, h, phi){\n  sigma*rho_gauss(h, phi) #Covarianza espacial\n}\n\nsv_gauss &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_gauss(sigma, h, phi) #Semivarianza espacial\n}\n#1.3 Modelo Gneting ----\n\ncov_gneiting &lt;- function(h){\n  s &lt;- 0.301187465825\n  ifelse(0&lt;= s*h &  s*h &lt;= 1,\n  (1 + 8*s*h + 25*(s*h)^2 + 32*(s*h)^3) * (1-s*h)^8,\n  0)\n}\n\nsv_gneiting &lt;- function(nugget, sigma, h){\n  nugget + sigma - cov_gneiting(h) #Semivarianza espacial\n}\n\n#1.4 Modelo Spherical ----\n\nrho_spherical &lt;- function(h, phi){\n  ifelse(h&lt;phi,\n         1 - 1.5*(h/phi) + 0.5*(h/phi)^3,\n         0)\n}\n\ncov_spherical &lt;- function(sigma, h, phi){\n  sigma*rho_spherical(h, phi) #Covarianza espacial\n}\n\nsv_spherical &lt;- function(nugget, sigma, h, phi){\n  nugget + sigma - cov_spherical(sigma, h, phi) #Semivarianza espacial\n}\n\n#1.5 Modelo Matern ----\n\nrho_matern &lt;- function(h, phi, kappa){\n  (1/(2*gamma(kappa))) * (h/phi)^kappa * besselK((h/phi), kappa)\n}\n\ncov_matern &lt;- function(sigma, h, phi, kappa){\n  sigma*rho_matern(h, phi, kappa) #Covarianza espacial\n}\n\nsv_matern &lt;- function(nugget, sigma, h, phi, kappa){\n  nugget + sigma - cov_matern(sigma, h, phi, kappa) #Semivarianza espacial\n}\n\n#2. Función para estimar por WLS----\n\nMSE_ponderados &lt;- function(par, h, gamma,kappa=NA,w, model, n, pesos){\n  nugget &lt;- par[1]\n  sigma &lt;- par[2]\n  phi &lt;- par[3]\n  \n  gamma_hat &lt;- switch(model,\n                      \"exponencial\" = sv_exp(nugget, sigma, h, phi),\n                      \"gaussian\"    = sv_gauss(nugget, sigma, h, phi),\n                      \"gneiting\"    = sv_gneiting(nugget, sigma, h, phi),\n                      \"spherical\"   = sv_spherical(nugget, sigma, h, phi),\n                      \"matern\"      = sv_matern(nugget, sigma, h, phi, kappa)\n  )\n  \n  w &lt;- switch(pesos,\n              \"Cressie\" = 1/(2*(2*gamma_hat)^2/n),\n              \"n\" = 1/n,\n              \"h/n\" = 1/(h/n),\n              \"I\" = 1)\n  \n  sum(w*(gamma - gamma_hat)^2)\n}\n\nest_sev_WLS &lt;- function(par, kappa = NA, model, h, gamma, n){\n  sigma_0 &lt;- par[1]\n  phi_0 &lt;- par[2]\n  nugget_0 &lt;- par[3]\n  kappa_0 &lt;- kappa\n  \n  # Selección de función\n  sv &lt;- switch(model,\n               \"exponencial\" = sv_exp,\n               \"gaussian\"    = sv_gauss,\n               \"spherical\"   = sv_spherical,\n               \"gneiting\"    = sv_gneiting,\n               \"matern\"      = sv_matern\n  )\n  \n  args_sv &lt;- names(formals(sv))\n  \n  args_list &lt;- list(\n    nugget = nugget_0,\n    sigma  = sigma_0,\n    h      = h,\n    phi    = phi_0,\n    kappa  = kappa_0\n  )\n  \n  args_list &lt;- args_list[names(args_list) %in% args_sv]\n  \n  sv_ini &lt;- do.call(sv, args_list)\n  \n  formula_sv &lt;- switch(model,\n                       \"gneiting\" = gamma ~ sv(nugget, sigma, h),\n                       \"matern\" = gamma ~ sv(nugget, sigma, h, phi, kappa),\n                       gamma ~ sv(nugget, sigma, h, phi)\n  )\n  \n  start_list &lt;- switch(model,\n                       \"gneting\" = list(nugget = nugget_0, sigma = sigma_0),\n                       \"matern\" = list(nugget = nugget_0, sigma = sigma_0, phi = phi_0, kappa = kappa_0),\n                       list(nugget = nugget_0, sigma = sigma_0, phi = phi_0)\n  )\n    \n    #1. Ponderación de Bessel\n    \n    WW &lt;- (2*(2*sv_ini)^2/n)\n    \n    Bessel &lt;- nls(formula = formula_sv,\n                  start = start_list,\n                  weights = 1/WW,\n                  control = nls.control(maxiter = 500, warnOnly = TRUE))\n    \n    ini_Bessel&lt;-coef(Bessel)\n    \n    #1.1 Optim Bessel\n    \n    optim_bessel &lt;- optim(\n      par = coef(Bessel),\n      fn = MSE_ponderados,\n      h = h,\n      gamma = gamma,\n      pesos = \"Cressie\",\n      model = model,\n      n = n,\n      method = \"L-BFGS-B\",\n      lower = c(0, 0, 0)\n    )\n    \n    par_optim_Bess &lt;- optim_bessel$par[c(\"nugget\", \"sigma\", \"phi\")]\n    \n    #2. Ponderación 1/n\n    \n    W1 &lt;- n\n    \n    n_pond &lt;- nls(formula = formula_sv,\n                  start = start_list,\n                  weights = 1/W1,\n                  control = nls.control(maxiter = 500, warnOnly = TRUE))\n    \n    ini_n&lt;-coef(n_pond)\n    \n    #2.1 Optimización 1/n\n    \n    optim_n &lt;- optim(\n      par = coef(n_pond),\n      fn = MSE_ponderados,\n      h = h,\n      gamma = gamma,\n      pesos = \"n\",\n      n = n,\n      model = model,\n      method = \"L-BFGS-B\",\n      lower = c(0, 0, 0)\n    )    \n    \n    par_optim_n &lt;- optim_n$par[c(\"nugget\", \"sigma\", \"phi\")]\n    \n    \n    #3. Ponderación h/n\n    \n    W2 &lt;- h/n\n    \n    h_n_pond &lt;- nls(formula = formula_sv,\n                    start = start_list,\n                    weights = 1/W2,\n                    control = nls.control(maxiter = 500, warnOnly = TRUE))\n    \n    ini_h_n&lt;-coef(h_n_pond)\n    \n    optim_h_n &lt;- optim(\n      par = coef(h_n_pond),\n      fn = MSE_ponderados,\n      h = h,\n      gamma = gamma,\n      pesos = \"h/n\",\n      model = model,\n      n = n,\n      method = \"L-BFGS-B\",\n      lower = c(0, 0, 0)\n    )    \n    \n    par_optim_h_n &lt;- optim_h_n$par[c(\"nugget\", \"sigma\", \"phi\")]\n    \n\nres &lt;- list(Bessel = list(Iniciales = ini_Bessel,\n                           Optimizados = par_optim_Bess),\n            `1/n` = list(Iniciales = ini_n,\n                          Optimizados = par_optim_n),\n            `h/n` = list(Iniciales = ini_h_n,\n                          Optimizados = par_optim_h_n))    \nreturn(res)\n}\n\nMSE_sv &lt;- function(gamma_hat, par, kappa, model, h){\n  sigma_0 &lt;- par[[2]]\n  phi_0 &lt;- par[[3]]\n  nugget_0 &lt;- par[[1]]\n  kappa_0 &lt;- kappa\n  \n  sv &lt;- switch(model,\n               \"exponencial\" = sv_exp,\n               \"gaussian\"    = sv_gauss,\n               \"spherical\"   = sv_spherical,\n               \"gneiting\"    = sv_gneiting,\n               \"matern\"      = sv_matern\n  )\n  \n  args_sv &lt;- names(formals(sv))\n  \n  args_list &lt;- list(\n    nugget = nugget_0,\n    sigma  = sigma_0,\n    h      = h,\n    phi    = phi_0,\n    kappa  = kappa_0\n  )\n  \n  args_list &lt;- args_list[names(args_list) %in% args_sv]\n  \n  sv_est &lt;- do.call(sv, args_list)\n  \n  return(mean((sv_est-gamma_hat)^2))\n}\n\n#3. Función para etimar por máxima verosimilitud\n\nloglik &lt;- function(par, kappa=NA, z, dist_matrix, model){\n  sigma_0 &lt;- par[1]\n  phi_0 &lt;- par[2]\n  nugget_0 &lt;- par[3]\n  kappa_0 &lt;- kappa\n  \n  cov &lt;- switch(model,\n               \"exponencial\" = cov_exp,\n               \"gaussian\"    = cov_gauss,\n               \"spherical\"   = cov_spherical,\n               \"gneiting\"    = cov_gneiting,\n               \"matern\"      = cov_matern\n  )\n  \n  args_cov &lt;- names(formals(cov))\n  \n  args_list &lt;- list(\n    sigma  = sigma_0,\n    nugget = nugget_0,\n    h      = dist_matrix,\n    phi    = phi_0,\n    kappa  = kappa_0\n  )\n  \n  args_list &lt;- args_list[names(args_list) %in% args_cov]\n  \n  Sigma &lt;- do.call(cov, args_list) \n  diag(Sigma) = diag(Sigma) + nugget_0\n  \n  # Descomposición de Cholesky (más estable que solve o det)\n  inv_Sigma &lt;- solve(Sigma)\n  det &lt;- log(det(Sigma))\n  \n  # Log-verosimilitud del modelo Gaussiano\n  z &lt;- z \n  n &lt;- length(z)\n  ll &lt;- -0.5 * (n * log(2 * pi) + det + crossprod(z, inv_Sigma %*% z))  # Log-verosimilitud (negativa porque optim minimiza)\n  return(-ll)\n}\n\n\nLos modelos obtenidos ajustanto por EyeFit, son:\n\ncov.model sigmasq      phi tausq kappa kappa2 practicalRange\n1 exponential   10.74 109166.3  2.07    NA     NA       327033.0\n2    gaussian   10.00  80000.0  2.07    NA     NA       138465.5\n3   spherical   10.00 157832.8  2.07    NA     NA       157832.8\n\n\nVer código\nvariog_T &lt;- data.frame(h = vg1_T$u, gamma_hat = vg1_T$v,\n                       n = vg1_T$n)\n\nrange_sv_T &lt;- seq(1,max(variog_T$h), by=1000)\n\n# Modelo exponencial ----\n\nsigma_0_eT &lt;- 10.74\nphi_0_eT &lt;- 109166.3\nnugget_0_eT &lt;- 2.07\n\npar_eT &lt;- c(sigma_0_eT, phi_0_eT, nugget_0_eT)\n\nres_e_T &lt;- est_sev_WLS(par=par_eT, kappa = NA,\n                       model=\"exponencial\",\n                       h=variog_T$h,\n                       gamma = variog_T$gamma_hat,\n                       n = variog_T$n)\n\n\nWarning in nls(formula = formula_sv, start = start_list, weights = 1/W2, :\ngradiente singular\n\n\nVer código\nMLE_eT &lt;- optim(fn = loglik,\n             par = par_eT,\n             kappa=NA,\n             z = datosT$Residuos, \n             dist_matrix=dist_matrix_T,\n             model = \"exponencial\",\n             method = \"L-BFGS-B\",\n             lower = c(0, 0, 0))\n\nestsv_exp_Bess_T &lt;- do.call(sv_exp, c(as.list(res_e_T$Bessel$Optimizados), list(h = range_sv_T)))\nestsv_exp_n_T &lt;- do.call(sv_exp, c(as.list(res_e_T$`1/n`$Optimizados), list(h = range_sv_T)))\nestsv_exp_h_n_T &lt;- do.call(sv_exp, c(as.list(res_e_T$`h/n`$Optimizados), list(h = range_sv_T)))\nestsv_exp_MLE_T &lt;- do.call(sv_exp, c(list(nugget = MLE_eT$par[3], phi = MLE_eT$par[2] , sigma = MLE_eT$par[1],h = range_sv_T)))\n\n# Modelo Gaussiano ----\n\nsigma_0_gT &lt;- 10.00    \nphi_0_gT &lt;- 80000.0\nnugget_0_gT &lt;- 2.07\n\npar_gT &lt;- c(sigma_0_gT, phi_0_gT, nugget_0_gT)\n\nres_g_T &lt;- est_sev_WLS(par=par_gT, kappa = NA,\n                       model=\"gaussian\",\n                       h=variog_T$h,\n                       gamma = variog_T$gamma_hat,\n                       n = variog_T$n)\n\nestsv_g_Bess_T &lt;- do.call(sv_gauss, c(as.list(res_g_T$Bessel$Optimizados), list(h = range_sv_T)))\nestsv_g_n_T &lt;- do.call(sv_gauss, c(as.list(res_g_T$`1/n`$Optimizados), list(h = range_sv_T)))\nestsv_g_h_n_T &lt;- do.call(sv_gauss, c(as.list(res_g_T$`h/n`$Optimizados), list(h = range_sv_T)))\n\n# Modelo esférico\n\nsigma_0_esT &lt;- 10.00   \nphi_0_esT &lt;- 157832.8\nnugget_0_esT &lt;- 2.07\n\npar_esT &lt;- c(sigma_0_esT, phi_0_esT, nugget_0_esT)\n\nres_es_T &lt;- est_sev_WLS(par=par_esT, kappa = NA,\n                       model=\"spherical\",\n                       h=variog_T$h,\n                       gamma = variog_T$gamma_hat,\n                       n = variog_T$n)\n\nMLE_esT &lt;- optim(fn = loglik,\n             par = par_esT,\n             kappa=NA,\n             z = datosT$Residuos, \n             dist_matrix=dist_matrix_T,\n             model = \"spherical\",\n             method = \"L-BFGS-B\",\n             lower = c(0, 0, 0))\n\n\nestsv_es_Bess_T &lt;- do.call(sv_spherical, c(as.list(res_es_T$Bessel$Optimizados), list(h = range_sv_T)))\nestsv_es_n_T &lt;- do.call(sv_spherical, c(as.list(res_es_T$`1/n`$Optimizados), list(h = range_sv_T)))\nestsv_es_h_n_T &lt;- do.call(sv_spherical, c(as.list(res_es_T$`h/n`$Optimizados), list(h = range_sv_T)))\nestsv_es_MLE_T &lt;- do.call(sv_spherical, c(list(nugget = MLE_esT$par[3], phi = MLE_esT$par[2] , sigma = MLE_esT$par[1],h = range_sv_T)))\n\n\n\nExponencialGaussianoEsférico\n\n\n\nOptimGeoR\n\n\n\n\nVer código\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (optim)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(range_sv_T, estsv_exp_Bess_T, col=\"#FF4040\", lwd=1.5)\nlines(range_sv_T, estsv_exp_n_T, col=\"#4169E1\", lwd=1.5)\nlines(range_sv_T, estsv_exp_h_n_T, col=\"#008B00\", lwd=1.5)\nlines(range_sv_T, estsv_exp_MLE_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"Cressie\", \"1/n\", \"n/h\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\nVer código\nresumen_exp_T &lt;- cbind(\n  c(\"Cressie\", \"$$1/n$$\", \"$$n/h$$\", \"MLE\"),\n  rbind(\n    t(res_e_T$Bessel$Optimizados),\n    t(res_e_T$`1/n`$Optimizados),\n    t(res_e_T$`h/n`$Optimizados),\n    MLE_eT$par[c(3,1,2)]\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, res_e_T$Bessel$Optimizados, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_e_T$`1/n`$Optimizados, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_e_T$`h/n`$Optimizados, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, list(nugget = MLE_eT$par[3], phi = MLE_eT$par[2] , sigma = MLE_eT$par[1]), NA, model = \"exponencial\", variog_T$h)\n  )\n)\n\nresumen_exp_T &lt;- as.data.frame(resumen_exp_T)\nresumen_exp_T[ , -1] &lt;- lapply(resumen_exp_T[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_exp_T, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nCressie\n0\n12.944\n98216.23\n3.591000e+00\n\n\n1/n\n0\n11.178\n74809.84\n3.867000e+00\n\n\nn/h\n0\n12.797\n98765.53\n3.465000e+00\n\n\nMLE\n0\n31.706\n109166.30\n1.191489e+10\n\n\n\n\n\n\n\n\n\nVer código\nini1_exp_T &lt;- c(sigma_0_eT, phi_0_eT)\nfitvar1_exp_T &lt;- variofit(vg1_T,\n                    cov.model = \"exponential\",\n                    ini1_exp_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_eT,\n                    wei = \"equal\")\n\nfitvar2_exp_T &lt;- variofit(vg1_T,\n                    cov.model = \"exponential\",\n                    ini1_exp_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_eT,\n                    wei = \"npairs\")\n\nfitvar3_exp_T &lt;- variofit(vg1_T,\n                    cov.model = \"exponential\",\n                    ini1_exp_T,\n                    fix.nugget =F,\n                    nugget = nugget_0_eT,\n                    wei = \"cressie\")\n\nfitvar4_exp_T &lt;- likfit(temp,\n                  coords = temp$coords,\n                  data = temp$data,\n                  trend = ~ poly(Norte, 2, raw = FALSE),\n                  ini.cov.pars = ini1_exp_T,\n                  fix.nugget = F,\n                  nugget = nugget_0_eT,\n                  cov.model = \"exponential\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_exp_T, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_exp_T, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_exp_T, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_exp_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Texp &lt;- c(fitvar1_exp_T$nugget, fitvar1_exp_T$cov.pars[1], fitvar1_exp_T$cov.pars[2])\npar2Texp &lt;- c(fitvar2_exp_T$nugget, fitvar2_exp_T$cov.pars[1], fitvar2_exp_T$cov.pars[2])\npar3Texp &lt;- c(fitvar3_exp_T$nugget, fitvar3_exp_T$cov.pars[1], fitvar3_exp_T$cov.pars[2])\npar4Texp &lt;- c(fitvar4_exp_T$nugget, fitvar4_exp_T$cov.pars[1], fitvar4_exp_T$cov.pars[2])\n\nresumen_exp_T2 &lt;- cbind(\n  c(\"MCO\", \"$$1/n$$\", \"$$Cressie$$\",\"MLE\"),\n  rbind(\n    par1Texp,\n    par2Texp,\n    par3Texp,\n    par4Texp\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, par1Texp, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par2Texp, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par3Texp, NA, model = \"exponencial\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par4Texp, NA, model = \"exponencial\", variog_T$h)\n  )\n)\n\nresumen_exp_T2 &lt;- as.data.frame(resumen_exp_T2)\nresumen_exp_T2[ , -1] &lt;- lapply(resumen_exp_T2[ , -1], function(x) round(as.numeric(x), 3))\nkable(resumen_exp_T2, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n0\n12.141\n82253.55\n3.184\n\n\n1/n\n0\n12.423\n83939.23\n3.243\n\n\nCressie\n0\n13.298\n109166.30\n4.009\n\n\nMLE\n0\n23.536\n75307.76\n117.550\n\n\n\n\n\n\n\n\n\n\n\nOptimGeoR\n\n\n\n\nVer código\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (optim)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(range_sv_T, estsv_g_Bess_T, col=\"#FF4040\", lwd=1.5)\nlines(range_sv_T, estsv_g_n_T, col=\"#4169E1\", lwd=1.5)\nlines(range_sv_T, estsv_g_h_n_T, col=\"#008B00\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"Cressie\", \"1/n\", \"n/h\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\nVer código\nresumen_g_T &lt;- cbind(\n  c(\"Cressie\", \"$$1/n$$\", \"$$n/h$$\"),\n  rbind(\n    t(res_g_T$Bessel$Optimizados),\n    t(res_g_T$`1/n`$Optimizados),\n    t(res_g_T$`h/n`$Optimizados)\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, res_g_T$Bessel$Optimizados, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_g_T$`1/n`$Optimizados, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_g_T$`h/n`$Optimizados, NA, model = \"gaussian\", variog_T$h)\n  )\n)\n\nresumen_g_T &lt;- as.data.frame(resumen_g_T)\nresumen_g_T[ , -1] &lt;- lapply(resumen_g_T[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_g_T, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nCressie\n0\n12.053\n74520.03\n2.809\n\n\n1/n\n0\n11.126\n69274.92\n3.233\n\n\nn/h\n0\n11.620\n72540.07\n2.825\n\n\n\n\n\n\n\n\n\nVer código\nini1_g_T &lt;- c(sigma_0_gT, phi_0_gT)\nfitvar1_g_T &lt;- variofit(vg1_T,\n                    cov.model = \"gaussian\",\n                    ini1_g_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_gT,\n                    wei = \"equal\")\n\nfitvar2_g_T &lt;- variofit(vg1_T,\n                    cov.model = \"gaussian\",\n                    ini1_g_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_gT,\n                    wei = \"npairs\")\n\nfitvar3_g_T &lt;- variofit(vg1_T,\n                    cov.model = \"gaussian\",\n                    ini1_g_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_gT,\n                    wei = \"cressie\")\n\nfitvar4_g_T &lt;- likfit(temp,\n                  coords = temp$coords,\n                  data = temp$data,\n                  trend = ~ poly(Norte, 2, raw = FALSE),\n                  ini.cov.pars = ini1_g_T,\n                  fix.nugget = F,\n                  nugget = nugget_0_gT,\n                  cov.model = \"gaussian\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_g_T, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_g_T, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_g_T, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_g_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Tg &lt;- c(fitvar1_g_T$nugget, fitvar1_g_T$cov.pars[1], fitvar1_g_T$cov.pars[2])\npar2Tg &lt;- c(fitvar2_g_T$nugget, fitvar2_g_T$cov.pars[1], fitvar2_g_T$cov.pars[2])\npar3Tg &lt;- c(fitvar3_g_T$nugget, fitvar3_g_T$cov.pars[1], fitvar3_g_T$cov.pars[2])\npar4Tg &lt;- c(fitvar4_g_T$nugget, fitvar4_g_T$cov.pars[1], fitvar4_g_T$cov.pars[2])\n\nresumen_g_T2 &lt;- cbind(\n  c(\"MCO\", \"$$1/n$$\", \"$$Cressie$$\",\"MLE\"),\n  rbind(\n    par1Tg,\n    par2Tg,\n    par3Tg,\n    par4Tg\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, par1Tg, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par2Tg, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par3Tg, NA, model = \"gaussian\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par4Tg, NA, model = \"gaussian\", variog_T$h)\n  )\n)\n\nresumen_g_T2 &lt;- as.data.frame(resumen_g_T2)\nresumen_g_T2[ , -1] &lt;- lapply(resumen_g_T2[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_g_T2, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n0.000\n11.862\n74341.86\n2.776\n\n\n1/n\n0.000\n11.883\n74575.03\n2.777\n\n\nCressie\n0.349\n11.781\n80000.00\n2.835\n\n\nMLE\n3.589\n21.264\n80000.00\n155.000\n\n\n\n\n\n\n\n\n\n\n\nOptimGeoR\n\n\n\n\nVer código\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (optim)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(range_sv_T, estsv_es_Bess_T, col=\"#FF4040\", lwd=1.5)\nlines(range_sv_T, estsv_es_n_T, col=\"#4169E1\", lwd=1.5)\nlines(range_sv_T, estsv_es_h_n_T, col=\"#008B00\", lwd=1.5)\nlines(range_sv_T, estsv_es_MLE_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"Cressie\", \"1/n\", \"n/h\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\nVer código\nresumen_es_T &lt;- cbind(\n  c(\"Cressie\", \"$$1/n$$\", \"$$n/h$$\",\"MLE\"),\n  rbind(\n    t(res_es_T$Bessel$Optimizados),\n    t(res_es_T$`1/n`$Optimizados),\n    t(res_es_T$`h/n`$Optimizados),\n    MLE_esT$par[c(3,1,2)]\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, res_es_T$Bessel$Optimizados, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_es_T$`1/n`$Optimizados, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, res_es_T$`h/n`$Optimizados, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, list(nugget = MLE_esT$par[3], phi = MLE_esT$par[2] , sigma = MLE_esT$par[1]), NA, model = \"spherical\", variog_T$h)\n  )\n)\n\nresumen_es_T &lt;- as.data.frame(resumen_es_T)\nresumen_es_T[ , -1] &lt;- lapply(resumen_es_T[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_es_T, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nCressie\n0\n12.165\n191573.0\n3.044000e+00\n\n\n1/n\n0\n11.128\n165974.6\n3.417000e+00\n\n\nn/h\n0\n11.692\n175441.3\n2.976000e+00\n\n\nMLE\n0\n27.958\n157832.8\n2.490774e+10\n\n\n\n\n\n\n\n\n\nVer código\nini1_es_T &lt;- c(sigma_0_esT, phi_0_esT)\nfitvar1_es_T &lt;- variofit(vg1_T,\n                    cov.model = \"spherical\",\n                    ini1_es_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_esT,\n                    wei = \"equal\")\n\nfitvar2_es_T &lt;- variofit(vg1_T,\n                    cov.model = \"spherical\",\n                    ini1_es_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_esT,\n                    wei = \"npairs\")\n\nfitvar3_es_T &lt;- variofit(vg1_T,\n                    cov.model = \"spherical\",\n                    ini1_es_T,\n                    fix.nugget = F,\n                    nugget = nugget_0_esT,\n                    wei = \"cressie\")\n\nfitvar4_es_T &lt;- likfit(temp,\n                  coords = temp$coords,\n                  data = temp$data,\n                  trend = ~ poly(Norte, 2, raw = FALSE),\n                  ini.cov.pars = ini1_es_T,\n                  fix.nugget = F,\n                  nugget = nugget_0_esT,\n                  cov.model = \"spherical\",\n                  lik.method = \"ML\")\n\n\nplot(vg1_T,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Estimación teórica del modelo de semivariograma \\n (GeoR, gstat)\",\n     col.main = \"#36648B\", cex.main =1.3)\nlines(fitvar1_es_T, col=\"#FF4040\", lwd=1.5)\nlines(fitvar2_es_T, col=\"#4169E1\", lwd=1.5)\nlines(fitvar3_es_T, col=\"#008B00\", lwd=1.5)\nlines(fitvar4_es_T, col=\"#FFA500\", lwd=1.5)\nlegend(\"topleft\",\n       c(\"MCO\", \"1/n\", \"Cressie\", \"MLE\"),#, \"REML\"),\n       lwd = 1,\n       lty = 3,\n       col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       box.col = 9,\n       text.col = c(\"#FF4040\", \"#4169E1\", \"#008B00\",\"#FFA500\"),\n       cex=1,\n       seg.len = .5)\n\n\n\n\n\n\n\n\n\n\n\nVer código\npar1Tes &lt;- c(fitvar1_es_T$nugget, fitvar1_es_T$cov.pars[1], fitvar1_es_T$cov.pars[2])\npar2Tes &lt;- c(fitvar2_es_T$nugget, fitvar2_es_T$cov.pars[1], fitvar2_es_T$cov.pars[2])\npar3Tes &lt;- c(fitvar3_es_T$nugget, fitvar3_es_T$cov.pars[1], fitvar3_es_T$cov.pars[2])\npar4Tes &lt;- c(fitvar4_es_T$nugget, fitvar4_es_T$cov.pars[1], fitvar4_es_T$cov.pars[2])\n\nresumen_es_T2 &lt;- cbind(\n  c(\"MCO\", \"$$1/n$$\", \"$$Cressie$$\",\"MLE\"),\n  rbind(\n    par1Tes,\n    par2Tes,\n    par3Tes,\n    par4Tes\n  ),\n  MSE = c(\n    MSE_sv(variog_T$gamma_hat, par1Tes, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par2Tes, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par3Tes, NA, model = \"spherical\", variog_T$h),\n    MSE_sv(variog_T$gamma_hat, par4Tes, NA, model = \"spherical\", variog_T$h)\n  )\n)\n\nresumen_es_T2 &lt;- as.data.frame(resumen_es_T2)\nresumen_es_T2[ , -1] &lt;- lapply(resumen_es_T2[ , -1], function(x) round(as.numeric(x), 3))\n\nkable(resumen_es_T2, digits = 3,\n      col.names = c(\"Método\", \"Nugget\", \"Sigma\", \"Phi\", \"MSE\"),\n      escape = F, row.names = F)\n\n\n\n\n\nMétodo\nNugget\nSigma\nPhi\nMSE\n\n\n\n\nMCO\n0\n11.878\n171733.0\n2.938\n\n\n1/n\n0\n11.898\n166427.4\n2.944\n\n\nCressie\n0\n11.860\n157832.8\n2.977\n\n\nMLE\n0\n25.641\n144147.3\n179.276\n\n\n\n\n\n\n\n\n\n\n\nEl modelo con menor MSE es el modelo Gausiano. Sin embargo, dada la inestabilidad numérica que se observa al realizar la predicción se opta por usar el modelo esférico obtenido por mínimos cuadrados ponderados usando la ponderación 1/n, que es el segundo mejor en términos del MSE.\n\n\n3.2.4 Kriging\n\n\nVer código\nbest_model_T &lt;- gstat::vgm(psill = res_es_T$`1/n`$Optimizados[2],\n                           model = \"Sph\",\n                           range = res_es_T$`1/n`$Optimizados[3],\n                           nugget = res_es_T$`1/n`$Optimizados[1]\n)\n\nsh_mundos_utm &lt;- st_transform(sh_mundos, crs = CRS(\"EPSG:3310\"))\n\nnew &lt;- sp::spsample(as(sh_mundos_utm, \"Spatial\"), n = 50000, type = \"regular\")\n\nproj4string(new) &lt;- CRS(\"EPSG:3310\")\ncoordinates(new) ~ Este + Norte\n\n\ncoordinates(new) ~ Este + Norte\n\n\nVer código\ncolnames(new@coords) &lt;- c(\"Este\", \"Norte\")\n\ncoordinates(datosT) &lt;- ~Este + Norte\nproj4string(datosT) &lt;- CRS(\"EPSG:3310\")\n\ng_obj&lt;-gstat::gstat(id=\"Temperatura\",\n             formula = Temperatura ~ Norte + I(Norte^2),\n             model = best_model_T,\n             data = datosT)\nsh_mundos_sp_utm &lt;- as(sh_mundos_utm, \"Spatial\")\n\npredic &lt;- predict(g_obj, newdata = new)\n\n\n[using universal kriging]\n\n\nVer código\nprediction &lt;- data.frame(predic)\n\n#Mapas de predicción\n\ngridded(predic) &lt;- TRUE\n\n#1. Mapa de Kriging\n\npredic_raster_utm &lt;- raster(predic, layer = \"Temperatura.pred\")\n\n# 2. Asegurarse de que el CRS del ráster se asigne correctamente (EPSG:3310)\ncrs(predic_raster_utm) &lt;- \"+init=epsg:3310\"\n\nsh_mundos_utm_simple &lt;- st_union(sh_mundos_utm)\nsh_mundos_sp_utm_simple &lt;- as(sh_mundos_utm_simple, \"Spatial\")\n\npredic_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        predic_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nbins &lt;- c(-5,0, 5, 8, 10, 12, 15, 20, 25)\n\npred_range &lt;- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))\npal_pred &lt;- colorBin(\n  palette = \"viridis\", # La paleta de colores\n  domain = pred_range,\n  bins = bins,\n  na.color = \"transparent\"\n)\n\nmapa_kriging_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  \n  # Añadir la capa ráster de Predicción Kriging\n  addRasterImage(\n    predic_raster_wgs84, # Usamos el objeto raster reproyectado\n    colors = pal_pred, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n    addCircleMarkers(data = datosT_sf_wgs84,\n                   fillColor = ~pal(Temperatura),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 6,\n                   popup = ~paste(\"Temp:\", Temperatura, \"°C\")) %&gt;% \n  \n  addLegend(\n    pal = pal_pred, \n    values = pred_range,\n    title = \"Predicción T (°C)\",\n    position = \"topright\"\n  ) %&gt;%\n  \n  addLegend(pal = pal,\n            values = datosT_sf_wgs84$Temperatura,\n            title = \"Temperatura Observada\",\n    position = \"topleft\"\n  ) \n\n#2 Mapa Varianza------------------------------------------\n\nvar_raster_utm &lt;- raster(predic, layer = \"Temperatura.var\")\n\n# 2. Asegurarse de que el CRS del ráster se asigne correctamente (EPSG:3310)\ncrs(var_raster_utm) &lt;- \"+init=epsg:3310\"\n\nvar_raster_wgs84 &lt;- raster::projectRaster(\n    raster::mask(\n        var_raster_utm, \n        sh_mundos_sp_utm_simple\n    ),\n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nbinsv &lt;- seq(0,30, by=5)\n\nvar_range &lt;- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))\npal_var &lt;- colorBin(\n  palette = \"Spectral\", # La paleta de colores\n  domain = var_range,\n  bins = binsv,\n  na.color = \"transparent\"\n)\n\nmapa_var_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  \n  # Añadir la capa ráster de Predicción Kriging\n  addRasterImage(\n    var_raster_wgs84, # Usamos el objeto raster reproyectado\n    colors = pal_var, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  addLegend(\n    pal = pal_var, \n    values = var_range,\n    title = \"Varianza\",\n    position = \"topright\"\n  ) \n\n#3. Mapa Cv ----------------------------------------------\n\ncv_raster_utm &lt;- sqrt(var_raster_utm) / abs(predic_raster_utm)\n\nmapa_mayor_a_uno &lt;- cv_raster_utm &gt; 1\ncv_raster_utm[mapa_mayor_a_uno] &lt;- 1\n\ncrs(cv_raster_utm) &lt;- \"+init=epsg:3310\"\n\ncv_raster_masked_utm &lt;- raster::mask(cv_raster_utm, sh_mundos_sp_utm_simple)\n\n# 2. Aplicar CROP (Recorte físico del rectángulo)\ncv_raster_cropped_utm &lt;- raster::crop(cv_raster_masked_utm, sh_mundos_sp_utm_simple)\n\n# 3. Reproyectar el objeto MÁS PEQUEÑO a WGS84\ncv_raster_wgs84 &lt;- raster::projectRaster(\n    cv_raster_cropped_utm, \n    crs = \"+init=epsg:4326\", \n    method = \"bilinear\"\n)\n\nbincv &lt;- seq(0,1, by=.1)\n\ncv_range &lt;- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))\n\npal_cv &lt;- colorBin(\n  palette = \"RdYlGn\", # Rojo-Amarillo-Verde\n  domain = cv_range,\n  na.color = \"transparent\",\n  bins = bincv,\n  reverse = TRUE # ¡Esto es CRUCIAL! Para que el Verde sea BAJA incertidumbre.\n)\n\nmapa_cv_leaflet &lt;- leaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  \n  # Añadir la capa ráster de Predicción Kriging\n  addRasterImage(\n    cv_raster_wgs84, # Usamos el objeto raster reproyectado\n    colors = pal_cv, \n    opacity = 0.7,\n    group = \"Predicción Kriging\"\n  ) %&gt;%\n  \n  addLegend(\n    pal = pal_cv, \n    values = cv_range,\n    title = \"Coeficiente de Variación\",\n    position = \"topright\"\n  )\n\n\n\nPredicciónVarianzaCoeficiente de variación\n\n\n\n\nVer código\nmapa_kriging_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_var_leaflet\n\n\n\n\n\n\n\n\n\n\nVer código\nmapa_cv_leaflet",
    "crumbs": [
      "Análisis Geoestadístico",
      "Análisis Univariado"
    ]
  },
  {
    "objectID": "Geo_uni.html#variable-ozono",
    "href": "Geo_uni.html#variable-ozono",
    "title": "Análisis geoestadístico del ozono y la temperatura en California durante marzo de 2024",
    "section": "3.1 Variable Ozono",
    "text": "3.1 Variable Ozono\nSe tomaron los datos de Temperatura de la madrugada el primero de marzo de 2024:\n\n\nVer código\nEstacionesOz &lt;- data %&gt;% filter(AQSID %in% colnames(Ozone_Matrix)[-1])\nEstacionesOz &lt;- EstacionesOz[,c(1:10,13)]\n\nest_sf_Oz &lt;- st_as_sf(EstacionesOz, \n                   coords = c(\"Longitude\", \"Latitude\"), \n                   crs = 4326)\nest_sf_utm_O &lt;- st_transform(est_sf_Oz, crs = 3310)\ndeci_coord_O = SpatialPoints(cbind(EstacionesOz$Longitude,\n                                 EstacionesOz$Latitude),\n                           proj4string = CRS(\"+proj=longlat\"))\nutm_coord_O = spTransform(deci_coord_O, CRS(\"EPSG:3310\"))\nutm_coord_df_O = as.data.frame(utm_coord_O)\nEstacionesOz$x &lt;- utm_coord_df_O$coords.x1\nEstacionesOz$y &lt;- utm_coord_df_O$coords.x2\n\ny_oz &lt;- Ozone_Matrix[1,] #Tomar una fecha\ny_oz &lt;- cbind(colnames(y_oz),t(y_oz[1,]))\ny_oz &lt;- y_oz[-1,]\ny_oz &lt;- as.data.frame(y_oz)\ny_oz &lt;- na.omit(y_oz)\ny_oz &lt;- inner_join(y_oz, EstacionesOz, by=c(\"V1\"=\"AQSID\"))\ndatosOZ &lt;- y_oz[,c(13,14,2)] #Datos1 es la base con coordenadas + variable\ncolnames(datosOZ)=c(\"Este\",\"Norte\",\"Ozono\")\ndatosOZ$Ozono &lt;- as.numeric(datosOZ$Ozono)\n\ncoords_3310O &lt;- st_coordinates(est_sf_utm_O)\nest_sf_utm_O$Este &lt;- coords_3310O[, \"X\"]\nest_sf_utm_O$Norte &lt;- coords_3310O[, \"Y\"]\n\ndatosO_sf_utm &lt;- merge(est_sf_utm_O, y_oz[, c(\"V1\", \"V2\")], by.x = \"AQSID\", by.y = \"V1\")\ndatosO_sf_utm$Ozono &lt;- as.numeric(datosO_sf_utm$V2)\n\ndatosO_sf_wgs84 &lt;- merge(est_sf_Oz, y_oz[, c(\"V1\", \"V2\")], by.x = \"AQSID\", by.y = \"V1\")\ndatosO_sf_wgs84$Ozono &lt;- as.numeric(datosO_sf_wgs84$V2)\n\n\n\npalO &lt;- colorNumeric(palette = \"viridis\", domain = datosO_sf_wgs84$Ozono)\n\nleaflet() %&gt;%\n  addProviderTiles(providers$CartoDB.Positron) %&gt;%\n  # Contorno de California\n  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = \"black\", weight = 2) %&gt;%\n  # Puntos de temperatura\n  addCircleMarkers(data = datosO_sf_wgs84,\n                   fillColor = ~palO(Ozono),\n                   fillOpacity = 0.8,\n                   color = \"black\",\n                   weight = 1,\n                   radius = 6,\n                   popup = ~paste(\"Ozono:\", Ozono, \"°C\")) %&gt;%\n  addLegend(pal = palO, values = datosO_sf_wgs84$Ozono, title = \"Ozono (ppb)\")\n\n\n\n\n\n\nVer código\nozone &lt;- as.geodata(datosOZ) \nsummary(ozone)\n\n\nNumber of data points: 139 \n\nCoordinates summary\n         Este   Norte\nmin -276541.1 -598934\nmax  500861.7  415184\n\nDistance summary\n       min        max \n   6304.93 1187479.83 \n\nData summary\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n20.00000 35.00000 38.00000 37.48201 40.50000 53.00000 \n\n\n\nGráficos de dispersiónGeoR\n\n\n\n\nVer código\npar(mfrow=c(1,2))\n\nplot(Ozono~Este, data = datosOZ, ylab = \"Ozono\", xlab=\"Este\")\nplot(Ozono~Norte, data = datosOZ, ylab = \"Ozono\", xlab=\"Norte\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(ozone, qt.col = c(\"purple\",\n                          \"pink\",\n                          \"green\",\n                          \"yellow\"),\n     scatter3d=T)\n\n\n\n\n\n\n\n\n\n\n\n\nEl gráfico muestra una relación polinomial de la variable Ozono con respecto a las coordenadas en Norte. Se prueba con varios modelos hasta encontrar aquel que mitigue el efecto espacial.\n\n3.1.1 Modelo de tendencia espacial\nEl modelo que mejor atrapa el efecto de la media es:\nOzono = \\beta_0+\\beta_1 \\times Norte + \\beta_2 \\times Norte^2 + \\beta_3 \\times Norte^3\n\n\nVer código\nfitO &lt;- lm(Ozono~poly(Norte,3), data = datosOZ) \nsummary(fitO)\n\n\n\nCall:\nlm(formula = Ozono ~ poly(Norte, 3), data = datosOZ)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-16.1873  -2.2096   0.3313   2.3770  11.9884 \n\nCoefficients:\n                Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)      37.4820     0.3551 105.541  &lt; 2e-16 ***\npoly(Norte, 3)1 -29.2103     4.1871  -6.976 1.23e-10 ***\npoly(Norte, 3)2  16.3181     4.1871   3.897 0.000153 ***\npoly(Norte, 3)3  14.9140     4.1871   3.562 0.000509 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.187 on 135 degrees of freedom\nMultiple R-squared:  0.3618,    Adjusted R-squared:  0.3477 \nF-statistic: 25.51 on 3 and 135 DF,  p-value: 3.865e-13\n\n\nGráficamente se observa una mitigación en la tendencia espacial:\n\nGráficos de dispersiónGeoR\n\n\n\n\nVer código\ndatosOZ$Residuos &lt;- fitO$residuals\n\npar(mfrow=c(1,2))\nplot(Residuos~Este, data = datosOZ, xlab=\"Este\", ylab=\"Residuos\")\nplot(Residuos~Norte, data = datosOZ, xlab=\"Norte\", ylab=\"Residuos\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(ozone, qt.col = c(\"purple\",\n                          \"pink\",\n                          \"green\",\n                          \"yellow\"),\n     scatter3d=T, trend = ~ poly(Norte,3))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.1.2 Estimación empírica del semivariograma\nA continuación, se presenta la estimación del semivariograma obtenida con la función variog. Se muestran dos gráficos comparativos: el primero corresponde a los datos originales (sin eliminar la tendencia) y el segundo a los residuales obtenidos tras ajustar el modelo de regresión, lo que permite observar el efecto de remover la tendencia en la estructura espacial.\n\n\nVer código\nvg_O &lt;- variog(ozone,estimator.type = \"modulus\", pairs.min=50) #Sin tendencia espacial\n\n\nvariog: computing omnidirectional variogram\n\n\nVer código\nvg1_O &lt;- variog(ozone, trend = ~poly(Norte,3), estimator.type = \"modulus\", pairs.min=50)\n\n\nvariog: computing omnidirectional variogram\n\n\n\nCon tendenciaRemoviendo Tendencia\n\n\n\n\nVer código\nplot(vg_O,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Sin remover tendencia\",\n     col.main = 4, cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer código\nplot(vg1_O,\n     xlab = \"h\",\n     ylab = \"Semivarianza\",\n     cex.lab = 1.3,\n     cex.axis = 1.2,\n     main = \"Removiendo tendencia\",\n     col.main = 4, cex.main =1.3)\n\n\n\n\n\n\n\n\n\n\n\n\nSe observa que la estimación de la semivarianza de la variable incrementos es más estable y presenta valores más bajos al remover la tendencia, lo que indica que en este caso el semivariograma refleja de manera más adecuada la verdadera estructura espacial del fenómeno.\n\n\nVer código\nplot(vg1_O$u, vg1_O$n, type=\"b\",\n     xlab=\"distance\", ylab=\"n pairs\",\n     main=\"Número de pares por bin\")\n\n\n\n\n\n\n\n\n\n\n\n3.1.3 Estimación del Modelo Teórico de Semivariograma\n\n\n\n\n\n\nEn construcción\n\n\n\n\n\n\n\n\n3.1.4 Kriging\n\n\n\n\n\n\nEn construcción",
    "crumbs": [
      "Análisis Geoestadístico",
      "Análisis Univariado"
    ]
  }
]