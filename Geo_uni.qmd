---
title: "Análisis geoestadístico del ozono y la temperatura en California durante marzo de 2024"
lang: es
author: 
  - name: "Luna Katerin Díaz Casallas"
    email: "ldiazca@unal.edu.co"
  - name: "Camilo Alejandro Raba Gómez"
    email: "craba@unal.edu.co"
institute: "Departamento de Estadística - Universidad Nacional de Colombia"
date: today
format:
  html:
    toc: True
    toc-title: "Tabla de contenidos"
    toc-depth: 3  # Profundidad de los encabezados a enumerar
    number-sections: true  # Activa la numeración de secciones
    html-math-method: katex
    code-fold: true
    code-summary: "Ver código"
    link-external-newwindow: true
    css: styles.css
    theme:
      light: flatly
      dark: darkly
    include-after-body: footer.html
editor_options:
  chunk_output_type: console
bibliography: referencias.bib
nocite: '@*'
---

# Introducción

La calidad del aire es un factor clave para la salud pública, el bienestar social y la sostenibilidad ambiental, y California se destaca como uno de los estados más afectados de Estados Unidos por la contaminación atmosférica. La combinación de una alta densidad poblacional, una intensa actividad industrial y vehicular, junto con fenómenos naturales como los incendios forestales, ha hecho que varias de sus ciudades se ubiquen entre las más contaminadas del país. Al mismo tiempo, la temperatura cumple un papel fundamental en la dinámica atmosférica, ya que influye en la dispersión, concentración y formación de contaminantes, además de constituir en sí misma un aspecto crítico para comprender las condiciones ambientales regionales. Frente a este contexto, resulta necesario llevar a cabo un análisis geoespacial que considere tanto la calidad del aire como la temperatura en California, con el fin de identificar patrones espaciales, contrastes regionales y áreas críticas que permitan orientar acciones de mitigación y gestión ambiental.

# Descripción

Los datos objeto de este estudio provienen de la [Agencia de Protección Ambiental (EPA)](https://www.epa.gov/) de los Estados Unidos y corresponden a registros horarios obtenidos de las estaciones de monitoreo durante el mes de marzo de 2024. En partícular, se analizan las variables **Temperatura** y **Ozono (**$O_3$**)**.

## Unidades

-   *Temperatura:* Medido en grados celsius (C°) con una intensidad horaria.

-   *Ozono:* Medido en partes por billón (ppb) con una intensidad horaria.

```{r, warning=FALSE, message=F}
#Librerias necesarias
library(dplyr)
library(geoR)
library(sp)
library(readxl)
library(tidyr)
library(sf)
library(ggplot2)
library(knitr)
library(plotly)
library(leaflet)
library(raster)
library(stars)

#Carga de datos
Cali_Marz <- read.csv("AirNow_Marzo_California.csv", colClasses = c("AQSID"="character"))

Ozone <- Cali_Marz %>% filter(Variable=="OZONE") 
NO2 <- Cali_Marz %>% filter(Variable=="NO2")
Temp <- read.csv("Temperatura.csv", colClasses = c("AQSID"="character"))

Ozone <- Ozone %>% mutate(DateTime = paste(Date, Hour, sep = " "))
NO2 <- NO2 %>% mutate(DateTime = paste(Date, Hour, sep = " "))
Temp <- Temp[,-1]

#Para el mapa de California
sh_mundos<-st_read("admin00.shp",quiet=TRUE)
sh_mundos <- sh_mundos %>% filter(CNTRY_NAME=="United States")
sh_mundos <- sh_mundos %>% filter(ADMIN_NAME=="California")

#Datos de las estaciones
data <- read.csv("HourlyAQObs_2024010101.dat")
data <- data %>% filter(CountryCode=="US")
data <- data %>% filter(StateName=="CA")

CRS_UTM_NY = "+init=epsg:3310"

Ozone_Matrix <- Ozone %>%
  dplyr::select(DateTime, AQSID, Value) %>%
  pivot_wider(names_from = AQSID, values_from = Value) 

Temp_Matrix <- Temp %>%
  dplyr::select(DateTime, AQSID, Value) %>%
  pivot_wider(names_from = AQSID, values_from = Value) 

#Para el mapa

sh_mundos_wgs84 <- st_transform(sh_mundos, crs = 4326)

sh_mundos_utm <- st_transform(sh_mundos, crs = CRS("EPSG:3310"))

new <- sp::spsample(as(sh_mundos_utm, "Spatial"), n = 50000, type = "regular")

proj4string(new) <- CRS("EPSG:3310")
coordinates(new) ~ Este + Norte
colnames(new@coords) <- c("Este", "Norte")

sh_mundos_sp_utm <- as(sh_mundos_utm, "Spatial")

sh_mundos_utm_simple <- st_union(sh_mundos_utm)
sh_mundos_sp_utm_simple <- as(sh_mundos_utm_simple, "Spatial")

```

# Análisis geoestadístico univariado

## Variable Ozono

Se tomaron los datos de Temperatura de la madrugada el primero de marzo de 2024:

```{r}
EstacionesOz <- data %>% filter(AQSID %in% colnames(Ozone_Matrix)[-1])
EstacionesOz <- EstacionesOz[,c(1:10,13)]

est_sf_Oz <- st_as_sf(EstacionesOz, 
                   coords = c("Longitude", "Latitude"), 
                   crs = 4326)
est_sf_utm_O <- st_transform(est_sf_Oz, crs = 3310)
deci_coord_O = SpatialPoints(cbind(EstacionesOz$Longitude,
                                 EstacionesOz$Latitude),
                           proj4string = CRS("+proj=longlat"))
utm_coord_O = spTransform(deci_coord_O, CRS("EPSG:3310"))
utm_coord_df_O = as.data.frame(utm_coord_O)
EstacionesOz$x <- utm_coord_df_O$coords.x1
EstacionesOz$y <- utm_coord_df_O$coords.x2

y_oz <- Ozone_Matrix[1,] #Tomar una fecha
y_oz <- cbind(colnames(y_oz),t(y_oz[1,]))
y_oz <- y_oz[-1,]
y_oz <- as.data.frame(y_oz)
y_oz <- na.omit(y_oz)
y_oz <- inner_join(y_oz, EstacionesOz, by=c("V1"="AQSID"))
datosOZ <- y_oz[,c(13,14,2)] #Datos1 es la base con coordenadas + variable
colnames(datosOZ)=c("Este","Norte","Ozono")
datosOZ$Ozono <- as.numeric(datosOZ$Ozono)

coords_3310O <- st_coordinates(est_sf_utm_O)
est_sf_utm_O$Este <- coords_3310O[, "X"]
est_sf_utm_O$Norte <- coords_3310O[, "Y"]

datosO_sf_utm <- merge(est_sf_utm_O, y_oz[, c("V1", "V2")], by.x = "AQSID", by.y = "V1")
datosO_sf_utm$Ozono <- as.numeric(datosO_sf_utm$V2)

datosO_sf_wgs84 <- merge(est_sf_Oz, y_oz[, c("V1", "V2")], by.x = "AQSID", by.y = "V1")
datosO_sf_wgs84$Ozono <- as.numeric(datosO_sf_wgs84$V2)



palO <- colorNumeric(palette = "viridis", domain = datosO_sf_wgs84$Ozono)

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  # Contorno de California
  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = "black", weight = 2) %>%
  # Puntos de temperatura
  addCircleMarkers(data = datosO_sf_wgs84,
                   fillColor = ~palO(Ozono),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 6,
                   popup = ~paste("Ozono:", Ozono, "°C")) %>%
  addLegend(pal = palO, values = datosO_sf_wgs84$Ozono, title = "Ozono (ppb)")

ozone <- as.geodata(datosOZ) 
summary(ozone)

```

::: panel-tabset
### Gráficos de dispersión

```{r}
par(mfrow=c(1,2))

plot(Ozono~Este, data = datosOZ, ylab = "Ozono", xlab="Este")
plot(Ozono~Norte, data = datosOZ, ylab = "Ozono", xlab="Norte")
```

### GeoR

```{r}
plot(ozone, qt.col = c("purple",
                          "pink",
                          "green",
                          "yellow"),
     scatter3d=T)
```
:::

El gráfico muestra una relación polinomial de la variable Ozono con respecto a las coordenadas en Norte. Se prueba con varios modelos hasta encontrar aquel que mitigue el efecto espacial.

### Modelo de tendencia espacial

El modelo que mejor atrapa el efecto de la media es:

$$Ozono = \beta_0+\beta_1 \times Norte^2 + \beta_2 \times Norte^3 + \beta_3 \times Este$$

```{r}
fitO <- lm(Ozono~I(Norte^2)+I(Norte^3)+Este, data = datosOZ) 
summary(fitO)
```

Gráficamente se observa una mitigación en la tendencia espacial:

::: panel-tabset
#### Gráficos de dispersión

```{r}
datosOZ$Residuos <- fitO$residuals

par(mfrow=c(1,2))
plot(Residuos~Este, data = datosOZ, xlab="Este", ylab="Residuos")
plot(Residuos~Norte, data = datosOZ, xlab="Norte", ylab="Residuos")
```

#### GeoR

```{r}
plot(ozone, qt.col = c("purple",
                          "pink",
                          "green",
                          "yellow"),
     scatter3d=T, trend = ~ poly(Norte,3))
```
:::

### Estimación empírica del semivariograma

A continuación, se presenta la estimación del semivariograma obtenida con la función variog. Se muestran dos gráficos comparativos: el primero corresponde a los datos originales (sin eliminar la tendencia) y el segundo a los residuales obtenidos tras ajustar el modelo de regresión, lo que permite observar el efecto de remover la tendencia en la estructura espacial.

```{r, message=FALSE}
vg_O <- variog(ozone,estimator.type = "modulus", pairs.min=50) #Sin tendencia espacial
vg1_O <- variog(ozone, trend = ~I(Norte^2)+I(Norte^3)+Este, estimator.type = "modulus", pairs.min=50)
```

::: panel-tabset
#### Con tendencia

```{r}
plot(vg_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Sin remover tendencia",
     col.main = 4, cex.main =1.3)
```

#### Removiendo Tendencia

```{r}
plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Removiendo tendencia",
     col.main = 4, cex.main =1.3)
```
:::

Se observa que la estimación de la semivarianza de la variable incrementos es más estable y presenta valores más bajos al remover la tendencia, lo que indica que en este caso el semivariograma refleja de manera más adecuada la verdadera estructura espacial del fenómeno.

```{r}
plot(vg1_O$u, vg1_O$n, type="b",
     xlab="distance", ylab="n pairs",
     main="Número de pares por bin")
```

### Estimación del Modelo Teórico de Semivariograma

Los modelos obtenidos ajustanto por EyeFit, son:

``` text
cov.model sigmasq      phi tausq kappa kappa2 practicalRange
1    matern    17.0 440676.0     5   0.5     NA        1320147
2  gneiting    17.5 803585.6     9    NA     NA        1371348
3    linear    0.25 0.32     0    NA     NA            Inf
```
::: panel-tabset

#### Matern

```{r}
#| message: false
#| warning: false
#| results: 'hide'

sigma_0_mO <- 17.0
phi_0_mO <- 440676.0
nugget_0_mO <- 5
kappa_0_mO <- 0.5

ini1_mat_O <- c(sigma_0_mO, phi_0_mO)
fitvar1_mat_O <- variofit(vg1_O,
                    cov.model = "matern",
                    ini1_mat_O,
                    fix.nugget = F,
                    nugget = nugget_0_mO,
                    kappa = kappa_0_mO,
                    wei = "equal")

fitvar2_mat_O <- variofit(vg1_O,
                    cov.model = "matern",
                    ini1_mat_O,
                    fix.nugget = F,
                    nugget = nugget_0_mO,
                    kappa = kappa_0_mO,
                    wei = "npairs")

fitvar3_mat_O <- variofit(vg1_O,
                    cov.model = "matern",
                    ini1_mat_O,
                    fix.nugget = F,
                    nugget = nugget_0_mO,
                    kappa = kappa_0_mO,
                    wei = "cressie")

fitvar4_mat_O <- likfit(ozone,
                  coords = ozone$coords,
                  data = ozone$data,
                  trend = ~ I(Norte^2) + I(Norte^3) + Este,
                  ini.cov.pars = ini1_mat_O,
                  fix.nugget = F,
                  nugget = nugget_0_mO,
                  kappa = kappa_0_mO,
                  cov.model = "matern",
                  lik.method = "ML")


plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_mat_O, col="#FF4040", lwd=1.5)
lines(fitvar2_mat_O, col="#4169E1", lwd=1.5)
lines(fitvar3_mat_O, col="#008B00", lwd=1.5)
lines(fitvar4_mat_O, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)
```

#### Gneiting

```{r}
#| message: false
#| warning: false
#| results: 'hide'

sigma_0_gO <- 17.5
phi_0_gO <- 803585.6
nugget_0_gO <- 9

ini1_g_O <- c(sigma_0_gO, phi_0_gO)
fitvar1_g_O <- variofit(vg1_O,
                    cov.model = "gneiting",
                    ini1_g_O,
                    fix.nugget = F,
                    nugget = nugget_0_gO,
                    wei = "equal")

fitvar2_g_O <- variofit(vg1_O,
                    cov.model = "gneiting",
                    ini1_g_O,
                    fix.nugget = F,
                    nugget = nugget_0_gO,
                    wei = "npairs")

fitvar3_g_O <- variofit(vg1_O,
                    cov.model = "gneiting",
                    ini1_g_O,
                    fix.nugget = F,
                    nugget = nugget_0_gO,
                    wei = "cressie")

fitvar4_g_O <- likfit(ozone,
                  coords = ozone$coords,
                  data = ozone$data,
                  trend = ~ I(Norte^2) + I(Norte^3) + Este,
                  ini.cov.pars = ini1_g_O,
                  fix.nugget = F,
                  nugget = nugget_0_gO,
                  cov.model = "gneiting",
                  lik.method = "ML")


plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_g_O, col="#FF4040", lwd=1.5)
lines(fitvar2_g_O, col="#4169E1", lwd=1.5)
lines(fitvar3_g_O, col="#008B00", lwd=1.5)
lines(fitvar4_g_O, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)
```

#### Lineal

```{r}
#| message: false
#| warning: false
#| results: 'hide'

sigma_0_lO <- 0.25
phi_0_lO <- 0.32
nugget_0_lO <- 0

ini1_l_O <- c(sigma_0_lO, phi_0_lO)
fitvar1_l_O <- variofit(vg1_O,
                    cov.model = "linear",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "equal")

fitvar2_l_O <- variofit(vg1_O,
                    cov.model = "linear",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "npairs")

fitvar3_l_O <- variofit(vg1_O,
                    cov.model = "linear",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "cressie")

fitvar4_l_O <- likfit(ozone,
                  coords = ozone$coords,
                  data = ozone$data,
                  trend = ~ I(Norte^2) + I(Norte^3) + Este,
                  ini.cov.pars = ini1_l_O,
                  fix.nugget = F,
                  nugget = nugget_0_lO,
                  cov.model = "linear",
                  lik.method = "ML")


plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_l_O, col="#FF4040", lwd=1.5)
lines(fitvar2_l_O, col="#4169E1", lwd=1.5)
lines(fitvar3_l_O, col="#008B00", lwd=1.5)
lines(fitvar4_l_O, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

```


:::

### Kriging

```{r, message=F, warning=F}

#| message: false
#| warning: false
#| results: 'hide'

best_model_O <- gstat::vgm(psill = fitvar1_mat_O$cov.pars[1],
                           model = "Mat",
                           range = fitvar1_mat_O$cov.pars[2],
                           nugget = fitvar1_mat_O$nugget,
                           kappa = fitvar1_mat_O$kappa
                           
)

coordinates(datosOZ) <- ~Este + Norte
proj4string(datosOZ) <- CRS("EPSG:3310")

g_obj<-gstat::gstat(id="Ozono",
             formula = Ozono ~ I(Norte^2) + I(Norte^3) + Este,
             model = best_model_O,
             data = datosOZ)

predic <- predict(g_obj, newdata = new, nmin = 12, maxdist=fitvar3_mat_O$cov.pars[2])

prediction <- data.frame(predic)

#Mapas de predicción

gridded(predic) <- TRUE

#1. Mapa de Kriging

predic_raster_utm <- raster(predic, layer = "Ozono.pred")

# 2. Asegurarse de que el CRS del ráster se asigne correctamente (EPSG:3310)
crs(predic_raster_utm) <- "+init=epsg:3310"

predic_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        predic_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

bins <- seq(15,55, by=5)

pred_range <- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))
pal_pred <- colorBin(
  palette = "viridis", # La paleta de colores
  domain = pred_range,
  bins = bins,
  na.color = "transparent"
)

mapa_kriging_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  
  # Añadir la capa ráster de Predicción Kriging
  addRasterImage(
    predic_raster_wgs84, # Usamos el objeto raster reproyectado
    colors = pal_pred, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
    addCircleMarkers(data = datosO_sf_wgs84,
                   fillColor = ~palO(Ozono),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 6,
                   popup = ~paste("Ozn:", Ozono, "ppb")) %>% 
  
  addLegend(
    pal = pal_pred, 
    values = pred_range,
    title = "Predicción Oz ppb",
    position = "topright"
  ) %>%
  
  addLegend(pal = palO,
            values = datosO_sf_wgs84$Ozono,
            title = "Ozono Observado",
    position = "topleft"
  ) 

#2 Mapa Varianza------------------------------------------

var_raster_utm <- raster(predic, layer = "Ozono.var")

# 2. Asegurarse de que el CRS del ráster se asigne correctamente (EPSG:3310)
crs(var_raster_utm) <- "+init=epsg:3310"

var_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        var_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

binsv <- seq(0,30, by=5)

var_range <- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))
pal_var <- colorBin(
  palette = "Spectral", # La paleta de colores
  domain = var_range,
  bins = binsv,
  na.color = "transparent"
)

mapa_var_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  
  # Añadir la capa ráster de Predicción Kriging
  addRasterImage(
    var_raster_wgs84, # Usamos el objeto raster reproyectado
    colors = pal_var, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_var, 
    values = var_range,
    title = "Varianza",
    position = "topright"
  ) 

#3. Mapa Cv ----------------------------------------------

cv_raster_utm <- sqrt(var_raster_utm) / abs(predic_raster_utm)

mapa_mayor_a_uno <- cv_raster_utm > 1
cv_raster_utm[mapa_mayor_a_uno] <- 1

crs(cv_raster_utm) <- "+init=epsg:3310"

cv_raster_masked_utm <- raster::mask(cv_raster_utm, sh_mundos_sp_utm_simple)

# 2. Aplicar CROP (Recorte físico del rectángulo)
cv_raster_cropped_utm <- raster::crop(cv_raster_masked_utm, sh_mundos_sp_utm_simple)

# 3. Reproyectar el objeto MÁS PEQUEÑO a WGS84
cv_raster_wgs84 <- raster::projectRaster(
    cv_raster_cropped_utm, 
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

bincv <- seq(0,1, by=.1)

cv_range <- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))

pal_cv <- colorBin(
  palette = "RdYlGn", # Rojo-Amarillo-Verde
  domain = cv_range,
  na.color = "transparent",
  bins = bincv,
  reverse = TRUE # ¡Esto es CRUCIAL! Para que el Verde sea BAJA incertidumbre.
)

mapa_cv_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  
  # Añadir la capa ráster de Predicción Kriging
  addRasterImage(
    cv_raster_wgs84, # Usamos el objeto raster reproyectado
    colors = pal_cv, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  
  addLegend(
    pal = pal_cv, 
    values = cv_range,
    title = "Coeficiente de Variación",
    position = "topright"
  )
```

::: panel-tabset
#### Predicción

```{r}
mapa_kriging_leaflet
```

#### Varianza

```{r}
mapa_var_leaflet
```

#### Coeficiente de variación

```{r}
mapa_cv_leaflet
```

:::

## Variable Temperatura

Se tomaron los datos de Temperatura de la madrugada el primero de marzo de 2024:

```{r}
EstacionesT <- data %>% filter(AQSID %in% colnames(Temp_Matrix)[-1])
EstacionesT <- EstacionesT[,c(1:10,13)]

est_sf_T <- st_as_sf(EstacionesT, 
                      coords = c("Longitude", "Latitude"), 
                      crs = 4326)

est_sf_utm_T <- st_transform(est_sf_T, crs = 3310)
deci_coord_T = SpatialPoints(cbind(EstacionesT$Longitude,
                                 EstacionesT$Latitude),
                           proj4string = CRS("+proj=longlat"))
utm_coord_T = spTransform(deci_coord_T, CRS("EPSG:3310"))
utm_coord_df_T = as.data.frame(utm_coord_T)
EstacionesT$x <- utm_coord_df_T$coords.x1
EstacionesT$y <- utm_coord_df_T$coords.x2

y_T <- Temp_Matrix[1,] #Tomar una fecha
y_T <- cbind(colnames(y_T),t(y_T[1,]))
y_T <- y_T[-1,]
y_T <- as.data.frame(y_T)
y_T <- na.omit(y_T)
y_T <- y_T[-which.min(y_T$V2),]
y_T <- inner_join(y_T, EstacionesT, by=c("V1"="AQSID"))
datosT <- y_T[,c(13,14,2)] #Datos1 es la base con coordenadas + variable
colnames(datosT)=c("Este","Norte","Temperatura")
datosT$Temperatura <- as.numeric(datosT$Temperatura)

coords_3310 <- st_coordinates(est_sf_utm_T)
est_sf_utm_T$Este <- coords_3310[, "X"]
est_sf_utm_T$Norte <- coords_3310[, "Y"]


# 4. Crear el objeto final de datos (combinando temperatura con las coordenadas UTM)
datosT_sf_utm <- merge(est_sf_utm_T, y_T[, c("V1", "V2")], by.x = "AQSID", by.y = "V1")
datosT_sf_utm$Temperatura <- as.numeric(datosT_sf_utm$V2)

datosT_sf_wgs84 <- merge(est_sf_T, y_T[, c("V1", "V2")], by.x = "AQSID", by.y = "V1")
datosT_sf_wgs84$Temperatura <- as.numeric(datosT_sf_wgs84$V2)



pal <- colorNumeric(palette = "viridis", domain = datosT_sf_wgs84$Temperatura)

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  # Contorno de California
  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = "black", weight = 2) %>%
  # Puntos de temperatura
  addCircleMarkers(data = datosT_sf_wgs84,
                   fillColor = ~pal(Temperatura),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 6,
                   popup = ~paste("Temp:", Temperatura, "°C")) %>%
  addLegend(pal = pal, values = datosT_sf_wgs84$Temperatura, title = "Temperatura (°C)")

temp <- as.geodata(datosT) 
summary(temp)

```

::: panel-tabset
### Gráficos de dispersión

```{r}
par(mfrow=c(1,2))

plot(Temperatura~Este, data = datosT, ylab = "Temperatura", xlab="Este")
plot(Temperatura~Norte, data = datosT, ylab = "Temperatura", xlab="Norte")
```

### GeoR

```{r}
plot(temp, qt.col = c("purple",
                    "pink",
                    "green",
                    "yellow"),
     scatter3d=T)
```
:::

En el gráfico se observa un agrupamiento en las coordenadas Norte con respecto a los datos, que puede llegar a corregirse con algún polinomio. Se probará con diferentes modelos a ver si se puede llegar a disminuir el efecto espacial.

### Modelo de tendencia espacial

El modelo que mejor atrapa el efecto de la media es:

$$
Temperatura = \beta_0 + \beta_1 \times Norte + \beta_2 \times Norte^2
$$

```{r}
fitT <- lm(Temperatura~Norte+I(Norte^2), data = datosT) 
summary(fitT)
```

Observamos el comportamiento de sus residuales podemos notar que el modelo ayudo a reducir el efecto espacial.

::: panel-tabset
#### Gráficos de dispersión

```{r}
datosT$Residuos <- fitT$residuals
par(mfrow=c(1,2))
plot(Residuos~Este, data = datosT, xlab="Este", ylab="Residuos")
plot(Residuos~Norte, data = datosT, xlab="Norte", ylab="Residuos")
```

#### GeoR

```{r}
plot(temp, qt.col = c("purple",
                    "pink",
                    "green",
                    "yellow"),
     scatter3d=T, trend=~Norte+I(Norte^2))
```
:::

### Estimación empírica del semivariograma

p¿Presentamos la estimación del semivariograma obtenida mediante la función variog para la variable temperatura. Se comparan los resultados al calcularlo directamente sobre los datos originales (sin remover la tendencia) y al utilizar los residuales de un modelo de regresión, con el objetivo de analizar cómo influye la presencia de tendencia en la estructura espacial.

```{r}
vg_T <- variog(temp, estimator.type = "modulus", pairs.min=50) #Sin tendencia espacial
vg1_T <- variog(temp, trend = ~Norte+I(Norte^2),
                estimator.type = "modulus", pairs.min=50)

```

::: panel-tabset
#### Con tendencia

```{r}
plot(vg_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Sin remover tendencia",
     col.main = 4, cex.main =1.3)
```

#### Removiendo tendencia

```{r}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Removiendo tendencia",
     col.main = 4, cex.main =1.3)
```
:::

Cuando no se remueve la tendencia, la semivarianza alcanza valores más altos y presenta una forma aparentemente más regular, aunque dicha regularidad está influenciada por la tendencia global de los datos. En cambio, al eliminar la tendencia, los valores de semivarianza disminuyen y el patrón pierde suavidad, pero el variograma refleja con mayor fidelidad la verdadera dependencia espacial.

```{r}
plot(vg1_T$u, vg1_T$n, type="b",
     xlab="distance", ylab="n pairs",
     main="Número de pares por bin")
```

En este caso, el último punto corresponde a menos de 25 pares de observaciones, por lo que su interpretación resulta menos confiable.

### Estimación del Modelo Teórico de Semivariograma

```{r}


dist_matrix_T <- as.matrix(dist(temp$coords))

#1. Funciones de correlación, covarianza y semivarianza: ----

#1.1 Modelo exponencial ----

rho_exp <- function(h, phi){
  exp(-(h/phi)) #Correlacion espacial
}

cov_exp <- function(sigma, h, phi){
  sigma*rho_exp(h, phi) #Covarianza espacial
}

sv_exp <- function(nugget, sigma, h, phi){
  nugget + sigma - cov_exp(sigma, h, phi) #Semivarianza espacial
} 

#1.2 Modelo Gaussianio ----

rho_gauss <- function(h, phi){
  exp(-(h/phi)^2)
}

cov_gauss <- function(sigma, h, phi){
  sigma*rho_gauss(h, phi) #Covarianza espacial
}

sv_gauss <- function(nugget, sigma, h, phi){
  nugget + sigma - cov_gauss(sigma, h, phi) #Semivarianza espacial
}
#1.3 Modelo Gneting ----

cov_gneiting <- function(h){
  s <- 0.301187465825
  ifelse(0<= s*h &  s*h <= 1,
  (1 + 8*s*h + 25*(s*h)^2 + 32*(s*h)^3) * (1-s*h)^8,
  0)
}

sv_gneiting <- function(nugget, sigma, h){
  nugget + sigma - cov_gneiting(h) #Semivarianza espacial
}

#1.4 Modelo Spherical ----

rho_spherical <- function(h, phi){
  ifelse(h<phi,
         1 - 1.5*(h/phi) + 0.5*(h/phi)^3,
         0)
}

cov_spherical <- function(sigma, h, phi){
  sigma*rho_spherical(h, phi) #Covarianza espacial
}

sv_spherical <- function(nugget, sigma, h, phi){
  nugget + sigma - cov_spherical(sigma, h, phi) #Semivarianza espacial
}

#1.5 Modelo Matern ----

rho_matern <- function(h, phi, kappa){
  (1/(2*gamma(kappa))) * (h/phi)^kappa * besselK((h/phi), kappa)
}

cov_matern <- function(sigma, h, phi, kappa){
  sigma*rho_matern(h, phi, kappa) #Covarianza espacial
}

sv_matern <- function(nugget, sigma, h, phi, kappa){
  nugget + sigma - cov_matern(sigma, h, phi, kappa) #Semivarianza espacial
}

#2. Función para estimar por WLS----

MSE_ponderados <- function(par, h, gamma,kappa=NA,w, model, n, pesos){
  nugget <- par[1]
  sigma <- par[2]
  phi <- par[3]
  
  gamma_hat <- switch(model,
                      "exponencial" = sv_exp(nugget, sigma, h, phi),
                      "gaussian"    = sv_gauss(nugget, sigma, h, phi),
                      "gneiting"    = sv_gneiting(nugget, sigma, h, phi),
                      "spherical"   = sv_spherical(nugget, sigma, h, phi),
                      "matern"      = sv_matern(nugget, sigma, h, phi, kappa)
  )
  
  w <- switch(pesos,
              "Cressie" = 1/(2*(2*gamma_hat)^2/n),
              "n" = 1/n,
              "h/n" = 1/(h/n),
              "I" = 1)
  
  sum(w*(gamma - gamma_hat)^2)
}

est_sev_WLS <- function(par, kappa = NA, model, h, gamma, n){
  sigma_0 <- par[1]
  phi_0 <- par[2]
  nugget_0 <- par[3]
  kappa_0 <- kappa
  
  # Selección de función
  sv <- switch(model,
               "exponencial" = sv_exp,
               "gaussian"    = sv_gauss,
               "spherical"   = sv_spherical,
               "gneiting"    = sv_gneiting,
               "matern"      = sv_matern
  )
  
  args_sv <- names(formals(sv))
  
  args_list <- list(
    nugget = nugget_0,
    sigma  = sigma_0,
    h      = h,
    phi    = phi_0,
    kappa  = kappa_0
  )
  
  args_list <- args_list[names(args_list) %in% args_sv]
  
  sv_ini <- do.call(sv, args_list)
  
  formula_sv <- switch(model,
                       "gneiting" = gamma ~ sv(nugget, sigma, h),
                       "matern" = gamma ~ sv(nugget, sigma, h, phi, kappa),
                       gamma ~ sv(nugget, sigma, h, phi)
  )
  
  start_list <- switch(model,
                       "gneting" = list(nugget = nugget_0, sigma = sigma_0),
                       "matern" = list(nugget = nugget_0, sigma = sigma_0, phi = phi_0, kappa = kappa_0),
                       list(nugget = nugget_0, sigma = sigma_0, phi = phi_0)
  )
    
    #1. Ponderación de Bessel
    
    WW <- (2*(2*sv_ini)^2/n)
    
    Bessel <- nls(formula = formula_sv,
                  start = start_list,
                  weights = 1/WW,
                  control = nls.control(maxiter = 500, warnOnly = TRUE))
    
    ini_Bessel<-coef(Bessel)
    
    #1.1 Optim Bessel
    
    optim_bessel <- optim(
      par = coef(Bessel),
      fn = MSE_ponderados,
      h = h,
      gamma = gamma,
      pesos = "Cressie",
      model = model,
      n = n,
      method = "L-BFGS-B",
      lower = c(0, 0, 0)
    )
    
    par_optim_Bess <- optim_bessel$par[c("nugget", "sigma", "phi")]
    
    #2. Ponderación 1/n
    
    W1 <- n
    
    n_pond <- nls(formula = formula_sv,
                  start = start_list,
                  weights = 1/W1,
                  control = nls.control(maxiter = 500, warnOnly = TRUE))
    
    ini_n<-coef(n_pond)
    
    #2.1 Optimización 1/n
    
    optim_n <- optim(
      par = coef(n_pond),
      fn = MSE_ponderados,
      h = h,
      gamma = gamma,
      pesos = "n",
      n = n,
      model = model,
      method = "L-BFGS-B",
      lower = c(0, 0, 0)
    )    
    
    par_optim_n <- optim_n$par[c("nugget", "sigma", "phi")]
    
    
    #3. Ponderación h/n
    
    W2 <- h/n
    
    h_n_pond <- nls(formula = formula_sv,
                    start = start_list,
                    weights = 1/W2,
                    control = nls.control(maxiter = 500, warnOnly = TRUE))
    
    ini_h_n<-coef(h_n_pond)
    
    optim_h_n <- optim(
      par = coef(h_n_pond),
      fn = MSE_ponderados,
      h = h,
      gamma = gamma,
      pesos = "h/n",
      model = model,
      n = n,
      method = "L-BFGS-B",
      lower = c(0, 0, 0)
    )    
    
    par_optim_h_n <- optim_h_n$par[c("nugget", "sigma", "phi")]
    

res <- list(Bessel = list(Iniciales = ini_Bessel,
                           Optimizados = par_optim_Bess),
            `1/n` = list(Iniciales = ini_n,
                          Optimizados = par_optim_n),
            `h/n` = list(Iniciales = ini_h_n,
                          Optimizados = par_optim_h_n))    
return(res)
}

MSE_sv <- function(gamma_hat, par, kappa, model, h){
  sigma_0 <- par[[2]]
  phi_0 <- par[[3]]
  nugget_0 <- par[[1]]
  kappa_0 <- kappa
  
  sv <- switch(model,
               "exponencial" = sv_exp,
               "gaussian"    = sv_gauss,
               "spherical"   = sv_spherical,
               "gneiting"    = sv_gneiting,
               "matern"      = sv_matern
  )
  
  args_sv <- names(formals(sv))
  
  args_list <- list(
    nugget = nugget_0,
    sigma  = sigma_0,
    h      = h,
    phi    = phi_0,
    kappa  = kappa_0
  )
  
  args_list <- args_list[names(args_list) %in% args_sv]
  
  sv_est <- do.call(sv, args_list)
  
  return(mean((sv_est-gamma_hat)^2))
}

#3. Función para etimar por máxima verosimilitud

loglik <- function(par, kappa=NA, z, dist_matrix, model){
  sigma_0 <- par[1]
  phi_0 <- par[2]
  nugget_0 <- par[3]
  kappa_0 <- kappa
  
  cov <- switch(model,
               "exponencial" = cov_exp,
               "gaussian"    = cov_gauss,
               "spherical"   = cov_spherical,
               "gneiting"    = cov_gneiting,
               "matern"      = cov_matern
  )
  
  args_cov <- names(formals(cov))
  
  args_list <- list(
    sigma  = sigma_0,
    nugget = nugget_0,
    h      = dist_matrix,
    phi    = phi_0,
    kappa  = kappa_0
  )
  
  args_list <- args_list[names(args_list) %in% args_cov]
  
  Sigma <- do.call(cov, args_list) 
  diag(Sigma) = diag(Sigma) + nugget_0
  
  # Descomposición de Cholesky (más estable que solve o det)
  inv_Sigma <- solve(Sigma)
  det <- log(det(Sigma))
  
  # Log-verosimilitud del modelo Gaussiano
  z <- z 
  n <- length(z)
  ll <- -0.5 * (n * log(2 * pi) + det + crossprod(z, inv_Sigma %*% z))  # Log-verosimilitud (negativa porque optim minimiza)
  return(-ll)
}

```

Los modelos obtenidos ajustanto por EyeFit, son:

``` text

cov.model sigmasq      phi tausq kappa kappa2 practicalRange
1 exponential   10.74 109166.3  2.07    NA     NA       327033.0
2    gaussian   10.00  80000.0  2.07    NA     NA       138465.5
3   spherical   10.00 157832.8  2.07    NA     NA       157832.8
```

```{r}

variog_T <- data.frame(h = vg1_T$u, gamma_hat = vg1_T$v,
                       n = vg1_T$n)

range_sv_T <- seq(1,max(variog_T$h), by=1000)

# Modelo exponencial ----

sigma_0_eT <- 10.74
phi_0_eT <- 109166.3
nugget_0_eT <- 2.07

par_eT <- c(sigma_0_eT, phi_0_eT, nugget_0_eT)

res_e_T <- est_sev_WLS(par=par_eT, kappa = NA,
                       model="exponencial",
                       h=variog_T$h,
                       gamma = variog_T$gamma_hat,
                       n = variog_T$n)

MLE_eT <- optim(fn = loglik,
             par = par_eT,
             kappa=NA,
             z = datosT$Residuos, 
             dist_matrix=dist_matrix_T,
             model = "exponencial",
             method = "L-BFGS-B",
             lower = c(0, 0, 0))

estsv_exp_Bess_T <- do.call(sv_exp, c(as.list(res_e_T$Bessel$Optimizados), list(h = range_sv_T)))
estsv_exp_n_T <- do.call(sv_exp, c(as.list(res_e_T$`1/n`$Optimizados), list(h = range_sv_T)))
estsv_exp_h_n_T <- do.call(sv_exp, c(as.list(res_e_T$`h/n`$Optimizados), list(h = range_sv_T)))
estsv_exp_MLE_T <- do.call(sv_exp, c(list(nugget = MLE_eT$par[3], phi = MLE_eT$par[2] , sigma = MLE_eT$par[1],h = range_sv_T)))

# Modelo Gaussiano ----

sigma_0_gT <- 10.00    
phi_0_gT <- 80000.0
nugget_0_gT <- 2.07

par_gT <- c(sigma_0_gT, phi_0_gT, nugget_0_gT)

res_g_T <- est_sev_WLS(par=par_gT, kappa = NA,
                       model="gaussian",
                       h=variog_T$h,
                       gamma = variog_T$gamma_hat,
                       n = variog_T$n)

estsv_g_Bess_T <- do.call(sv_gauss, c(as.list(res_g_T$Bessel$Optimizados), list(h = range_sv_T)))
estsv_g_n_T <- do.call(sv_gauss, c(as.list(res_g_T$`1/n`$Optimizados), list(h = range_sv_T)))
estsv_g_h_n_T <- do.call(sv_gauss, c(as.list(res_g_T$`h/n`$Optimizados), list(h = range_sv_T)))

# Modelo esférico

sigma_0_esT <- 10.00   
phi_0_esT <- 157832.8
nugget_0_esT <- 2.07

par_esT <- c(sigma_0_esT, phi_0_esT, nugget_0_esT)

res_es_T <- est_sev_WLS(par=par_esT, kappa = NA,
                       model="spherical",
                       h=variog_T$h,
                       gamma = variog_T$gamma_hat,
                       n = variog_T$n)

MLE_esT <- optim(fn = loglik,
             par = par_esT,
             kappa=NA,
             z = datosT$Residuos, 
             dist_matrix=dist_matrix_T,
             model = "spherical",
             method = "L-BFGS-B",
             lower = c(0, 0, 0))


estsv_es_Bess_T <- do.call(sv_spherical, c(as.list(res_es_T$Bessel$Optimizados), list(h = range_sv_T)))
estsv_es_n_T <- do.call(sv_spherical, c(as.list(res_es_T$`1/n`$Optimizados), list(h = range_sv_T)))
estsv_es_h_n_T <- do.call(sv_spherical, c(as.list(res_es_T$`h/n`$Optimizados), list(h = range_sv_T)))
estsv_es_MLE_T <- do.call(sv_spherical, c(list(nugget = MLE_esT$par[3], phi = MLE_esT$par[2] , sigma = MLE_esT$par[1],h = range_sv_T)))

```

:::::: panel-tabset
#### Exponencial

::: panel-tabset
##### Optim

```{r}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (optim)",
     col.main = "#36648B", cex.main =1.3)
lines(range_sv_T, estsv_exp_Bess_T, col="#FF4040", lwd=1.5)
lines(range_sv_T, estsv_exp_n_T, col="#4169E1", lwd=1.5)
lines(range_sv_T, estsv_exp_h_n_T, col="#008B00", lwd=1.5)
lines(range_sv_T, estsv_exp_MLE_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("Cressie", "1/n", "n/h", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

resumen_exp_T <- cbind(
  c("Cressie", "$$1/n$$", "$$n/h$$", "MLE"),
  rbind(
    t(res_e_T$Bessel$Optimizados),
    t(res_e_T$`1/n`$Optimizados),
    t(res_e_T$`h/n`$Optimizados),
    MLE_eT$par[c(3,1,2)]
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, res_e_T$Bessel$Optimizados, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_e_T$`1/n`$Optimizados, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_e_T$`h/n`$Optimizados, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, list(nugget = MLE_eT$par[3], phi = MLE_eT$par[2] , sigma = MLE_eT$par[1]), NA, model = "exponencial", variog_T$h)
  )
)

resumen_exp_T <- as.data.frame(resumen_exp_T)
resumen_exp_T[ , -1] <- lapply(resumen_exp_T[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_exp_T, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)
```

##### GeoR

```{r}
#| message: false
#| warning: false
#| results: 'hide'
ini1_exp_T <- c(sigma_0_eT, phi_0_eT)
fitvar1_exp_T <- variofit(vg1_T,
                    cov.model = "exponential",
                    ini1_exp_T,
                    fix.nugget = F,
                    nugget = nugget_0_eT,
                    wei = "equal")

fitvar2_exp_T <- variofit(vg1_T,
                    cov.model = "exponential",
                    ini1_exp_T,
                    fix.nugget = F,
                    nugget = nugget_0_eT,
                    wei = "npairs")

fitvar3_exp_T <- variofit(vg1_T,
                    cov.model = "exponential",
                    ini1_exp_T,
                    fix.nugget =F,
                    nugget = nugget_0_eT,
                    wei = "cressie")

fitvar4_exp_T <- likfit(temp,
                  coords = temp$coords,
                  data = temp$data,
                  trend = ~ poly(Norte, 2, raw = FALSE),
                  ini.cov.pars = ini1_exp_T,
                  fix.nugget = F,
                  nugget = nugget_0_eT,
                  cov.model = "exponential",
                  lik.method = "ML")


plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_exp_T, col="#FF4040", lwd=1.5)
lines(fitvar2_exp_T, col="#4169E1", lwd=1.5)
lines(fitvar3_exp_T, col="#008B00", lwd=1.5)
lines(fitvar4_exp_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

```

```{r}

par1Texp <- c(fitvar1_exp_T$nugget, fitvar1_exp_T$cov.pars[1], fitvar1_exp_T$cov.pars[2])
par2Texp <- c(fitvar2_exp_T$nugget, fitvar2_exp_T$cov.pars[1], fitvar2_exp_T$cov.pars[2])
par3Texp <- c(fitvar3_exp_T$nugget, fitvar3_exp_T$cov.pars[1], fitvar3_exp_T$cov.pars[2])
par4Texp <- c(fitvar4_exp_T$nugget, fitvar4_exp_T$cov.pars[1], fitvar4_exp_T$cov.pars[2])

resumen_exp_T2 <- cbind(
  c("MCO", "$$1/n$$", "$$Cressie$$","MLE"),
  rbind(
    par1Texp,
    par2Texp,
    par3Texp,
    par4Texp
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, par1Texp, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par2Texp, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par3Texp, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par4Texp, NA, model = "exponencial", variog_T$h)
  )
)

resumen_exp_T2 <- as.data.frame(resumen_exp_T2)
resumen_exp_T2[ , -1] <- lapply(resumen_exp_T2[ , -1], function(x) round(as.numeric(x), 3))
kable(resumen_exp_T2, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)

```
:::

#### Gaussiano

::: panel-tabset
##### Optim

```{r}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (optim)",
     col.main = "#36648B", cex.main =1.3)
lines(range_sv_T, estsv_g_Bess_T, col="#FF4040", lwd=1.5)
lines(range_sv_T, estsv_g_n_T, col="#4169E1", lwd=1.5)
lines(range_sv_T, estsv_g_h_n_T, col="#008B00", lwd=1.5)
legend("topleft",
       c("Cressie", "1/n", "n/h"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00"),
       cex=1,
       seg.len = .5)

resumen_g_T <- cbind(
  c("Cressie", "$$1/n$$", "$$n/h$$"),
  rbind(
    t(res_g_T$Bessel$Optimizados),
    t(res_g_T$`1/n`$Optimizados),
    t(res_g_T$`h/n`$Optimizados)
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, res_g_T$Bessel$Optimizados, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_g_T$`1/n`$Optimizados, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_g_T$`h/n`$Optimizados, NA, model = "gaussian", variog_T$h)
  )
)

resumen_g_T <- as.data.frame(resumen_g_T)
resumen_g_T[ , -1] <- lapply(resumen_g_T[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_g_T, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F)

```

##### GeoR

```{r}
#| message: false
#| warning: false
#| results: 'hide'
#| 
ini1_g_T <- c(sigma_0_gT, phi_0_gT)
fitvar1_g_T <- variofit(vg1_T,
                    cov.model = "gaussian",
                    ini1_g_T,
                    fix.nugget = F,
                    nugget = nugget_0_gT,
                    wei = "equal")

fitvar2_g_T <- variofit(vg1_T,
                    cov.model = "gaussian",
                    ini1_g_T,
                    fix.nugget = F,
                    nugget = nugget_0_gT,
                    wei = "npairs")

fitvar3_g_T <- variofit(vg1_T,
                    cov.model = "gaussian",
                    ini1_g_T,
                    fix.nugget = F,
                    nugget = nugget_0_gT,
                    wei = "cressie")

fitvar4_g_T <- likfit(temp,
                  coords = temp$coords,
                  data = temp$data,
                  trend = ~ poly(Norte, 2, raw = FALSE),
                  ini.cov.pars = ini1_g_T,
                  fix.nugget = F,
                  nugget = nugget_0_gT,
                  cov.model = "gaussian",
                  lik.method = "ML")


plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_g_T, col="#FF4040", lwd=1.5)
lines(fitvar2_g_T, col="#4169E1", lwd=1.5)
lines(fitvar3_g_T, col="#008B00", lwd=1.5)
lines(fitvar4_g_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)
```

```{r}
par1Tg <- c(fitvar1_g_T$nugget, fitvar1_g_T$cov.pars[1], fitvar1_g_T$cov.pars[2])
par2Tg <- c(fitvar2_g_T$nugget, fitvar2_g_T$cov.pars[1], fitvar2_g_T$cov.pars[2])
par3Tg <- c(fitvar3_g_T$nugget, fitvar3_g_T$cov.pars[1], fitvar3_g_T$cov.pars[2])
par4Tg <- c(fitvar4_g_T$nugget, fitvar4_g_T$cov.pars[1], fitvar4_g_T$cov.pars[2])

resumen_g_T2 <- cbind(
  c("MCO", "$$1/n$$", "$$Cressie$$","MLE"),
  rbind(
    par1Tg,
    par2Tg,
    par3Tg,
    par4Tg
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, par1Tg, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par2Tg, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par3Tg, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par4Tg, NA, model = "gaussian", variog_T$h)
  )
)

resumen_g_T2 <- as.data.frame(resumen_g_T2)
resumen_g_T2[ , -1] <- lapply(resumen_g_T2[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_g_T2, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)
```
:::

#### Esférico

::: panel-tabset
##### Optim

```{r}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (optim)",
     col.main = "#36648B", cex.main =1.3)
lines(range_sv_T, estsv_es_Bess_T, col="#FF4040", lwd=1.5)
lines(range_sv_T, estsv_es_n_T, col="#4169E1", lwd=1.5)
lines(range_sv_T, estsv_es_h_n_T, col="#008B00", lwd=1.5)
lines(range_sv_T, estsv_es_MLE_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("Cressie", "1/n", "n/h", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

resumen_es_T <- cbind(
  c("Cressie", "$$1/n$$", "$$n/h$$","MLE"),
  rbind(
    t(res_es_T$Bessel$Optimizados),
    t(res_es_T$`1/n`$Optimizados),
    t(res_es_T$`h/n`$Optimizados),
    MLE_esT$par[c(3,1,2)]
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, res_es_T$Bessel$Optimizados, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_es_T$`1/n`$Optimizados, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_es_T$`h/n`$Optimizados, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, list(nugget = MLE_esT$par[3], phi = MLE_esT$par[2] , sigma = MLE_esT$par[1]), NA, model = "spherical", variog_T$h)
  )
)

resumen_es_T <- as.data.frame(resumen_es_T)
resumen_es_T[ , -1] <- lapply(resumen_es_T[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_es_T, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F)
```

##### GeoR

```{r}
#| message: false
#| warning: false
#| results: 'hide'
#| 
ini1_es_T <- c(sigma_0_esT, phi_0_esT)
fitvar1_es_T <- variofit(vg1_T,
                    cov.model = "spherical",
                    ini1_es_T,
                    fix.nugget = F,
                    nugget = nugget_0_esT,
                    wei = "equal")

fitvar2_es_T <- variofit(vg1_T,
                    cov.model = "spherical",
                    ini1_es_T,
                    fix.nugget = F,
                    nugget = nugget_0_esT,
                    wei = "npairs")

fitvar3_es_T <- variofit(vg1_T,
                    cov.model = "spherical",
                    ini1_es_T,
                    fix.nugget = F,
                    nugget = nugget_0_esT,
                    wei = "cressie")

fitvar4_es_T <- likfit(temp,
                  coords = temp$coords,
                  data = temp$data,
                  trend = ~ poly(Norte, 2, raw = FALSE),
                  ini.cov.pars = ini1_es_T,
                  fix.nugget = F,
                  nugget = nugget_0_esT,
                  cov.model = "spherical",
                  lik.method = "ML")


plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_es_T, col="#FF4040", lwd=1.5)
lines(fitvar2_es_T, col="#4169E1", lwd=1.5)
lines(fitvar3_es_T, col="#008B00", lwd=1.5)
lines(fitvar4_es_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)



```

```{r}

par1Tes <- c(fitvar1_es_T$nugget, fitvar1_es_T$cov.pars[1], fitvar1_es_T$cov.pars[2])
par2Tes <- c(fitvar2_es_T$nugget, fitvar2_es_T$cov.pars[1], fitvar2_es_T$cov.pars[2])
par3Tes <- c(fitvar3_es_T$nugget, fitvar3_es_T$cov.pars[1], fitvar3_es_T$cov.pars[2])
par4Tes <- c(fitvar4_es_T$nugget, fitvar4_es_T$cov.pars[1], fitvar4_es_T$cov.pars[2])

resumen_es_T2 <- cbind(
  c("MCO", "$$1/n$$", "$$Cressie$$","MLE"),
  rbind(
    par1Tes,
    par2Tes,
    par3Tes,
    par4Tes
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, par1Tes, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par2Tes, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par3Tes, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par4Tes, NA, model = "spherical", variog_T$h)
  )
)

resumen_es_T2 <- as.data.frame(resumen_es_T2)
resumen_es_T2[ , -1] <- lapply(resumen_es_T2[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_es_T2, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)

```
:::
::::::

El modelo con menor MSE es el modelo Gausiano. Sin embargo, dada la inestabilidad numérica que se observa al realizar la predicción se opta por usar el modelo esférico obtenido por mínimos cuadrados ponderados usando la ponderación $1/n$, que es el segundo mejor en términos del MSE.

### Kriging

```{r, message=F, warning=F}

#| message: false
#| warning: false
#| results: 'hide'

best_model_T <- gstat::vgm(psill = res_es_T$`1/n`$Optimizados[2],
                           model = "Sph",
                           range = res_es_T$`1/n`$Optimizados[3],
                           nugget = res_es_T$`1/n`$Optimizados[1]
)

coordinates(datosT) <- ~Este + Norte
proj4string(datosT) <- CRS("EPSG:3310")

g_obj<-gstat::gstat(id="Temperatura",
             formula = Temperatura ~ Norte + I(Norte^2),
             model = best_model_T,
             data = datosT)

predic <- predict(g_obj, newdata = new, nmin = 12, maxdist=74809.84)

prediction <- data.frame(predic)

#Mapas de predicción

gridded(predic) <- TRUE

#1. Mapa de Kriging

predic_raster_utm <- raster(predic, layer = "Temperatura.pred")

# 2. Asegurarse de que el CRS del ráster se asigne correctamente (EPSG:3310)
crs(predic_raster_utm) <- "+init=epsg:3310"

predic_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        predic_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

bins <- c(-5,0, 5, 8, 10, 12, 15, 20, 25)

pred_range <- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))
pal_pred <- colorBin(
  palette = "viridis", # La paleta de colores
  domain = pred_range,
  bins = bins,
  na.color = "transparent"
)

mapa_kriging_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  
  # Añadir la capa ráster de Predicción Kriging
  addRasterImage(
    predic_raster_wgs84, # Usamos el objeto raster reproyectado
    colors = pal_pred, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
    addCircleMarkers(data = datosT_sf_wgs84,
                   fillColor = ~pal(Temperatura),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 6,
                   popup = ~paste("Temp:", Temperatura, "°C")) %>% 
  
  addLegend(
    pal = pal_pred, 
    values = pred_range,
    title = "Predicción T (°C)",
    position = "topright"
  ) %>%
  
  addLegend(pal = pal,
            values = datosT_sf_wgs84$Temperatura,
            title = "Temperatura Observada",
    position = "topleft"
  ) 

#2 Mapa Varianza------------------------------------------

var_raster_utm <- raster(predic, layer = "Temperatura.var")

# 2. Asegurarse de que el CRS del ráster se asigne correctamente (EPSG:3310)
crs(var_raster_utm) <- "+init=epsg:3310"

var_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        var_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

binsv <- seq(0,30, by=5)

var_range <- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))
pal_var <- colorBin(
  palette = "Spectral", # La paleta de colores
  domain = var_range,
  bins = binsv,
  na.color = "transparent"
)

mapa_var_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  
  # Añadir la capa ráster de Predicción Kriging
  addRasterImage(
    var_raster_wgs84, # Usamos el objeto raster reproyectado
    colors = pal_var, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_var, 
    values = var_range,
    title = "Varianza",
    position = "topright"
  ) 

#3. Mapa Cv ----------------------------------------------

cv_raster_utm <- sqrt(var_raster_utm) / abs(predic_raster_utm)

mapa_mayor_a_uno <- cv_raster_utm > 1
cv_raster_utm[mapa_mayor_a_uno] <- 1

crs(cv_raster_utm) <- "+init=epsg:3310"

cv_raster_masked_utm <- raster::mask(cv_raster_utm, sh_mundos_sp_utm_simple)

# 2. Aplicar CROP (Recorte físico del rectángulo)
cv_raster_cropped_utm <- raster::crop(cv_raster_masked_utm, sh_mundos_sp_utm_simple)

# 3. Reproyectar el objeto MÁS PEQUEÑO a WGS84
cv_raster_wgs84 <- raster::projectRaster(
    cv_raster_cropped_utm, 
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

bincv <- seq(0,1, by=.1)

cv_range <- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))

pal_cv <- colorBin(
  palette = "RdYlGn", # Rojo-Amarillo-Verde
  domain = cv_range,
  na.color = "transparent",
  bins = bincv,
  reverse = TRUE # ¡Esto es CRUCIAL! Para que el Verde sea BAJA incertidumbre.
)

mapa_cv_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  
  # Añadir la capa ráster de Predicción Kriging
  addRasterImage(
    cv_raster_wgs84, # Usamos el objeto raster reproyectado
    colors = pal_cv, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  
  addLegend(
    pal = pal_cv, 
    values = cv_range,
    title = "Coeficiente de Variación",
    position = "topright"
  )
```

::: panel-tabset
#### Predicción

```{r}
mapa_kriging_leaflet
```

#### Varianza

```{r}
mapa_var_leaflet
```

#### Coeficiente de variación

```{r}
mapa_cv_leaflet
```


:::
