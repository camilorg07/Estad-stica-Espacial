p_c23_h = 0.01
p_c23_mort = 0.015
p_ce_ca = 0.10
p_ce_mort = 0.10
p_ca_mort = 0.20
# Tasas de Intervención (La clave del modelo)
p_c23_cancer_no = 0.05 # CIN23 -> Cáncer (SIN intervención)
p_c23_cancer_int = 0.005 # CIN23 -> Cáncer (CON intervención, REDUCIDO)
p_c23_curacion_int = 0.40 # CIN23 -> Healthy (CON intervención, AUMENTADO)
# --- 3. Probabilidades de Permanencia (La Diagonal) ---
p_stay_h = 1 - (p_h_cin1 + p_h_c23 + p_mort_base)
p_stay_c1 = 1 - (p_c1_h + p_c1_c23 + p_c1_mort)
# Permanencia CIN23 SIN intervención
p_stay_c23_no = 1 - (p_c23_h + p_c23_cancer_no + p_c23_mort)
# Permanencia CIN23 CON intervención
p_stay_c23_int = 1 - (p_c23_curacion_int + p_c23_cancer_int + p_c23_mort)
p_stay_ce = 1 - (p_ce_ca + p_ce_mort)
p_stay_ca = 1 - p_ca_mort
# --- 4. Definición de Estados y Matrices de Transición (El FIX) ---
# 4.1 Estados Markov
state_CIN1 <- define_state(cost = 100000, utility = param$u_CIN)
state_CIN23 <- define_state(cost = 200000, utility = param$u_CIN)
state_cancer_early <- define_state(cost = param$cost_cancer_early, utility = param$u_cancer_early)
state_cancer_adv  <- define_state(cost = param$cost_cancer_adv,  utility = param$u_cancer_adv)
state_dead <- define_state(cost = 0, utility = 0)
# 4.2 MATRIZ DE CONTROL (NO TAMIZACIÓN) - Usando matrix()
# El orden es por COLUMNA (la convención de R)
mat_no <- matrix(
c(
# healthy
p_stay_h, 0.03, 0.01, 0, 0, 0,
# CIN1
p_h_cin1, p_stay_c1, 0, 0, 0, 0,
# CIN23
p_h_c23, p_c1_c23, p_stay_c23_no, 0, 0, 0,
# cancer_early
0, 0, p_c23_cancer_no, p_stay_ce, 0, 0,
# cancer_adv
0, 0, 0, p_ce_ca, p_stay_ca, 0,
# dead (Absorbente)
p_mort_base, p_c1_mort, p_c23_mort, p_ce_mort, p_ca_mort, 1
),
nrow = 6, ncol = 6, byrow = FALSE,
dimnames = list(c("healthy", "CIN1", "CIN23", "cancer_early", "cancer_adv", "dead"),
c("healthy", "CIN1", "CIN23", "cancer_early", "cancer_adv", "dead"))
)
# 4.3 MATRIZ DE INTERVENCIÓN (TAMIZACIÓN) - Usando matrix()
mat_int <- matrix(
c(
# healthy
p_stay_h, 0.03, p_c23_curacion_int, 0, 0, 0, # Fila clave de curación
# CIN1
p_h_cin1, p_stay_c1, 0, 0, 0, 0,
# CIN23
p_h_c23, p_c1_c23, p_stay_c23_int, 0, 0, 0, # Fila clave de permanencia
# cancer_early
0, 0, p_c23_cancer_int, p_stay_ce, 0, 0, # Fila clave de progresión reducida
# cancer_adv
0, 0, 0, p_ce_ca, p_stay_ca, 0,
# dead (Absorbente)
p_mort_base, p_c1_mort, p_c23_mort, p_ce_mort, p_ca_mort, 1
),
nrow = 6, ncol = 6, byrow = FALSE,
dimnames = list(c("healthy", "CIN1", "CIN23", "cancer_early", "cancer_adv", "dead"),
c("healthy", "CIN1", "CIN23", "cancer_early", "cancer_adv", "dead"))
)
# Convertir las matrices base a objetos de transición de heemod
tmat_no_interv <- define_transition(mat_no)
tmat_interv <- define_transition(mat_int)
# --- 5.1 Modelo NO TAMIZACIÓN (Control) ---
mod_no <- define_strategy(
transition = tmat_no_interv,
healthy = define_state(cost = 0, utility = param$u_healthy),
CIN1 = state_CIN1, CIN23 = state_CIN23, cancer_early = state_cancer_early, cancer_adv = state_cancer_adv, dead = state_dead
)
# --- 1. Parámetros base ---
param <- define_parameters(
cost_cita = 52000, cost_cito = 41600, cost_vph = 70000,
cost_treat_CIN = 5000000, cost_cancer_early = 12238597, cost_cancer_adv  = 15000000,
u_healthy = 1, u_CIN = 0.95, u_cancer_early = 0.7, u_cancer_adv = 0.4,
qaly_discount = 0.03, cost_discount = 0.03
)
# --- 2. Variables de Probabilidad (Pre-cálculo) ---
p_h_cin1 = 0.05
p_h_c23 = 0.01
p_mort_base = 0.005
p_c1_h = 0.03
p_c1_c23 = 0.08
p_c1_mort = 0.01
p_c23_h = 0.01
p_c23_mort = 0.015
p_ce_ca = 0.10
p_ce_mort = 0.10
p_ca_mort = 0.20
p_c23_cancer_no = 0.05
p_c23_cancer_int = 0.005
p_c23_curacion_int = 0.40
p_stay_h = 1 - (p_h_cin1 + p_h_c23 + p_mort_base)
p_stay_c1 = 1 - (p_c1_h + p_c1_c23 + p_c1_mort)
p_stay_c23_no = 1 - (p_c23_h + p_c23_cancer_no + p_c23_mort)
p_stay_c23_int = 1 - (p_c23_curacion_int + p_c23_cancer_int + p_c23_mort)
p_stay_ce = 1 - (p_ce_ca + p_ce_mort)
p_stay_ca = 1 - p_ca_mort
# --- 3. Definición de Estados y Matrices de Transición ---
state_names <- c("healthy", "CIN1", "CIN23", "cancer_early", "cancer_adv", "dead")
state_CIN1 <- define_state(cost = 100000, utility = param$u_CIN)
state_CIN23 <- define_state(cost = 200000, utility = param$u_CIN)
state_cancer_early <- define_state(cost = param$cost_cancer_early, utility = param$u_cancer_early)
state_cancer_adv  <- define_state(cost = param$cost_cancer_adv,  utility = param$u_cancer_adv)
state_dead <- define_state(cost = 0, utility = 0)
# 3.1 MATRIZ DE CONTROL (NO TAMIZACIÓN)
mat_no <- matrix(
c(
p_stay_h, 0.03, 0.01, 0, 0, 0,
p_h_cin1, p_stay_c1, 0, 0, 0, 0,
p_h_c23, p_c1_c23, p_stay_c23_no, 0, 0, 0,
0, 0, p_c23_cancer_no, p_stay_ce, 0, 0,
0, 0, 0, p_ce_ca, p_stay_ca, 0,
p_mort_base, p_c1_mort, p_c23_mort, p_ce_mort, p_ca_mort, 1
),
nrow = 6, ncol = 6, byrow = FALSE # La convención de R es por COLUMNA
)
# 3.2 MATRIZ DE INTERVENCIÓN (TAMIZACIÓN)
mat_int <- matrix(
c(
p_stay_h, 0.03, p_c23_curacion_int, 0, 0, 0, # Curación
p_h_cin1, p_stay_c1, 0, 0, 0, 0,
p_h_c23, p_c1_c23, p_stay_c23_int, 0, 0, 0, # Permanencia
0, 0, p_c23_cancer_int, p_stay_ce, 0, 0, # Progresión Reducida
0, 0, 0, p_ce_ca, p_stay_ca, 0,
p_mort_base, p_c1_mort, p_c23_mort, p_ce_mort, p_ca_mort, 1
),
nrow = 6, ncol = 6, byrow = FALSE
)
# --- 4. Definición de Estrategias y Ejecución ---
# El FIX: Pasar los state_names explícitamente
tmat_no_interv <- define_transition(mat_no, state_names = state_names)
library(heemod)
# --- 1. Parámetros base (Entradas para el modelo) ---
param <- define_parameters(
cost_cita = 52000, cost_cito = 41600, cost_vph = 70000,
cost_treat_CIN = 5000000, cost_cancer_early = 12238597, cost_cancer_adv  = 15000000,
u_healthy = 1, u_CIN = 0.95, u_cancer_early = 0.7, u_cancer_adv = 0.4,
qaly_discount = 0.03, cost_discount = 0.03
)
# --- 2. Variables de Probabilidad (Pre-cálculo) ---
# Estados
state_names <- c("healthy", "CIN1", "CIN23", "cancer_early", "cancer_adv", "dead")
# Tasas de Salida Comunes (Literatura)
p_h_cin1 = 0.05
p_h_c23 = 0.01
p_mort_base = 0.005
p_c1_h = 0.03
p_c1_c23 = 0.08
p_c1_mort = 0.01
p_c23_h = 0.01
p_c23_mort = 0.015
p_ce_ca = 0.10
p_ce_mort = 0.10
p_ca_mort = 0.20
# Tasas de Intervención (La clave del modelo)
p_c23_cancer_no = 0.05
p_c23_cancer_int = 0.005
p_c23_curacion_int = 0.40
# Probabilidades de Permanencia (La Diagonal)
p_stay_h = 1 - (p_h_cin1 + p_h_c23 + p_mort_base)
p_stay_c1 = 1 - (p_c1_h + p_c1_c23 + p_c1_mort)
p_stay_c23_no = 1 - (p_c23_h + p_c23_cancer_no + p_c23_mort)
p_stay_c23_int = 1 - (p_c23_curacion_int + p_c23_cancer_int + p_c23_mort)
p_stay_ce = 1 - (p_ce_ca + p_ce_mort)
p_stay_ca = 1 - p_ca_mort
# --- 3. Definición de Estados y MATRICES CON data.frame() ---
# 3.1 Estados Markov
state_CIN1 <- define_state(cost = 100000, utility = param$u_CIN)
state_CIN23 <- define_state(cost = 200000, utility = param$u_CIN)
state_cancer_early <- define_state(cost = param$cost_cancer_early, utility = param$u_cancer_early)
state_cancer_adv  <- define_state(cost = param$cost_cancer_adv,  utility = param$u_cancer_adv)
state_dead <- define_state(cost = 0, utility = 0)
# 3.2 MATRIZ DE CONTROL (NO TAMIZACIÓN)
mat_no_df <- data.frame(
# healthy
p_stay_h, p_h_cin1, p_h_c23, 0, 0, p_mort_base,
# CIN1
p_c1_h, p_stay_c1, p_c1_c23, 0, 0, p_c1_mort,
# CIN23
p_c23_h, 0, p_stay_c23_no, p_c23_cancer_no, 0, p_c23_mort,
# cancer_early
0, 0, 0, p_stay_ce, p_ce_ca, p_ce_mort,
# cancer_adv
0, 0, 0, 0, p_stay_ca, p_ca_mort,
# dead
0, 0, 0, 0, 0, 1
)
# Reordenar por filas para coincidir con define_transition (y heemod)
mat_no <- matrix(t(mat_no_df), nrow = 6, ncol = 6, byrow = TRUE, dimnames = list(state_names, state_names))
# 3.3 MATRIZ DE INTERVENCIÓN (TAMIZACIÓN)
mat_int_df <- data.frame(
# healthy
p_stay_h, p_h_cin1, p_h_c23, 0, 0, p_mort_base,
# CIN1
p_c1_h, p_stay_c1, p_c1_c23, 0, 0, p_c1_mort,
# CIN23 (MODIFICADA)
p_c23_curacion_int, 0, p_stay_c23_int, p_c23_cancer_int, 0, p_c23_mort,
# cancer_early
0, 0, 0, p_stay_ce, p_ce_ca, p_ce_mort,
# cancer_adv
0, 0, 0, p_ce_ca, p_stay_ca, 0,
# dead
0, 0, 0, 0, 0, 1
)
mat_int <- matrix(t(mat_int_df), nrow = 6, ncol = 6, byrow = TRUE, dimnames = list(state_names, state_names))
# --- 4. Definición de Estrategias y Ejecución ---
# Ahora, define_transition recibe una matriz de 6x6 válida
tmat_no_interv <- define_transition(mat_no)
tmat_interv <- define_transition(mat_int)
mod_no <- define_strategy(
transition = tmat_no_interv,
healthy = define_state(cost = 0, utility = param$u_healthy),
CIN1 = state_CIN1, CIN23 = state_CIN23, cancer_early = state_cancer_early, cancer_adv = state_cancer_adv, dead = state_dead
)
## Resumen
El objetivo del artículo es extender la metodología \textbf{GeDS}, desarrollada originalmente para regresión spline normal multivariada, a un contexto más general de \textbf{modelos lineales y no lineales generalizados (GLM/GNM)}.
library(splines)
library(MASS)
# Asignar las columnas 'times' y 'accel' del dataframe mcycle
times <- mcycle$times
accel <- mcycle$accel
nknots <- 9 # nodos internos; 10 intervalos
knots <- seq(min(times), max(times), len = nknots + 2)[-c(1, nknots + 2)]
library(splines)
fit1 <- lm(accel ~ bs(times, knots = knots, degree = 1))
fit2 <- lm(accel ~ bs(times, knots = knots, degree = 2))
fit3 <- lm(accel ~ bs(times, knots = knots)) # degree = 3
# Representar
plot(times, accel, col = 'darkgray')
newx <- seq(min(times), max(times), len = 200)
newdata <- data.frame(times = newx)
lines(newx, predict(fit1, newdata), lty = 3)
lines(newx, predict(fit2, newdata), lty = 2)
lines(newx, predict(fit3, newdata))
abline(v = knots, lty = 3, col = 'darkgray')
leyenda <- c("d=1 (df=11)", "d=2 (df=12)", "d=3 (df=13)")
legend("topright", legend = leyenda, lty = c(3, 2, 1))
library(MASS)
# Asignar las columnas 'times' y 'accel' del dataframe mcycle
times <- mcycle$times
accel <- mcycle$accel
nknots <- 9 # nodos internos; 10 intervalos
knots <- seq(min(times), max(times), len = nknots + 2)[-c(1, nknots + 2)]
library(splines)
fit1 <- lm(accel ~ bs(times, knots = knots, degree = 1))
fit2 <- lm(accel ~ bs(times, knots = knots, degree = 2))
fit3 <- lm(accel ~ bs(times, knots = knots)) # degree = 3
# Representar
plot(times, accel, col = 'darkgray')
newx <- seq(min(times), max(times), len = 200)
newdata <- data.frame(times = newx)
lines(newx, predict(fit1, newdata), lty = 3)
lines(newx, predict(fit2, newdata), lty = 2)
lines(newx, predict(fit3, newdata))
abline(v = knots, lty = 3, col = 'darkgray')
leyenda <- c("d=1 (df=11)", "d=2 (df=12)", "d=3 (df=13)")
legend("topright", legend = leyenda, lty = c(3, 2, 1))
abline(v = knots, lty = 3, col = 'darkgray')
# Representar
plot(times, accel, col = 'darkgray')
lines(newx, predict(fit1, newdata), lty = 3)
lines(newx, predict(fit2, newdata), lty = 2)
newx <- seq(min(times), max(times), len = 200)
newdata <- data.frame(times = newx)
lines(newx, predict(fit1, newdata), lty = 3)
lines(newx, predict(fit2, newdata), lty = 2)
lines(newx, predict(fit3, newdata))
# Representar
plot(times, accel, col = 'darkgray')
lines(newx, predict(fit1, newdata), lty = 3)
library(dplyr)
library(geoR)
library(sp)
library(readxl)
library(tidyr)
library(sf)
library(ggplot2)
library(tidyverse)
library(lubridate)
library(spacetime)
library(gstat)
library(GeoModels)
## 2. Datos -----------------
Temp <- read_excel("Temp_imp.xlsx", sheet = "Temperatura")
setwd("~/Espacial/Estadística Espacial")
Temp <- read_excel("Temp_imp.xlsx", sheet = "Temperatura")
Temp <- as.data.frame(Temp)
EstacionesT <- read_excel("Temp_imp.xlsx", sheet = "Estaciones")
EstacionesT$AQSID<-as.character(EstacionesT$AQSID)
EstacionesT <- EstacionesT[,c(1,12,13)]
Temp_long <- Temp %>% pivot_longer(cols = -DateTime, names_to = "AQSID",
values_to = "value") %>%  mutate(AQSID = as.character(AQSID))
Temp_long<-Temp_long %>%
filter(as.Date(dmy_hms(Temp_long$DateTime)) == as.Date("2024-01-03"))
Data_ST <- Temp_long %>% left_join(EstacionesT, by = "AQSID")
Data_ST$DateTime <- dmy_hms(Data_ST$DateTime)
Data_ST$Hora <- hour(Data_ST$DateTime)
## 3. Analisis de media -----------------
Temp.st.res <- as.data.frame(Data_ST) %>%
group_by(DateTime) %>%
mutate(value = resid(lm(value ~ Norte+I(Norte^2)))) %>%
ungroup()
geoMatrix <- Temp.st.res %>%
dplyr::select(DateTime, AQSID, value) %>%
tidyr::pivot_wider(names_from = AQSID, values_from = value) %>%
arrange(DateTime) %>%
dplyr::select(-DateTime) %>%
as.matrix()
geovgm <- GeoVariogram(data = geoMatrix,
coordx = as.matrix(EstacionesT[,c("Este", "Norte")]),
coordt = unique(Data_ST$Hora - min(Data_ST$Hora)),
distance = "Eucl",
type= "variogram",
maxdist = 8e+05)
plot(geovgm)
GeoCovmatrix(corrmodel = "Matern_Matern_nosep",
coordx = as.matrix(EstacionesT[,c("Este", "Norte")]),
coordt = 0:23,
model = "Gaussian",
param = init.ST_Mat_Mat)
CorrParam("Matern_Matern_nosep")
GeoCovmatrix(corrmodel = "Gneiting",
coordx = as.matrix(EstacionesT[,c("Este", "Norte")]),
coordt = 0:23,
model = "Gaussian",
param = init.ST_Mat_Mat)
GeoCovmatrix(corrmodel = "Gneiting",
coordx = as.matrix(EstacionesT[,c("Este", "Norte")]),
coordt = 0:23,
model = "Gaussian",
param = init.ST_gne)
init.ST_gne <- list(
scale_s = 1e5,
power_s = 1,
scale_t = 1,
power_t = 1,
sep     = 0.5,
sill    = 9,
nugget  = 0.1
)
lower.ST_gne <- list(
scale_s = 0.001,
power_s = 0.1,
scale_t = 0.001,
power_t = 0.1,
sep     = 0.01,
sill    = 0.001,
nugget  = 0
)
upper.ST_gne <- list(
scale_s = 3e6,
power_s = 2,
scale_t = 12,
power_t = 2,
sep     = 0.99,
sill    = 20,
nugget  = 1
)
GeoCovmatrix(corrmodel = "Gneiting",
coordx = as.matrix(EstacionesT[,c("Este", "Norte")]),
coordt = 0:23,
model = "Gaussian",
param = init.ST_gne)
fixed.ST_gne <- list(mean = 0)
geofit_gne <- GeoFit(data = geoMatrix,
coordx = as.matrix(EstacionesT[,c("Este", "Norte")]),
coordt = unique(Data_ST$Hora - min(Data_ST$Hora)),
distance = "Eucl",
maxdist = 8e+05,
maxtime =23,
model = "Gaussian",
corrmodel = "Gneiting",
start = init.ST_gne,
optimizer = "L-BFGS-B",
fixed = fixed.ST_gne,
lower = lower.ST_gne,
upper = upper.ST_gne)
geofit_gne
geofit_gne <- GeoFit(data = geoMatrix,
coordx = as.matrix(EstacionesT[,c("Este", "Norte")]),
coordt = unique(Data_ST$Hora - min(Data_ST$Hora)),
distance = "Eucl",
maxdist = 8e+05,
maxtime =11,
model = "Gaussian",
corrmodel = "Gneiting",
start = init.ST_gne,
optimizer = "L-BFGS-B",
fixed = fixed.ST_gne,
lower = lower.ST_gne,
upper = upper.ST_gne)
geocgvm<- GeoCovariogram(fitted = geofit_gne,
answer.vario = TRUE,
show.vario = TRUE,
add.vario = TRUE,
vario = geovgm,
invisible = TRUE)
geofit_gne
geofit_gne <- GeoFit(data = geoMatrix,
coordx = as.matrix(EstacionesT[,c("Este", "Norte")]),
coordt = unique(Data_ST$Hora - min(Data_ST$Hora)),
distance = "Eucl",
maxdist = 8e+05,
maxtime =7,
model = "Gaussian",
corrmodel = "Gneiting",
start = init.ST_gne,
optimizer = "L-BFGS-B",
fixed = fixed.ST_gne,
lower = lower.ST_gne,
upper = upper.ST_gne)
geofit_gne
##################################################################
>
geocgvm<- GeoCovariogram(fitted = geofit_gne,
answer.vario = TRUE,
show.vario = TRUE,
add.vario = TRUE,
vario = geovgm,
invisible = TRUE)
GeoPlotEmpirical(geovgm)
geofit_gne1 <- GeoFit(data = geoMatrix,
coordx = as.matrix(EstacionesT[,c("Este", "Norte")]),
coordt = unique(Data_ST$Hora - min(Data_ST$Hora)),
distance = "Eucl",
maxdist = 5e+05,
maxtime =8,
model = "Gaussian",
corrmodel = "Gneiting",
start = init.ST_gne,
optimizer = "L-BFGS-B",
fixed = fixed.ST_gne,
lower = lower.ST_gne,
upper = upper.ST_gne)
geocgvm1<- GeoCovariogram(fitted = geofit_gne1,
answer.vario = TRUE,
show.vario = TRUE,
add.vario = TRUE,
vario = geovgm,
invisible = TRUE)
CorrParam("Matern_Matern_nosep")
?GeoCovmatrix
?NuisParam
NuisParam("Gaussian")
init.mat_mat <- list(
scale_s = 1e5,
scale_t = 1,
smooth_s = 2,
smooth_t = 2,
sep     = 0.5,
sill    = 12,
nugget  = 0.1
)
lower.mat_mat <- list(
scale_s = 1e5,
scale_t = 2,
smooth_s = 1e-3,
smooth_t = 1e-3,
sep     = 1e-3,
sill    = 1e-3,
nugget  = 0
)
upper.mat_mat <- list(
scale_s = 7e5,
scale_t = 20,
smooth_s = Inf,
smooth_t = Inf,
sep     = 1,
sill    = 20,
nugget  = 6
)
tictoc::tic()
geofit_mat_mat <- GeoFit(data = geoMatrix,
coordx = as.matrix(EstacionesT[,c("Este", "Norte")]),
coordt = unique(Data_ST$Hora - min(Data_ST$Hora)),
distance = "Eucl",
maxdist = 7e+05,
maxtime =10,
model = "Gaussian",
corrmodel = "Matern_Matern_nosep",
start = init.mat_mat,
optimizer = "L-BFGS-B",
fixed = fixed.ST_gne,
lower = lower.mat_mat,
upper = upper.mat_mat)
tictoc::toc()
View(Temp)
11804/60
geocgvmat<- GeoCovariogram(fitted = geofit_mat_mat,
answer.vario = TRUE,
show.vario = TRUE,
add.vario = TRUE,
vario = geovgm,
invisible = TRUE)
geocgvm<- GeoCovariogram(fitted = geofit_gne,
answer.vario = TRUE,
show.vario = TRUE,
add.vario = TRUE,
vario = geovgm,
invisible = TRUE)
geocgvm1<- GeoCovariogram(fitted = geofit_gne1,
answer.vario = TRUE,
show.vario = TRUE,
add.vario = TRUE,
vario = geovgm,
invisible = TRUE)
