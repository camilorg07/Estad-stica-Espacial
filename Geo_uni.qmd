
# Análisis Univariado

## Introducción

La calidad del aire es un factor clave para la salud pública, el bienestar social y la sostenibilidad ambiental, y California se destaca como uno de los estados más afectados de Estados Unidos por la contaminación atmosférica. La combinación de una alta densidad poblacional, una intensa actividad industrial y vehicular, junto con fenómenos naturales como los incendios forestales, ha hecho que varias de sus ciudades se ubiquen entre las más contaminadas del país. Al mismo tiempo, la temperatura cumple un papel fundamental en la dinámica atmosférica, ya que influye en la dispersión, concentración y formación de contaminantes, además de constituir en sí misma un aspecto crítico para comprender las condiciones ambientales regionales. Frente a este contexto, resulta necesario llevar a cabo un análisis geoespacial que considere tanto la calidad del aire como la temperatura en California, con el fin de identificar patrones espaciales, contrastes regionales y áreas críticas que permitan orientar acciones de mitigación y gestión ambiental.

## Descripción

Los datos objeto de este estudio provienen de la [Agencia de Protección Ambiental (EPA)](https://www.epa.gov/) de los Estados Unidos y corresponden a registros horarios obtenidos de las estaciones de monitoreo durante el mes de marzo de 2024. En partícular, se analizan las variables **Temperatura** y **Ozono (**$O_3$**)**.

### Unidades

-   *Temperatura:* Medido en grados celsius (C°) con una intensidad horaria.

-   *Ozono:* Medido en partes por billón (ppb) con una intensidad horaria.

```{r, warning=FALSE, message=F}

#Librerias necesarias ------------------------------------

set.seed(123)

library(dplyr)
library(geoR)
library(sp)
library(readxl)
library(tidyr)
library(sf)
library(ggplot2)
library(knitr)
library(plotly)
library(leaflet)
library(raster)
library(stars)
library(terra)

#Variale Temperatura --------------------------------------

Temp <- read_excel("GeoEst_Cali.xlsx", sheet = "Temperatura")
colnames(Temp)[-1] <- as.numeric(colnames(Temp)[-1])
EstacionesT <- read_excel("GeoEst_Cali.xlsx", sheet = "Estaciones")
EstacionesT <- EstacionesT %>% mutate(AQSID = as.numeric(AQSID))
EstacionesT <- EstacionesT %>% filter(AQSID %in% colnames(Temp)[-1])

#Variable Ozono ------------------------------------------

Ozono <- read_excel("GeoEst_Cali.xlsx", sheet = "Ozono")
colnames(Ozono)[-1] <- as.numeric(colnames(Ozono)[-1])
EstacionesOz <- read_excel("GeoEst_Cali.xlsx", sheet = "Estaciones")
EstacionesOz <- EstacionesOz %>% mutate(AQSID = as.numeric(AQSID))
EstacionesOz <- EstacionesOz %>% filter(AQSID %in% colnames(Ozono)[-1])

#Variable velocidad del viento ----------------------------

WS <- read_excel("GeoEst_Cali.xlsx", sheet = "WindSpeed")
colnames(WS)[-1] <- as.numeric(colnames(WS)[-1])
EstacionesWS <- read_excel("GeoEst_Cali.xlsx", sheet = "Estaciones")
EstacionesWS <- EstacionesWS %>% mutate(AQSID = as.numeric(AQSID))
EstacionesWS <- EstacionesWS %>% filter(AQSID %in% colnames(WS)[-1])

#Variable presión atmosférica -----------------------------

Presion <- read_excel("GeoEst_Cali.xlsx", sheet = "Presion")
colnames(Presion)[-1] <- as.numeric(colnames(Presion)[-1])
EstacionesPr <- read_excel("GeoEst_Cali.xlsx", sheet = "Estaciones")
EstacionesPr <- EstacionesPr %>% mutate(AQSID = as.numeric(AQSID))
EstacionesPr <- EstacionesPr %>% filter(AQSID %in% colnames(Presion)[-1])


#Para el mapa de California -------------------------------

sh_mundos<-st_read("admin00.shp",quiet=TRUE)
sh_mundos <- sh_mundos %>% filter(CNTRY_NAME=="United States")
sh_mundos <- sh_mundos %>% filter(ADMIN_NAME=="California")

CRS_UTM_NY = "+init=epsg:3310"

sh_mundos_wgs84 <- st_transform(sh_mundos, crs = 4326)

sh_mundos_utm <- st_transform(sh_mundos, crs = CRS("EPSG:3310"))

sh_mundos_sp_utm <- as(sh_mundos_utm, "Spatial")

sh_mundos_utm_simple <- st_union(sh_mundos_utm)
sh_mundos_sp_utm_simple <- as(sh_mundos_utm_simple, "Spatial")

#Grilla para hacer kriging ------------------------------

new <- sp::spsample(as(sh_mundos_utm, "Spatial"), n = 50000, type = "regular")

proj4string(new) <- CRS("EPSG:3310")
invisible(coordinates(new) ~ Este + Norte)
colnames(new@coords) <- c("Este", "Norte")

#Gráficos de dispersión ----------------------------------

simple_scatter_plot <- function(datos, variable1, variable2) {

    plot1 <- ggplot(as.data.frame(datos),
                    aes(x = .data[[variable1]], y = .data[[variable2]],
                               color = as.factor(1))) +
                    geom_point() +
                    scale_colour_viridis_d() +
                    labs(
                        x = variable1,
                        y = variable2
                        ) +
                    theme_light() +
                    theme(legend.position = "none")

    return(plot1)

}

```

## Análisis geoestadístico

### Variable Ozono

Se tomaron los datos de Temperatura de la madrugada el primero de marzo de 2024:

```{r, message=F, warning=F}

y_oz <- Ozono[1,] #Tomar una fecha
y_oz <- cbind(colnames(y_oz),t(y_oz[1,]))
y_oz <- y_oz[-1,]
y_oz <- as.data.frame(y_oz)
y_oz <- na.omit(y_oz)
y_oz$V1 <- as.numeric(y_oz$V1)
y_oz <- inner_join(y_oz, EstacionesOz, by=c("V1"="AQSID"))
datosOZ <- y_oz[,c(13,14,2)] #DatosOz es la base con coordenadas + variable
colnames(datosOZ)=c("Este","Norte","Ozono")
datosOZ$Ozono <- as.numeric(datosOZ$Ozono)

datosOZ_sf <- st_as_sf(datosOZ, coords = c("Este", "Norte"), crs = 3310)

datosO_sf_wgs84 <- st_transform(datosOZ_sf, crs = 4326)

palO <- colorNumeric(palette = "viridis", domain = datosO_sf_wgs84$Ozono)

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = "black", weight = 2) %>%
  addCircleMarkers(data = datosO_sf_wgs84,
                   fillColor = ~palO(Ozono),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("Ozono:", Ozono, "°C")) %>%
  addLegend(pal = palO, values = datosO_sf_wgs84$Ozono, title = "Ozono (ppb)")

ozone <- as.geodata(datosOZ) 
pander::pander(summary(ozone))

```

::: panel-tabset
#### Gráficos de dispersión

```{r}
pO1 <- simple_scatter_plot(datosOZ, "Este", "Ozono")
pO2 <- simple_scatter_plot(datosOZ, "Norte", "Ozono")

cowplot::plot_grid(pO1,pO2)

```

#### GeoR

```{r}
plot(ozone, qt.col = c("purple",
                          "pink",
                          "green",
                          "yellow"),
     scatter3d=T)
```
:::

El gráfico muestra una relación polinomial de la variable Ozono con respecto a las coordenadas en Norte. Se prueba con varios modelos hasta encontrar aquel que mitigue el efecto espacial.

#### Modelo para la Media

El modelo que mejor atrapa el efecto de la media es:

$$Ozono = \beta_0+\beta_1 \times Norte^2 + \beta_2 \times Norte^3 + \beta_3 \times Este$$

```{r}
fitO <- lm(Ozono~I(Norte^2)+I(Norte^3)+Este, data = datosOZ) 
pander::pander(summary(fitO))
```

Gráficamente se observa una mitigación en la tendencia espacial:

::: panel-tabset
##### Gráficos de dispersión

```{r}
datosOZ$Residuos <- fitO$residuals

pO1 <- simple_scatter_plot(datosOZ, "Este", "Residuos")
pO2 <- simple_scatter_plot(datosOZ, "Norte", "Residuos")

cowplot::plot_grid(pO1,pO2)

```

##### GeoR

```{r}
plot(ozone, qt.col = c("purple",
                          "pink",
                          "green",
                          "yellow"),
     scatter3d=T, trend = ~ poly(Norte,3))
```
:::

#### Estimación Empírica del Semivariograma

A continuación, se presenta la estimación del semivariograma obtenida con la función variog. Se muestran dos gráficos comparativos: el primero corresponde a los datos originales (sin eliminar la tendencia) y el segundo a los residuales obtenidos tras ajustar el modelo de regresión, lo que permite observar el efecto de remover la tendencia en la estructura espacial.

```{r, message=FALSE, results='hide'}
vg_O <- variog(ozone,estimator.type = "modulus", pairs.min=50) #Sin tendencia espacial

vg1_O <- variog(ozone, trend = ~I(Norte^2)+I(Norte^3)+Este, estimator.type = "modulus", pairs.min=50)
```

::: panel-tabset
##### Con tendencia

```{r}
plot(vg_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Sin remover tendencia",
     col.main = 4, cex.main =1.3)
```

##### Removiendo Tendencia

```{r}
plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Removiendo tendencia",
     col.main = 4, cex.main =1.3)
```
:::

Se observa que la estimación de la semivarianza de la variable incrementos es más estable y presenta valores más bajos al remover la tendencia, lo que indica que en este caso el semivariograma refleja de manera más adecuada la verdadera estructura espacial del fenómeno.

```{r}
plot(vg1_O$u, vg1_O$n, type="b",
     xlab="distance", ylab="n pairs",
     main="Número de pares por bin")
```

#### Estimación del Modelo Teórico de Semivariograma

Los modelos obtenidos ajustanto por EyeFit, son:

``` text
cov.model sigmasq      phi tausq kappa kappa2 practicalRange
1    matern    17.0 440676.0     5   0.5     NA        1320147
2  gneiting    17.5 803585.6     9    NA     NA        1371348
3    linear    0.25 0.32     0    NA     NA            Inf
```
::: panel-tabset

##### Matern

```{r}
#| message: false
#| warning: false
#| results: 'hide'

sigma_0_mO <- 12.0
phi_0_mO <- 224249.7
nugget_0_mO <- 2.00 
kappa_0_mO <- 0.2

ini1_mat_O <- c(sigma_0_mO, phi_0_mO)
fitvar1_mat_O <- variofit(vg1_O,
                    cov.model = "matern",
                    ini1_mat_O,
                    fix.nugget = F,
                    nugget = nugget_0_mO,
                    kappa = kappa_0_mO,
                    wei = "equal")

fitvar2_mat_O <- variofit(vg1_O,
                    cov.model = "matern",
                    ini1_mat_O,
                    fix.nugget = F,
                    nugget = nugget_0_mO,
                    kappa = kappa_0_mO,
                    wei = "npairs")

fitvar3_mat_O <- variofit(vg1_O,
                    cov.model = "matern",
                    ini1_mat_O,
                    fix.nugget = F,
                    nugget = nugget_0_mO,
                    kappa = kappa_0_mO,
                    wei = "cressie")

fitvar4_mat_O <- likfit(ozone,
                  coords = ozone$coords,
                  data = ozone$data,
                  trend = ~ I(Norte^2) + I(Norte^3) + Este,
                  ini.cov.pars = ini1_mat_O,
                  fix.nugget = F,
                  nugget = nugget_0_mO,
                  kappa = kappa_0_mO,
                  cov.model = "matern",
                  lik.method = "ML")


plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_mat_O, col="#FF4040", lwd=1.5)
lines(fitvar2_mat_O, col="#4169E1", lwd=1.5)
lines(fitvar3_mat_O, col="#008B00", lwd=1.5)
lines(fitvar4_mat_O, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)
```

##### Gneiting

```{r}
#| message: false
#| warning: false
#| results: 'hide'

sigma_0_gO <- 17.5
phi_0_gO <- 803585.6
nugget_0_gO <- 9

ini1_g_O <- c(sigma_0_gO, phi_0_gO)
fitvar1_g_O <- variofit(vg1_O,
                    cov.model = "gneiting",
                    ini1_g_O,
                    fix.nugget = F,
                    nugget = nugget_0_gO,
                    wei = "equal")

fitvar2_g_O <- variofit(vg1_O,
                    cov.model = "gneiting",
                    ini1_g_O,
                    fix.nugget = F,
                    nugget = nugget_0_gO,
                    wei = "npairs")

fitvar3_g_O <- variofit(vg1_O,
                    cov.model = "gneiting",
                    ini1_g_O,
                    fix.nugget = F,
                    nugget = nugget_0_gO,
                    wei = "cressie")

fitvar4_g_O <- likfit(ozone,
                  coords = ozone$coords,
                  data = ozone$data,
                  trend = ~ I(Norte^2) + I(Norte^3) + Este,
                  ini.cov.pars = ini1_g_O,
                  fix.nugget = F,
                  nugget = nugget_0_gO,
                  cov.model = "gneiting",
                  lik.method = "ML")


plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_g_O, col="#FF4040", lwd=1.5)
lines(fitvar2_g_O, col="#4169E1", lwd=1.5)
lines(fitvar3_g_O, col="#008B00", lwd=1.5)
lines(fitvar4_g_O, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)
```

##### Exponencial

```{r}
#| message: false
#| warning: false
#| results: 'hide'

sigma_0_lO <- 10
phi_0_lO <- 6e5
nugget_0_lO <- 10

ini1_l_O <- c(sigma_0_lO, phi_0_lO)
fitvar1_l_O <- variofit(vg1_O,
                    cov.model = "exponential",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "equal")

fitvar2_l_O <- variofit(vg1_O,
                    cov.model = "exponential",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "npairs")

fitvar3_l_O <- variofit(vg1_O,
                    cov.model = "exponential",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "cressie")

fitvar4_l_O <- likfit(ozone,
                  coords = ozone$coords,
                  data = ozone$data,
                  trend = ~ I(Norte^2) + I(Norte^3) + Este,
                  ini.cov.pars = ini1_l_O,
                  fix.nugget = F,
                  nugget = nugget_0_lO,
                  cov.model = "exponential",
                  lik.method = "ML")


plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_l_O, col="#FF4040", lwd=1.5)
lines(fitvar2_l_O, col="#4169E1", lwd=1.5)
lines(fitvar3_l_O, col="#008B00", lwd=1.5)
lines(fitvar4_l_O, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

```

##### Esférico

```{r}
#| message: false
#| warning: false
#| results: 'hide'

sigma_0_lO <- 10
phi_0_lO <- 6e5
nugget_0_lO <- 10

ini1_l_O <- c(sigma_0_lO, phi_0_lO)
fitvar1_es_O <- variofit(vg1_O,
                    cov.model = "spherical",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "equal")

fitvar2_es_O <- variofit(vg1_O,
                    cov.model = "spherical",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "npairs")

fitvar3_es_O <- variofit(vg1_O,
                    cov.model = "spherical",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "cressie")

fitvar4_es_O <- likfit(ozone,
                  coords = ozone$coords,
                  data = ozone$data,
                  trend = ~ I(Norte^2) + I(Norte^3) + Este,
                  ini.cov.pars = ini1_l_O,
                  fix.nugget = F,
                  nugget = nugget_0_lO,
                  cov.model = "spherical",
                  lik.method = "ML")


plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_es_O, col="#FF4040", lwd=1.5)
lines(fitvar2_es_O, col="#4169E1", lwd=1.5)
lines(fitvar3_es_O, col="#008B00", lwd=1.5)
lines(fitvar4_es_O, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

```

##### Cúbico

```{r}
#| message: false
#| warning: false
#| results: 'hide'

sigma_0_lO <- 10
phi_0_lO <- 6e5
nugget_0_lO <- 10

ini1_l_O <- c(sigma_0_lO, phi_0_lO)
fitvar1_c_O <- variofit(vg1_O,
                    cov.model = "cubic",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "equal")

fitvar2_c_O <- variofit(vg1_O,
                    cov.model = "cubic",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "npairs")

fitvar3_c_O <- variofit(vg1_O,
                    cov.model = "cubic",
                    ini1_l_O,
                    fix.nugget = F,
                    nugget = nugget_0_lO,
                    wei = "cressie")

fitvar4_c_O <- likfit(ozone,
                  coords = ozone$coords,
                  data = ozone$data,
                  trend = ~ I(Norte^2) + I(Norte^3) + Este,
                  ini.cov.pars = ini1_l_O,
                  fix.nugget = F,
                  nugget = nugget_0_lO,
                  cov.model = "cubic",
                  lik.method = "ML")


plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_c_O, col="#FF4040", lwd=1.5)
lines(fitvar2_c_O, col="#4169E1", lwd=1.5)
lines(fitvar3_c_O, col="#008B00", lwd=1.5)
lines(fitvar4_c_O, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

```
:::

#### Kriging

Usando el modelo exponencial:

```{r}
plot(vg1_O,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Modelo exponencial para Ozono",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar3_l_O, col="#008B00", lwd=1.5)

```


```{r, message=F, warning=F, results='hide'}

#Se ajusta el mejor modelo -------------------------------

best_model_O <- gstat::vgm(psill = fitvar3_l_O$cov.pars[1],
                           model = "Exp",
                           range = fitvar3_l_O$cov.pars[2],
                           nugget = fitvar3_l_O$nugget
                           
)

# Se crea un objeto en gstat ------------------------------

coordinates(datosOZ) <- ~Este + Norte
proj4string(datosOZ) <- CRS("EPSG:3310")

g_obj<-gstat::gstat(id="Ozono",
             formula = Ozono ~ I(Norte^2) + I(Norte^3) + Este,
             model = best_model_O,
             data = datosOZ)

#Kriging ------------------------------------------------

invisible(predic <- predict(g_obj, newdata = new, nmin = 20))


#Mapas de predicción -------------------------------------

gridded(predic) <- TRUE

#1. Mapa de Kriging --------------------------------------

predic_raster_utm <- raster(predic, layer = "Ozono.pred")

crs(predic_raster_utm) <- "+init=epsg:3310"

predic_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        predic_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

min_pred <- raster::cellStats(predic_raster_wgs84, stat='min')
max_pred <- raster::cellStats(predic_raster_wgs84, stat='max')

pred_range <- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))

step_pred <- (max_pred-min_pred)/ 6

bins <- round(seq(min_pred, max_pred, by=step_pred),0)

pal_pred <- colorBin(
  palette = "viridis", # La paleta de colores
  domain = pred_range,
  bins = bins,
  na.color = "transparent"
)

mapa_kriging_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    predic_raster_wgs84, 
    colors = pal_pred, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
    addCircleMarkers(data = datosO_sf_wgs84,
                   fillColor = ~palO(Ozono),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("Ozn:", Ozono, "ppb")) %>% 
  
  addLegend(
    pal = pal_pred, 
    values = pred_range,
    title = "Predicción Oz ppb",
    position = "topright"
  ) %>%
  
  addLegend(pal = palO,
            values = datosO_sf_wgs84$Ozono,
            title = "Ozono Observado",
    position = "topleft"
  ) 

#2 Mapa Varianza------------------------------------------

var_raster_utm <- raster(predic, layer = "Ozono.var")

crs(var_raster_utm) <- "+init=epsg:3310"

var_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        var_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

max_var <- raster::cellStats(var_raster_wgs84, stat='max')
step_var <- max_var / 6

binsv <- round(seq(0, max_var, by=step_var),2)

var_range <- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))
pal_var <- colorBin(
  palette = "Spectral", # La paleta de colores
  domain = var_range,
  bins = binsv,
  na.color = "transparent"
)

mapa_var_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    var_raster_wgs84,
    colors = pal_var, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_var, 
    values = var_range,
    title = "Varianza",
    position = "topright"
  ) 

#3. Mapa Cv ----------------------------------------------

cv_raster_utm <- sqrt(var_raster_utm) / abs(predic_raster_utm)

mapa_mayor_a_uno <- cv_raster_utm > 1
cv_raster_utm[mapa_mayor_a_uno] <- 1

crs(cv_raster_utm) <- "+init=epsg:3310"

cv_terra <- terra::rast(cv_raster_utm)
sh_terra <- terra::vect(sh_mundos_sp_utm_simple)

masked_cv_terra <- terra::mask(cv_terra, sh_terra)

cv_raster_wgs84_terra <- terra::project(
    masked_cv_terra, 
    y = "epsg:4326", 
    method = "bilinear" # Similar a projectRaster
)

cv_raster_wgs84 <- raster::raster(cv_raster_wgs84_terra)

max_cv <- raster::cellStats(cv_raster_wgs84, stat='max')
step_cv <- max_cv / 10

bincv <- seq(0,max_cv, by=step_cv)

cv_range <- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))

pal_cv <- colorBin(
  palette = "RdYlGn", # Rojo-Amarillo-Verde
  domain = cv_range,
  na.color = "transparent",
  bins = bincv,
  reverse = TRUE
)

mapa_cv_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    cv_raster_wgs84,
    colors = pal_cv, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_cv, 
    values = cv_range,
    title = "Coeficiente de Variación",
    position = "topright"
  )

```

::: panel-tabset
##### Predicción

```{r}
mapa_kriging_leaflet
```

##### Varianza

```{r}
mapa_var_leaflet
```

##### Coeficiente de variación

```{r}
mapa_cv_leaflet
```

:::

### Variable Temperatura

Se tomaron los datos de Temperatura de la madrugada el primero de marzo de 2024:

```{r, message=F, warning=F}
y_T <- Temp[1,] #Tomar una fecha
y_T <- cbind(colnames(y_T),t(y_T[1,]))
y_T <- y_T[-1,]
y_T <- as.data.frame(y_T)
y_T <- na.omit(y_T)
y_T <- y_T[-which.min(y_T$V2),]
y_T$V1 <- as.numeric(y_T$V1)
y_T <- inner_join(y_T, EstacionesT, by=c("V1"="AQSID"))
datosT <- y_T[,c(13,14,2)]
colnames(datosT)=c("Este","Norte","Temperatura")
datosT$Temperatura <- as.numeric(datosT$Temperatura)

datosT_sf <- st_as_sf(datosT, coords = c("Este", "Norte"), crs = 3310)

datosT_sf_wgs84 <- st_transform(datosT_sf, crs = 4326)

pal <- colorNumeric(palette = "viridis", domain = datosT_sf_wgs84$Temperatura)

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = "black", weight = 2) %>%
  addCircleMarkers(data = datosT_sf_wgs84,
                   fillColor = ~pal(Temperatura),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("Temp:", Temperatura, "°C")) %>%
  addLegend(pal = pal, values = datosT_sf_wgs84$Temperatura, title = "Temperatura (°C)")

temp <- as.geodata(datosT) 
pander::pander(summary(temp))

```

::: panel-tabset
#### Gráficos de dispersión

```{r}
pT1 <- simple_scatter_plot(datosT, "Este", "Temperatura")
pT2 <- simple_scatter_plot(datosT, "Norte", "Temperatura")

cowplot::plot_grid(pT1,pT2)
```

#### GeoR

```{r}
plot(temp, qt.col = c("purple",
                    "pink",
                    "green",
                    "yellow"),
     scatter3d=T)
```
:::

En el gráfico se observa un agrupamiento en las coordenadas Norte con respecto a los datos, que puede llegar a corregirse con algún polinomio. Se probará con diferentes modelos a ver si se puede llegar a disminuir el efecto espacial.

#### Modelo para la Media

El modelo que mejor atrapa el efecto de la media es:

$$
Temperatura = \beta_0 + \beta_1 \times Norte + \beta_2 \times Norte^2
$$

```{r}
fitT <- lm(Temperatura~Norte+I(Norte^2), data = datosT) 
pander::pander(summary(fitT))
```

Observamos el comportamiento de sus residuales podemos notar que el modelo ayudo a reducir el efecto espacial.

::: panel-tabset
##### Gráficos de dispersión

```{r}
datosT$Residuos <- fitT$residuals

pT1 <- simple_scatter_plot(datosT, "Este", "Residuos")
pT2 <- simple_scatter_plot(datosT, "Norte", "Residuos")

cowplot::plot_grid(pT1,pT2)

```

##### GeoR

```{r}
plot(temp, qt.col = c("purple",
                    "pink",
                    "green",
                    "yellow"),
     scatter3d=T, trend=~Norte+I(Norte^2))
```
:::

#### Estimación Empírica del Semivariograma

p¿Presentamos la estimación del semivariograma obtenida mediante la función variog para la variable temperatura. Se comparan los resultados al calcularlo directamente sobre los datos originales (sin remover la tendencia) y al utilizar los residuales de un modelo de regresión, con el objetivo de analizar cómo influye la presencia de tendencia en la estructura espacial.

```{r, results='hide'}
vg_T <- variog(temp, estimator.type = "modulus", pairs.min=50) #Sin tendencia espacial

vg1_T <- variog(temp, trend = ~Norte+I(Norte^2),
                estimator.type = "modulus", pairs.min=50)

```

::: panel-tabset
##### Con tendencia

```{r}
plot(vg_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Sin remover tendencia",
     col.main = 4, cex.main =1.3)
```

##### Removiendo tendencia

```{r}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Removiendo tendencia",
     col.main = 4, cex.main =1.3)
```
:::

Cuando no se remueve la tendencia, la semivarianza alcanza valores más altos y presenta una forma aparentemente más regular, aunque dicha regularidad está influenciada por la tendencia global de los datos. En cambio, al eliminar la tendencia, los valores de semivarianza disminuyen y el patrón pierde suavidad, pero el variograma refleja con mayor fidelidad la verdadera dependencia espacial.

```{r}
plot(vg1_T$u, vg1_T$n, type="b",
     xlab="distance", ylab="n pairs",
     main="Número de pares por bin")
```

En este caso, el último punto corresponde a menos de 25 pares de observaciones, por lo que su interpretación resulta menos confiable.

#### Estimación del Modelo Teórico de Semivariograma

```{r}


dist_matrix_T <- as.matrix(dist(temp$coords))

#1. Funciones de correlación, covarianza y semivarianza: ----

#1.1 Modelo exponencial ----

rho_exp <- function(h, phi){
  exp(-(h/phi)) #Correlacion espacial
}

cov_exp <- function(sigma, h, phi){
  sigma*rho_exp(h, phi) #Covarianza espacial
}

sv_exp <- function(nugget, sigma, h, phi){
  nugget + sigma - cov_exp(sigma, h, phi) #Semivarianza espacial
} 

#1.2 Modelo Gaussianio ----

rho_gauss <- function(h, phi){
  exp(-(h/phi)^2)
}

cov_gauss <- function(sigma, h, phi){
  sigma*rho_gauss(h, phi) #Covarianza espacial
}

sv_gauss <- function(nugget, sigma, h, phi){
  nugget + sigma - cov_gauss(sigma, h, phi) #Semivarianza espacial
}
#1.3 Modelo Gneting ----

cov_gneiting <- function(h){
  s <- 0.301187465825
  ifelse(0<= s*h &  s*h <= 1,
  (1 + 8*s*h + 25*(s*h)^2 + 32*(s*h)^3) * (1-s*h)^8,
  0)
}

sv_gneiting <- function(nugget, sigma, h){
  nugget + sigma - cov_gneiting(h) #Semivarianza espacial
}

#1.4 Modelo Spherical ----

rho_spherical <- function(h, phi){
  ifelse(h<phi,
         1 - 1.5*(h/phi) + 0.5*(h/phi)^3,
         0)
}

cov_spherical <- function(sigma, h, phi){
  sigma*rho_spherical(h, phi) #Covarianza espacial
}

sv_spherical <- function(nugget, sigma, h, phi){
  nugget + sigma - cov_spherical(sigma, h, phi) #Semivarianza espacial
}

#1.5 Modelo Matern ----

rho_matern <- function(h, phi, kappa){
  (1/(2*gamma(kappa))) * (h/phi)^kappa * besselK((h/phi), kappa)
}

cov_matern <- function(sigma, h, phi, kappa){
  sigma*rho_matern(h, phi, kappa) #Covarianza espacial
}

sv_matern <- function(nugget, sigma, h, phi, kappa){
  nugget + sigma - cov_matern(sigma, h, phi, kappa) #Semivarianza espacial
}

#1.6 Modelo Coseno -----------------

cov_cos <- function(sigma, h, phi){
  sigma * cos(h/phi)
}

cos_sv <- function(nugget, sigma, h, phi){
  nugget +  sigma *(1 - cos(h/phi))
}

#1.7 Modelo wave ------


rho_wave <- function(h, sigma, phi){
  ifelse(h == 0,
         1,
         (phi / h) * sin(h / phi))
}

sv_wave <- function(nugget, sigma, h, phi) {
  ifelse(h == 0,
         nugget,
         nugget + sigma - sigma * (phi / h) * sin(h / phi))
}

cov_wave <- function(h, sigma, phi, nugget) {
  ifelse(h == 0,
         sigma,
         sigma * (phi / h) * sin(h / phi))
}


#2. Función para estimar por WLS----

MSE_ponderados <- function(par, h, gamma,kappa=NA,w, model, n, pesos){
  nugget <- par[1]
  sigma <- par[2]
  phi <- par[3]
  
  gamma_hat <- switch(model,
                      "exponencial" = sv_exp(nugget, sigma, h, phi),
                      "gaussian"    = sv_gauss(nugget, sigma, h, phi),
                      "gneiting"    = sv_gneiting(nugget, sigma, h, phi),
                      "spherical"   = sv_spherical(nugget, sigma, h, phi),
                      "matern"      = sv_matern(nugget, sigma, h, phi, kappa),
                      "cos"         = cos_sv(nugget, sigma, h, phi)
  )
  
  w <- switch(pesos,
              "Cressie" = 1/(2*(2*gamma_hat)^2/n),
              "n" = 1/n,
              "h/n" = 1/(h/n),
              "I" = 1)
  
  sum(w*(gamma - gamma_hat)^2)
}


est_sev_WLS <- function(par, kappa = NA, model, h, gamma, n){
  sigma_0 <- par[1]
  phi_0 <- par[2]
  nugget_0 <- par[3]
  kappa_0 <- kappa
  
  # Selección de función
  sv <- switch(model,
               "exponencial" = sv_exp,
               "gaussian"    = sv_gauss,
               "spherical"   = sv_spherical,
               "gneiting"    = sv_gneiting,
               "matern"      = sv_matern,
               "cos" = cos_sv
  )
  
  args_sv <- names(formals(sv))
  
  args_list <- list(
    nugget = nugget_0,
    sigma  = sigma_0,
    h      = h,
    phi    = phi_0,
    kappa  = kappa_0
  )
  
  args_list <- args_list[names(args_list) %in% args_sv]
  
  sv_ini <- do.call(sv, args_list)
  
  formula_sv <- switch(model,
                       "gneiting" = gamma ~ sv(nugget, sigma, h),
                       "matern" = gamma ~ sv(nugget, sigma, h, phi, kappa),
                       gamma ~ sv(nugget, sigma, h, phi)
  )
  
  start_list <- switch(model,
                       "gneting" = list(nugget = nugget_0, sigma = sigma_0),
                       "matern" = list(nugget = nugget_0, sigma = sigma_0, phi = phi_0, kappa = kappa_0),
                       list(nugget = nugget_0, sigma = sigma_0, phi = phi_0)
  )
    
    #1. Ponderación de Bessel
    
    WW <- (2*(2*sv_ini)^2/n)
    
    Bessel <- nls(formula = formula_sv,
                  start = start_list,
                  weights = 1/WW,
                  lower = c(0, rep(1e-6, length(start_list)-1)),
                  control = nls.control(maxiter = 500, warnOnly = TRUE))
    
    ini_Bessel<-coef(Bessel)
    
    #1.1 Optim Bessel
    
    optim_bessel <- optim(
      par = coef(Bessel),
      fn = MSE_ponderados,
      h = h,
      gamma = gamma,
      pesos = "Cressie",
      model = model,
      n = n,
      method = "L-BFGS-B",
      lower = c(0, rep(1e-6, length(start_list)-1))
    )
    
    par_optim_Bess <- optim_bessel$par[c("nugget", "sigma", "phi")]
    
    #2. Ponderación 1/n
    
    W1 <- n
    
    n_pond <- nls(formula = formula_sv,
                  start = start_list,
                  weights = 1/W1,
                  lower = c(0, rep(1e-6, length(start_list)-1)),
                  control = nls.control(maxiter = 500, warnOnly = TRUE))
    
    ini_n<-coef(n_pond)
    
    #2.1 Optimización 1/n
    
    optim_n <- optim(
      par = coef(n_pond),
      fn = MSE_ponderados,
      h = h,
      gamma = gamma,
      pesos = "n",
      n = n,
      model = model,
      method = "L-BFGS-B",
      lower = c(0, rep(1e-6, length(start_list)-1))
    )    
    
    par_optim_n <- optim_n$par[c("nugget", "sigma", "phi")]
    
    
    #3. Ponderación h/n
    
    W2 <- h/n
    
    h_n_pond <- nls(formula = formula_sv,
                    start = start_list,
                    weights = 1/W2,
                    lower = c(0, rep(1e-6, length(start_list)-1)),
                    control = nls.control(maxiter = 500, warnOnly = TRUE))
    
    ini_h_n<-coef(h_n_pond)
    
    optim_h_n <- optim(
      par = coef(h_n_pond),
      fn = MSE_ponderados,
      h = h,
      gamma = gamma,
      pesos = "h/n",
      model = model,
      n = n,
      method = "L-BFGS-B",
      lower = c(0, rep(1e-6, length(start_list)-1))
    )    
    
    par_optim_h_n <- optim_h_n$par[c("nugget", "sigma", "phi")]
    

res <- list(Bessel = list(Iniciales = ini_Bessel,
                           Optimizados = par_optim_Bess),
            `1/n` = list(Iniciales = ini_n,
                          Optimizados = par_optim_n),
            `h/n` = list(Iniciales = ini_h_n,
                          Optimizados = par_optim_h_n))    
return(res)
}

MSE_sv <- function(gamma_hat, par, kappa, model, h){
  sigma_0 <- par[[2]]
  phi_0 <- par[[3]]
  nugget_0 <- par[[1]]
  kappa_0 <- kappa
  
  sv <- switch(model,
               "exponencial" = sv_exp,
               "gaussian"    = sv_gauss,
               "spherical"   = sv_spherical,
               "gneiting"    = sv_gneiting,
               "matern"      = sv_matern,
               "cos" = cos_sv,
               "wave" = sv_wave
  )
  
  args_sv <- names(formals(sv))
  
  args_list <- list(
    nugget = nugget_0,
    sigma  = sigma_0,
    h      = h,
    phi    = phi_0,
    kappa  = kappa_0
  )
  
  args_list <- args_list[names(args_list) %in% args_sv]
  
  sv_est <- do.call(sv, args_list)
  
  return(mean((sv_est-gamma_hat)^2))
}

#3. Función para etimar por máxima verosimilitud

loglik <- function(par, kappa=NA, z, dist_matrix, model){
  sigma_0 <- par[1]
  phi_0 <- par[2]
  nugget_0 <- par[3]
  kappa_0 <- kappa
  
  cov <- switch(model,
               "exponencial" = cov_exp,
               "gaussian"    = cov_gauss,
               "spherical"   = cov_spherical,
               "gneiting"    = cov_gneiting,
               "matern"      = cov_matern
  )
  
  args_cov <- names(formals(cov))
  
  args_list <- list(
    sigma  = sigma_0,
    nugget = nugget_0,
    h      = dist_matrix,
    phi    = phi_0,
    kappa  = kappa_0
  )
  
  args_list <- args_list[names(args_list) %in% args_cov]
  
  Sigma <- do.call(cov, args_list) 
  diag(Sigma) = diag(Sigma) + nugget_0
  
  # Descomposición de Cholesky (más estable que solve o det)
  inv_Sigma <- solve(Sigma)
  det <- log(det(Sigma))
  
  # Log-verosimilitud del modelo Gaussiano
  z <- z 
  n <- length(z)
  ll <- -0.5 * (n * log(2 * pi) + det + crossprod(z, inv_Sigma %*% z))  # Log-verosimilitud (negativa porque optim minimiza)
  return(-ll)
}

```

Los modelos obtenidos ajustanto por EyeFit, son:

``` text

cov.model sigmasq      phi tausq kappa kappa2 practicalRange
1 exponential   10.74 109166.3  2.07    NA     NA       327033.0
2    gaussian   10.00  80000.0  2.07    NA     NA       138465.5
3   spherical   10.00 157832.8  2.07    NA     NA       157832.8
```

```{r, warning=FALSE, message=FALSE}

variog_T <- data.frame(h = vg1_T$u, gamma_hat = vg1_T$v,
                       n = vg1_T$n)

range_sv_T <- seq(1,max(variog_T$h), by=1000)

# Modelo exponencial ----

sigma_0_eT <- 10.74
phi_0_eT <- 109166.3
nugget_0_eT <- 2.07

par_eT <- c(sigma_0_eT, phi_0_eT, nugget_0_eT)

res_e_T <- est_sev_WLS(par=par_eT, kappa = NA,
                       model="exponencial",
                       h=variog_T$h,
                       gamma = variog_T$gamma_hat,
                       n = variog_T$n)

MLE_eT <- optim(fn = loglik,
             par = par_eT,
             kappa=NA,
             z = datosT$Residuos, 
             dist_matrix=dist_matrix_T,
             model = "exponencial",
             method = "L-BFGS-B",
             lower = c(0, 0, 0))

estsv_exp_Bess_T <- do.call(sv_exp, c(as.list(res_e_T$Bessel$Optimizados), list(h = range_sv_T)))
estsv_exp_n_T <- do.call(sv_exp, c(as.list(res_e_T$`1/n`$Optimizados), list(h = range_sv_T)))
estsv_exp_h_n_T <- do.call(sv_exp, c(as.list(res_e_T$`h/n`$Optimizados), list(h = range_sv_T)))
estsv_exp_MLE_T <- do.call(sv_exp, c(list(nugget = MLE_eT$par[3], phi = MLE_eT$par[2] , sigma = MLE_eT$par[1],h = range_sv_T)))

# Modelo Gaussiano ----

sigma_0_gT <- 10.00    
phi_0_gT <- 80000.0
nugget_0_gT <- 2.07

par_gT <- c(sigma_0_gT, phi_0_gT, nugget_0_gT)

res_g_T <- est_sev_WLS(par=par_gT, kappa = NA,
                       model="gaussian",
                       h=variog_T$h,
                       gamma = variog_T$gamma_hat,
                       n = variog_T$n)

estsv_g_Bess_T <- do.call(sv_gauss, c(as.list(res_g_T$Bessel$Optimizados), list(h = range_sv_T)))
estsv_g_n_T <- do.call(sv_gauss, c(as.list(res_g_T$`1/n`$Optimizados), list(h = range_sv_T)))
estsv_g_h_n_T <- do.call(sv_gauss, c(as.list(res_g_T$`h/n`$Optimizados), list(h = range_sv_T)))

# Modelo esférico

sigma_0_esT <- 10.00   
phi_0_esT <- 157832.8
nugget_0_esT <- 2.07

par_esT <- c(sigma_0_esT, phi_0_esT, nugget_0_esT)

res_es_T <- est_sev_WLS(par=par_esT, kappa = NA,
                       model="spherical",
                       h=variog_T$h,
                       gamma = variog_T$gamma_hat,
                       n = variog_T$n)

MLE_esT <- optim(fn = loglik,
             par = par_esT,
             kappa=NA,
             z = datosT$Residuos, 
             dist_matrix=dist_matrix_T,
             model = "spherical",
             method = "L-BFGS-B",
             lower = c(0, 0, 0))


estsv_es_Bess_T <- do.call(sv_spherical, c(as.list(res_es_T$Bessel$Optimizados), list(h = range_sv_T)))
estsv_es_n_T <- do.call(sv_spherical, c(as.list(res_es_T$`1/n`$Optimizados), list(h = range_sv_T)))
estsv_es_h_n_T <- do.call(sv_spherical, c(as.list(res_es_T$`h/n`$Optimizados), list(h = range_sv_T)))
estsv_es_MLE_T <- do.call(sv_spherical, c(list(nugget = MLE_esT$par[3], phi = MLE_esT$par[2] , sigma = MLE_esT$par[1],h = range_sv_T)))

```

:::::: panel-tabset
##### Exponencial

::: panel-tabset
###### Optim

```{r}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (optim)",
     col.main = "#36648B", cex.main =1.3)
lines(range_sv_T, estsv_exp_Bess_T, col="#FF4040", lwd=1.5)
lines(range_sv_T, estsv_exp_n_T, col="#4169E1", lwd=1.5)
lines(range_sv_T, estsv_exp_h_n_T, col="#008B00", lwd=1.5)
lines(range_sv_T, estsv_exp_MLE_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("Cressie", "1/n", "n/h", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

resumen_exp_T <- cbind(
  c("Cressie", "1/n", "n/h", "MLE"),
  rbind(
    t(res_e_T$Bessel$Optimizados),
    t(res_e_T$`1/n`$Optimizados),
    t(res_e_T$`h/n`$Optimizados),
    MLE_eT$par[c(3,1,2)]
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, res_e_T$Bessel$Optimizados, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_e_T$`1/n`$Optimizados, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_e_T$`h/n`$Optimizados, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, list(nugget = MLE_eT$par[3], phi = MLE_eT$par[2] , sigma = MLE_eT$par[1]), NA, model = "exponencial", variog_T$h)
  )
)

resumen_exp_T <- as.data.frame(resumen_exp_T)
resumen_exp_T[ , -1] <- lapply(resumen_exp_T[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_exp_T, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)
```

###### GeoR

```{r}
#| message: false
#| warning: false
#| results: 'hide'
ini1_exp_T <- c(sigma_0_eT, phi_0_eT)
fitvar1_exp_T <- variofit(vg1_T,
                    cov.model = "exponential",
                    ini1_exp_T,
                    fix.nugget = F,
                    nugget = nugget_0_eT,
                    wei = "equal")

fitvar2_exp_T <- variofit(vg1_T,
                    cov.model = "exponential",
                    ini1_exp_T,
                    fix.nugget = F,
                    nugget = nugget_0_eT,
                    wei = "npairs")

fitvar3_exp_T <- variofit(vg1_T,
                    cov.model = "exponential",
                    ini1_exp_T,
                    fix.nugget =F,
                    nugget = nugget_0_eT,
                    wei = "cressie")

fitvar4_exp_T <- likfit(temp,
                  coords = temp$coords,
                  data = temp$data,
                  trend = ~ poly(Norte, 2, raw = FALSE),
                  ini.cov.pars = ini1_exp_T,
                  fix.nugget = F,
                  nugget = nugget_0_eT,
                  cov.model = "exponential",
                  lik.method = "ML")


plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_exp_T, col="#FF4040", lwd=1.5)
lines(fitvar2_exp_T, col="#4169E1", lwd=1.5)
lines(fitvar3_exp_T, col="#008B00", lwd=1.5)
lines(fitvar4_exp_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

```

```{r}

par1Texp <- c(fitvar1_exp_T$nugget, fitvar1_exp_T$cov.pars[1], fitvar1_exp_T$cov.pars[2])
par2Texp <- c(fitvar2_exp_T$nugget, fitvar2_exp_T$cov.pars[1], fitvar2_exp_T$cov.pars[2])
par3Texp <- c(fitvar3_exp_T$nugget, fitvar3_exp_T$cov.pars[1], fitvar3_exp_T$cov.pars[2])
par4Texp <- c(fitvar4_exp_T$nugget, fitvar4_exp_T$cov.pars[1], fitvar4_exp_T$cov.pars[2])

resumen_exp_T2 <- cbind(
  c("MCO", "1/n", "Cressie","MLE"),
  rbind(
    par1Texp,
    par2Texp,
    par3Texp,
    par4Texp
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, par1Texp, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par2Texp, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par3Texp, NA, model = "exponencial", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par4Texp, NA, model = "exponencial", variog_T$h)
  )
)

resumen_exp_T2 <- as.data.frame(resumen_exp_T2)
resumen_exp_T2[ , -1] <- lapply(resumen_exp_T2[ , -1], function(x) round(as.numeric(x), 3))
kable(resumen_exp_T2, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)

```
:::

##### Gaussiano

::: panel-tabset
###### Optim

```{r}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (optim)",
     col.main = "#36648B", cex.main =1.3)
lines(range_sv_T, estsv_g_Bess_T, col="#FF4040", lwd=1.5)
lines(range_sv_T, estsv_g_n_T, col="#4169E1", lwd=1.5)
lines(range_sv_T, estsv_g_h_n_T, col="#008B00", lwd=1.5)
legend("topleft",
       c("Cressie", "1/n", "n/h"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00"),
       cex=1,
       seg.len = .5)

resumen_g_T <- cbind(
  c("Cressie", "1/n", "n/h"),
  rbind(
    t(res_g_T$Bessel$Optimizados),
    t(res_g_T$`1/n`$Optimizados),
    t(res_g_T$`h/n`$Optimizados)
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, res_g_T$Bessel$Optimizados, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_g_T$`1/n`$Optimizados, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_g_T$`h/n`$Optimizados, NA, model = "gaussian", variog_T$h)
  )
)

resumen_g_T <- as.data.frame(resumen_g_T)
resumen_g_T[ , -1] <- lapply(resumen_g_T[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_g_T, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F)

```

###### GeoR

```{r}
#| message: false
#| warning: false
#| results: 'hide'
#| 
ini1_g_T <- c(sigma_0_gT, phi_0_gT)
fitvar1_g_T <- variofit(vg1_T,
                    cov.model = "gaussian",
                    ini1_g_T,
                    fix.nugget = F,
                    nugget = nugget_0_gT,
                    wei = "equal")

fitvar2_g_T <- variofit(vg1_T,
                    cov.model = "gaussian",
                    ini1_g_T,
                    fix.nugget = F,
                    nugget = nugget_0_gT,
                    wei = "npairs")

fitvar3_g_T <- variofit(vg1_T,
                    cov.model = "gaussian",
                    ini1_g_T,
                    fix.nugget = F,
                    nugget = nugget_0_gT,
                    wei = "cressie")

fitvar4_g_T <- likfit(temp,
                  coords = temp$coords,
                  data = temp$data,
                  trend = ~ poly(Norte, 2, raw = FALSE),
                  ini.cov.pars = ini1_g_T,
                  fix.nugget = F,
                  nugget = nugget_0_gT,
                  cov.model = "gaussian",
                  lik.method = "ML")


plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_g_T, col="#FF4040", lwd=1.5)
lines(fitvar2_g_T, col="#4169E1", lwd=1.5)
lines(fitvar3_g_T, col="#008B00", lwd=1.5)
lines(fitvar4_g_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)
```

```{r}
par1Tg <- c(fitvar1_g_T$nugget, fitvar1_g_T$cov.pars[1], fitvar1_g_T$cov.pars[2])
par2Tg <- c(fitvar2_g_T$nugget, fitvar2_g_T$cov.pars[1], fitvar2_g_T$cov.pars[2])
par3Tg <- c(fitvar3_g_T$nugget, fitvar3_g_T$cov.pars[1], fitvar3_g_T$cov.pars[2])
par4Tg <- c(fitvar4_g_T$nugget, fitvar4_g_T$cov.pars[1], fitvar4_g_T$cov.pars[2])

resumen_g_T2 <- cbind(
  c("MCO", "1/n", "Cressie","MLE"),
  rbind(
    par1Tg,
    par2Tg,
    par3Tg,
    par4Tg
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, par1Tg, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par2Tg, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par3Tg, NA, model = "gaussian", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par4Tg, NA, model = "gaussian", variog_T$h)
  )
)

resumen_g_T2 <- as.data.frame(resumen_g_T2)
resumen_g_T2[ , -1] <- lapply(resumen_g_T2[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_g_T2, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)
```
:::

##### Esférico

::: panel-tabset
###### Optim

```{r}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (optim)",
     col.main = "#36648B", cex.main =1.3)
lines(range_sv_T, estsv_es_Bess_T, col="#FF4040", lwd=1.5)
lines(range_sv_T, estsv_es_n_T, col="#4169E1", lwd=1.5)
lines(range_sv_T, estsv_es_h_n_T, col="#008B00", lwd=1.5)
lines(range_sv_T, estsv_es_MLE_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("Cressie", "1/n", "n/h", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

resumen_es_T <- cbind(
  c("Cressie", "1/n", "n/h","MLE"),
  rbind(
    t(res_es_T$Bessel$Optimizados),
    t(res_es_T$`1/n`$Optimizados),
    t(res_es_T$`h/n`$Optimizados),
    MLE_esT$par[c(3,1,2)]
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, res_es_T$Bessel$Optimizados, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_es_T$`1/n`$Optimizados, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, res_es_T$`h/n`$Optimizados, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, list(nugget = MLE_esT$par[3], phi = MLE_esT$par[2] , sigma = MLE_esT$par[1]), NA, model = "spherical", variog_T$h)
  )
)

resumen_es_T <- as.data.frame(resumen_es_T)
resumen_es_T[ , -1] <- lapply(resumen_es_T[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_es_T, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F)
```

###### GeoR

```{r}
#| message: false
#| warning: false
#| results: 'hide'
#| 
ini1_es_T <- c(sigma_0_esT, phi_0_esT)
fitvar1_es_T <- variofit(vg1_T,
                    cov.model = "spherical",
                    ini1_es_T,
                    fix.nugget = F,
                    nugget = nugget_0_esT,
                    wei = "equal")

fitvar2_es_T <- variofit(vg1_T,
                    cov.model = "spherical",
                    ini1_es_T,
                    fix.nugget = F,
                    nugget = nugget_0_esT,
                    wei = "npairs")

fitvar3_es_T <- variofit(vg1_T,
                    cov.model = "spherical",
                    ini1_es_T,
                    fix.nugget = F,
                    nugget = nugget_0_esT,
                    wei = "cressie")

fitvar4_es_T <- likfit(temp,
                  coords = temp$coords,
                  data = temp$data,
                  trend = ~ poly(Norte, 2, raw = FALSE),
                  ini.cov.pars = ini1_es_T,
                  fix.nugget = F,
                  nugget = nugget_0_esT,
                  cov.model = "spherical",
                  lik.method = "ML")


plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_es_T, col="#FF4040", lwd=1.5)
lines(fitvar2_es_T, col="#4169E1", lwd=1.5)
lines(fitvar3_es_T, col="#008B00", lwd=1.5)
lines(fitvar4_es_T, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)



```

```{r}

par1Tes <- c(fitvar1_es_T$nugget, fitvar1_es_T$cov.pars[1], fitvar1_es_T$cov.pars[2])
par2Tes <- c(fitvar2_es_T$nugget, fitvar2_es_T$cov.pars[1], fitvar2_es_T$cov.pars[2])
par3Tes <- c(fitvar3_es_T$nugget, fitvar3_es_T$cov.pars[1], fitvar3_es_T$cov.pars[2])
par4Tes <- c(fitvar4_es_T$nugget, fitvar4_es_T$cov.pars[1], fitvar4_es_T$cov.pars[2])

resumen_es_T2 <- cbind(
  c("MCO", "1/n", "Cressie","MLE"),
  rbind(
    par1Tes,
    par2Tes,
    par3Tes,
    par4Tes
  ),
  MSE = c(
    MSE_sv(variog_T$gamma_hat, par1Tes, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par2Tes, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par3Tes, NA, model = "spherical", variog_T$h),
    MSE_sv(variog_T$gamma_hat, par4Tes, NA, model = "spherical", variog_T$h)
  )
)

resumen_es_T2 <- as.data.frame(resumen_es_T2)
resumen_es_T2[ , -1] <- lapply(resumen_es_T2[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_es_T2, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)

```
:::
::::::

El modelo con menor MSE es el modelo Gausiano. Sin embargo, dada la inestabilidad numérica que se observa al realizar la predicción se opta por usar el modelo esférico obtenido por mínimos cuadrados ponderados usando la ponderación $h/n$, que es el segundo mejor en términos del MSE.

#### Kriging

Usando el modelo esférico:

```{r}
plot(vg1_T,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Modelo esférico para Temperatura",
     col.main = "#36648B", cex.main =1.3)
lines(range_sv_T, estsv_es_h_n_T, col="#008B00", lwd=1.5)

```


```{r, message=F, warning=F, results='hide'}

#Se escoge el mejor modelo --------------------------------

best_model_T <- gstat::vgm(psill = res_es_T$`h/n`$Optimizados[2],
                           model = "Sph",
                           range = res_es_T$`h/n`$Optimizados[3],
                           nugget = res_es_T$`h/n`$Optimizados[1]
)

#Se crea un objeto en gstat -------------------------------

coordinates(datosT) <- ~Este + Norte
proj4string(datosT) <- CRS("EPSG:3310")

g_obj<-gstat::gstat(id="Temperatura",
             formula = Temperatura ~ Norte + I(Norte^2),
             model = best_model_T,
             data = datosT)

#Kriging -------------------------------------------------

suppressMessages(predic <- predict(g_obj, newdata = new, nmin = 20))

#Mapas de predicción --------------------------------------

gridded(predic) <- TRUE

#1. Mapa de Kriging ---------------------------------------

predic_raster_utm <- raster(predic, layer = "Temperatura.pred")

crs(predic_raster_utm) <- "+init=epsg:3310"

predic_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        predic_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

min_pred <- raster::cellStats(predic_raster_wgs84, stat='min')
max_pred <- raster::cellStats(predic_raster_wgs84, stat='max')

pred_range <- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))

step_pred <- (max_pred-min_pred)/ 6

bins <- round(seq(min_pred, max_pred, by=step_pred),0)

pal_pred <- colorBin(
  palette = "viridis", # La paleta de colores
  domain = pred_range,
  bins = bins,
  na.color = "transparent"
)

mapa_kriging_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    predic_raster_wgs84,
    colors = pal_pred, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
    addCircleMarkers(data = datosT_sf_wgs84,
                   fillColor = ~pal(Temperatura),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("Temp:", Temperatura, "°C")) %>% 
  addLegend(
    pal = pal_pred, 
    values = pred_range,
    title = "Predicción T (°C)",
    position = "topright"
  ) %>%
  addLegend(pal = pal,
            values = datosT_sf_wgs84$Temperatura,
            title = "Temperatura Observada",
    position = "topleft"
  ) 

#2 Mapa Varianza------------------------------------------

var_raster_utm <- raster(predic, layer = "Temperatura.var")

crs(var_raster_utm) <- "+init=epsg:3310"

var_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        var_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

max_var <- raster::cellStats(var_raster_wgs84, stat='max')
step_var <- max_var / 6

binsv <- round(seq(0, max_var, by=step_var),2)

var_range <- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))
pal_var <- colorBin(
  palette = "Spectral", # La paleta de colores
  domain = var_range,
  bins = binsv,
  na.color = "transparent"
)

mapa_var_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    var_raster_wgs84, 
    colors = pal_var, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_var, 
    values = var_range,
    title = "Varianza",
    position = "topright"
  ) 

#3. Mapa Cv ----------------------------------------------

cv_raster_utm <- sqrt(var_raster_utm) / abs(predic_raster_utm)

mapa_mayor_a_uno <- cv_raster_utm > 1
cv_raster_utm[mapa_mayor_a_uno] <- 1

crs(cv_raster_utm) <- "+init=epsg:3310"

cv_terra <- terra::rast(cv_raster_utm)

masked_cv_terra <- terra::mask(cv_terra, sh_terra)

cv_raster_wgs84_terra <- terra::project(
    masked_cv_terra, 
    y = "epsg:4326", 
    method = "bilinear" # Similar a projectRaster
)

cv_raster_wgs84 <- raster::raster(cv_raster_wgs84_terra)

max_cv <- raster::cellStats(cv_raster_wgs84, stat='max')
step_cv <- max_cv / 10

bincv <- seq(0,max_cv, by=step_cv)

cv_range <- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))

pal_cv <- colorBin(
  palette = "RdYlGn", # Rojo-Amarillo-Verde
  domain = cv_range,
  na.color = "transparent",
  bins = bincv,
  reverse = TRUE 
)

mapa_cv_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    cv_raster_wgs84, 
    colors = pal_cv, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  
  addLegend(
    pal = pal_cv, 
    values = cv_range,
    title = "Coeficiente de Variación",
    position = "topright"
  )

```

::: panel-tabset
##### Predicción

```{r}
mapa_kriging_leaflet
```

##### Varianza

```{r}
mapa_var_leaflet
```

##### Coeficiente de variación

```{r}
mapa_cv_leaflet
```

:::

### Variable Velocidad del viento

```{r, message=F, warning=F}

y_WS <- WS[1,] #Tomar una fecha
y_WS <- cbind(colnames(y_WS),t(y_WS[1,]))
y_WS <- y_WS[-1,]
y_WS <- as.data.frame(y_WS)
y_WS <- na.omit(y_WS)
y_WS$V1 <- as.numeric(y_WS$V1)
y_WS <- inner_join(y_WS, EstacionesWS, by=c("V1"="AQSID"))
datosWS <- y_WS[,c(13,14,2)]
colnames(datosWS)=c("Este","Norte","WindSpeed")
datosWS$WindSpeed <- as.numeric(datosWS$WindSpeed)

datosWS_sf <- st_as_sf(datosWS, coords = c("Este", "Norte"), crs = 3310)

datosWS_sf_wgs84 <- st_transform(datosWS_sf, crs = 4326)

palWS <- colorNumeric(palette = "viridis", domain = datosWS_sf_wgs84$WindSpeed)

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = "black", weight = 2) %>%
  addCircleMarkers(data = datosWS_sf_wgs84,
                   fillColor = ~palWS(WindSpeed),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("WindSpeed:", WindSpeed, "m/s")) %>%
  addLegend(pal = palWS, values = datosWS_sf_wgs84$WindSpeed, title = "WindSpeed (m/s)")


ws <- as.geodata(datosWS)
pander::pander(summary(ws))
```

::: panel-tabset
#### Gráficos de dispersión

```{r}
pWS1 <- simple_scatter_plot(datosWS, "Este", "WindSpeed")
pWS2 <- simple_scatter_plot(datosWS, "Norte", "WindSpeed")

cowplot::plot_grid(pWS1,pWS2)

```

#### GeoR

```{r}
plot(ws, qt.col = c("purple",
                          "pink",
                          "green",
                          "yellow"),
     scatter3d=T)
```
:::

#### Modelo para la Media

El modelo que mejor atrapa el efecto de la media es:

$$WindSpeed = \beta_0 + \beta_1 \times Este + \beta_2 \times Norte + \beta_3 \times Este \times Norte$$

```{r}
fitWS <- lm(WindSpeed~Este*Norte, data = datosWS) 
pander::pander(summary(fitWS))

```

Gráficamente se observa una mitigación en la tendencia espacial:

::: panel-tabset
##### Gráficos de dispersión

```{r}
datosWS$Residuos <- fitWS$residuals

pWS1 <- simple_scatter_plot(datosWS, "Este", "Residuos")
pWS2 <- simple_scatter_plot(datosWS, "Norte", "Residuos")

cowplot::plot_grid(pWS1,pWS2)

```

##### GeoR

```{r}
plot(temp, qt.col = c("purple",
                      "pink",
                      "green",
                      "yellow"),
     scatter3d=T, trend=~Norte*Este)
```
:::

#### Estimación Empírica del Semivariograma

```{r, message=FALSE, results='hide'}
vgO_WS <- variog(ws,estimator.type = "modulus", pairs.min=50) 

vg1_WS <- variog(ws, trend = ~Norte*Este,
                estimator.type = "modulus", pairs.min=50)
```

::: panel-tabset
##### Con tendencia

```{r}
plot(vgO_WS,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Sin remover tendencia",
     col.main = 4, cex.main =1.3)
```

##### Removiendo Tendencia

```{r}
plot(vg1_WS,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Removiendo tendencia",
     col.main = 4, cex.main =1.3)
```
:::

##### Asintropía

```{r, message=FALSE, warning=FALSE,results='hide'}
par(mfrow = c(2, 2),
    mar = c(3, 3, 1, 1),
    mgp = c(2, 1, 0))

vg1_WS_0 <- variog(ws, trend = ~Norte*Este,
                estimator.type = "modulus", pairs.min=50,
                direction = 0)
vg1_WS_45 <- variog(ws, trend = ~Norte*Este,
                estimator.type = "modulus", pairs.min = 20,
                direction = pi / 4)
vg1_WS_90 <- variog(ws, trend = ~Norte*Este,
                estimator.type = "modulus", pairs.min=50,
                direction = pi / 2)
vg1_WS_135 <- variog(ws, trend = ~Norte*Este,
                estimator.type = "modulus", pairs.min=50,
                direction = 3 * pi / 4)

plot(vg1_WS_0,
     xlab = "h",
     ylab = "Semivarianza",
     main = "0°",
     col.main = 4)
plot(vg1_WS_45,
     xlab = "h",
     ylab = "Semivarianza",
     main = "45°",
     col.main = 4)
plot(vg1_WS_90,
     xlab = "h",
     ylab = "Semivarianza",
     main = "90°",
     col.main = 4)
plot(vg1_WS_135,
     xlab = "h",
     ylab = "Semivarianza",
     main = "135°",
     col.main = 4)

```


#### Estimación del Modelo Teórico de Semivariograma

```{r}
#| message: false
#| warning: false
#| results: 'hide'

variog_WS <- data.frame(h = vg1_WS$u, gamma_hat = vg1_WS$v,
                       n = vg1_WS$n)

range_sv_WS <- seq(1,max(variog_WS$h), by=1000)

#Modelo Coseno---------------------------------------------

sigma_0_cosWS <- 1.5
phi_0_cosWS <- .6e5
nugget_0_cosWS <- 1.5

#MCO -------
I_pond_WS <- nls(formula = gamma_hat ~cos_sv(nugget, sigma, h, phi),
              start = c(nugget = nugget_0_cosWS, sigma = sigma_0_cosWS, phi = phi_0_cosWS),
              lower = rep(1e-6,3),
              data = variog_WS,
              control = nls.control(maxiter = 500, warnOnly = TRUE))

optim_I_WS <- optim(
  par = coef(I_pond_WS),
  fn = MSE_ponderados,
  h = variog_WS$h,
  gamma = variog_WS$gamma_hat,
  pesos = "I",
  model = "cos",
  n = n,
  method = "L-BFGS-B",
  lower = rep(1e-6,3)
)

par_optim_I_WS <- optim_I_WS$par[c("nugget", "sigma", "phi")]

estsv_cos_I_WS <- do.call(cos_sv, c(as.list(par_optim_I_WS), list(h = range_sv_WS)))


#WLS -------

par_cosWS <- c(sigma_0_cosWS, phi_0_cosWS, nugget_0_cosWS)

res_cos_WS <- est_sev_WLS(par=par_cosWS, kappa = NA,
                       model="cos",
                       h=variog_WS$h,
                       gamma = variog_WS$gamma_hat,
                       n = variog_WS$n)

estsv_cos_Bess_WS <- do.call(cos_sv, c(as.list(res_cos_WS$Bessel$Optimizados), list(h = range_sv_WS)))
estsv_cos_n_WS <- do.call(cos_sv, c(as.list(res_cos_WS$`1/n`$Optimizados), list(h = range_sv_WS)))
estsv_cos_h_n_WS <- do.call(cos_sv, c(as.list(res_cos_WS$`h/n`$Optimizados), list(h = range_sv_WS)))

#Modelo Wave ---------------------------------------------

nugget_0_wvWS <- 1.5

par_wvWS <- c(3.5,.6e5)

fitvar1_cos_WS <- variofit(vg1_WS,
                    cov.model = "wave",
                    par_wvWS,
                    fix.nugget = F,
                    nugget = nugget_0_wvWS,
                    wei = "equal")
fitvar2_cos_WS <- variofit(vg1_WS,
                    cov.model = "wave",
                    par_wvWS,
                    fix.nugget = F,
                    nugget = nugget_0_wvWS,
                    wei = "npairs")

fitvar3_cos_WS <- variofit(vg1_WS,
                    cov.model = "wave",
                    par_wvWS,
                    fix.nugget = F,
                    nugget = nugget_0_wvWS,
                    wei = "cressie")

fitvar4_cos_WS <- likfit(ws,
                       coords = ws$coords,
                       data = ws$data,
                       trend = ~ Este*Norte,
                       ini.cov.pars = par_wvWS,
                       fix.nugget = F,
                       nugget = nugget_0_wvWS,
                       cov.model = "wave",
                       lik.method = "ML")
```

::: panel-tabset

###### Coseno (Optim)

```{r}
plot(vg1_WS,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (optim)",
     col.main = 4, cex.main =1.3)
lines(range_sv_WS, estsv_cos_Bess_WS, col="#FF4040", lwd=1.5)
lines(range_sv_WS, estsv_cos_n_WS, col="#4169E1", lwd=1.5)
lines(range_sv_WS, estsv_cos_h_n_WS, col="#008B00", lwd=1.5)
lines(range_sv_WS, estsv_cos_I_WS, col="#FFA500", lwd=1.5)
legend("topleft",
       c("Cressie", "1/n", "n/h", "MCO"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

resumen_cos_SV <- cbind(
  c("Cressie", "1/n", "n/h", "MCO"),
  rbind(
    t(res_cos_WS$Bessel$Optimizados),
    t(res_cos_WS$`1/n`$Optimizados),
    t(res_cos_WS$`h/n`$Optimizados),
    par_optim_I_WS
  ),
  MSE = c(
    MSE_sv(variog_WS$gamma_hat, res_cos_WS$Bessel$Optimizados, NA, model = "cos", variog_WS$h),
    MSE_sv(variog_WS$gamma_hat, res_cos_WS$`1/n`$Optimizados, NA, model = "cos", variog_WS$h),
    MSE_sv(variog_WS$gamma_hat, res_cos_WS$`h/n`$Optimizados, NA, model = "cos", variog_WS$h),
    MSE_sv(variog_WS$gamma_hat, par_optim_I_WS, NA, model = "cos", variog_WS$h)
  )
)

resumen_cos_SV <- as.data.frame(resumen_cos_SV)
resumen_cos_SV[ , -1] <- lapply(resumen_cos_SV[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_cos_SV, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)
```

###### Wave (GeoR)

```{r, message=FALSE, warning=FALSE}

plot(vg1_WS,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = 4, cex.main =1.3)

lines(fitvar1_cos_WS, col="#FF4040", lwd=1.5)
lines(fitvar2_cos_WS, col="#4169E1", lwd=1.5)
lines(fitvar3_cos_WS, col="#008B00", lwd=1.5)
lines(fitvar4_cos_WS, col="#FFA500", lwd=1.5)

legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

```

```{r}
par1WScos <- c(fitvar1_cos_WS$nugget, fitvar1_cos_WS$cov.pars[1], fitvar1_cos_WS$cov.pars[2])
par2WScos <- c(fitvar2_cos_WS$nugget, fitvar2_cos_WS$cov.pars[1], fitvar2_cos_WS$cov.pars[2])
par3WScos <- c(fitvar3_cos_WS$nugget, fitvar3_cos_WS$cov.pars[1], fitvar3_cos_WS$cov.pars[2])
par4WScos <- c(fitvar4_cos_WS$nugget, fitvar4_cos_WS$cov.pars[1], fitvar4_cos_WS$cov.pars[2])

resumen_wv_WS <- cbind(
  c("MCO", "1/n", "Cressie","MLE"),
  rbind(
    par1WScos,
    par2WScos,
    par3WScos,
    par4WScos
  ),
  MSE = c(
    MSE_sv(variog_WS$gamma_hat, par1WScos, NA, model = "wave", variog_WS$h),
    MSE_sv(variog_WS$gamma_hat, par2WScos, NA, model = "wave", variog_WS$h),
    MSE_sv(variog_WS$gamma_hat, par3WScos, NA, model = "wave", variog_WS$h),
    MSE_sv(variog_WS$gamma_hat, par4WScos, NA, model = "wave", variog_WS$h)
  )
)

resumen_wv_WS <- as.data.frame(resumen_wv_WS)
resumen_wv_WS[ , -1] <- lapply(resumen_wv_WS[ , -1], function(x) round(as.numeric(x), 3))

kable(resumen_wv_WS, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)

```

:::

#### Kriging

Usando el modelo wave:

```{r}
plot(vg1_WS,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Modelo wave para WindSpeed",
     col.main = 4, cex.main =1.3)
lines(fitvar2_cos_WS, col="#4169E1", lwd=1.5)
```


```{r, message=F, warning=F, results='hide'}

#Se escoge el mejor modelo --------------------------------

best_model_WS <- gstat::vgm(psill = par2WScos[2],
                           model = "Wav",
                           range = par2WScos[3],
                           nugget = par2WScos[1]
)

#Se crea un objeto en gstat -------------------------------

coordinates(datosWS) <- ~Este + Norte
proj4string(datosWS) <- CRS("EPSG:3310")

g_obj<-gstat::gstat(id="WindSpeed",
             formula = WindSpeed ~ Norte*Este,
             model = best_model_WS,
             data = datosWS)

#Kriging -------------------------------------------------

suppressMessages(predic <- predict(g_obj, newdata = new, nmin = 20))

#Mapas de predicción --------------------------------------

gridded(predic) <- TRUE

#1. Mapa de Kriging ---------------------------------------

predic_raster_utm <- raster(predic, layer = "WindSpeed.pred")

crs(predic_raster_utm) <- "+init=epsg:3310"

predic_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        predic_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

min_pred <- raster::cellStats(predic_raster_wgs84, stat='min')
max_pred <- raster::cellStats(predic_raster_wgs84, stat='max')

pred_range <- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))

step_pred <- (max_pred-min_pred)/ 6

bins <- round(seq(min_pred, max_pred, by=step_pred),0)

pal_pred <- colorBin(
  palette = "viridis", # La paleta de colores
  domain = pred_range,
  bins = bins,
  na.color = "transparent"
)

mapa_kriging_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    predic_raster_wgs84,
    colors = pal_pred, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
    addCircleMarkers(data = datosWS_sf_wgs84,
                   fillColor = ~palWS(WindSpeed),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("WS:", WindSpeed, "m/s")) %>% 
  addLegend(
    pal = pal_pred, 
    values = pred_range,
    title = "Predicción WS (m/s)",
    position = "topright"
  ) %>%
  addLegend(pal = palWS,
            values = datosWS_sf_wgs84$WindSpeed,
            title = "WS Observada",
    position = "topleft"
  ) 

#2 Mapa Varianza------------------------------------------

var_raster_utm <- raster(predic, layer = "WindSpeed.var")

crs(var_raster_utm) <- "+init=epsg:3310"

var_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        var_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

max_var <- raster::cellStats(var_raster_wgs84, stat='max')
step_var <- max_var / 6

binsv <- round(seq(0, max_var, by=step_var),2)

var_range <- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))
pal_var <- colorBin(
  palette = "Spectral", # La paleta de colores
  domain = var_range,
  bins = binsv,
  na.color = "transparent"
)

mapa_var_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    var_raster_wgs84, 
    colors = pal_var, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_var, 
    values = var_range,
    title = "Varianza",
    position = "topright"
  ) 

#3. Mapa Cv ----------------------------------------------

predic$cv <- sqrt(predic$WindSpeed.var) / pmax(abs(predic$WindSpeed.pred), 1e-6)

predic$cv[predic$cv > 1] <- 1

cv_raster_utm <- raster(predic, layer = "cv")

crs(cv_raster_utm) <- "+init=epsg:3310"

cv_terra <- terra::rast(cv_raster_utm)

masked_cv_terra <- terra::mask(cv_terra, sh_terra)

cv_raster_wgs84_terra <- terra::project(
    masked_cv_terra, 
    y = "epsg:4326", 
    method = "bilinear" # Similar a projectRaster
)

cv_raster_wgs84 <- raster::raster(cv_raster_wgs84_terra)

max_cv <- raster::cellStats(cv_raster_wgs84, stat='max')
step_cv <- max_cv / 10

bincv <- seq(0,max_cv, by=step_cv)

cv_range <- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))


pal_cv <- colorBin(
  palette = "RdYlGn", # Rojo-Amarillo-Verde
  domain = cv_range,
  na.color = "transparent",
  bins = bincv,
  reverse = TRUE 
)

mapa_cv_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    cv_raster_wgs84, 
    colors = pal_cv, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  
  addLegend(
    pal = pal_cv, 
    values = cv_range,
    title = "Coeficiente de Variación",
    position = "topright"
  )

```

::: panel-tabset
##### Predicción

```{r}
mapa_kriging_leaflet
```

##### Varianza

```{r}
mapa_var_leaflet
```

##### Coeficiente de variación

```{r}
mapa_cv_leaflet
```

:::

### Variable presión atmosférica

```{r, message=F, warning=F}

y_Pr <- Presion[1,] #Tomar una fecha
y_Pr <- cbind(colnames(y_Pr),t(y_Pr[1,]))
y_Pr <- y_Pr[-1,]
y_Pr <- as.data.frame(y_Pr)
y_Pr <- na.omit(y_Pr)
y_Pr$V1 <- as.numeric(y_Pr$V1)
y_Pr <- y_Pr[-which.min(y_Pr$V2),]
y_Pr <- y_Pr[-which.min(y_Pr$V2),]
y_Pr <- inner_join(y_Pr, EstacionesPr, by=c("V1"="AQSID"))
datosPr <- y_Pr[,c(13,14,2)]
colnames(datosPr)=c("Este","Norte","Presion")
datosPr$Presion <- as.numeric(datosPr$Presion)

datosPr_sf <- st_as_sf(datosPr, coords = c("Este", "Norte"), crs = 3310)

datosPr_sf_wgs84 <- st_transform(datosPr_sf, crs = 4326)

palPr <- colorNumeric(palette = "viridis", domain = datosPr_sf_wgs84$Presion)

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(data = sh_mundos_wgs84, fill = FALSE, color = "black", weight = 2) %>%
  addCircleMarkers(data = datosPr_sf_wgs84,
                   fillColor = ~palPr(Presion),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("Presion:", Presion, "mb")) %>%
  addLegend(pal = palPr, values = datosPr_sf_wgs84$Presion, title = "Presión Barométrica mb")


presion <- as.geodata(datosPr)
pander::pander(summary(presion))

```

::: panel-tabset
#### Gráficos de dispersión

```{r}
pPr1 <- simple_scatter_plot(datosPr, "Este", "Presion")
pPr2 <- simple_scatter_plot(datosPr, "Norte", "Presion")

cowplot::plot_grid(pPr1,pPr2)

```

#### GeoR

```{r}
plot(presion, qt.col = c("purple",
                          "pink",
                          "green",
                          "yellow"),
     scatter3d=T)
```
:::

#### Modelo para la Media

El modelo que mejor atrapa el efecto de la media es:

$$Presion = \beta_0 + \beta_1 \times Este + \beta_2 \times Norte $$

```{r}
fitPr <- lm(Presion~Este+Norte, data=datosPr)
pander::pander(summary(fitPr))

```

Gráficamente se observa una mitigación en la tendencia espacial:

::: panel-tabset
##### Gráficos de dispersión

```{r}
datosPr$Residuos <- fitPr$residuals

pPr1 <- simple_scatter_plot(datosPr, "Este", "Residuos")
pPr2 <- simple_scatter_plot(datosPr, "Norte", "Residuos")

cowplot::plot_grid(pPr1,pPr2)

```

##### GeoR

```{r}
plot(presion, qt.col = c("purple",
                      "pink",
                      "green",
                      "yellow"),
     scatter3d=T, trend=~Norte+Este)
```
:::

#### Estimación Empírica del Semivariograma

```{r, message=FALSE, results='hide'}
vgO_Pr <- variog(presion,estimator.type = "modulus", pairs.min=50) 

vg1_Pr <- variog(presion, trend = ~Norte+Este,
                estimator.type = "modulus", pairs.min=50)
```

::: panel-tabset
##### Con tendencia

```{r}
plot(vgO_Pr,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Sin remover tendencia",
     col.main = 4, cex.main =1.3)
```

##### Removiendo Tendencia

```{r}
plot(vg1_Pr,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Removiendo tendencia",
     col.main = 4, cex.main =1.3)
```
:::

#### Estimación del Modelo Teórico de Semivariograma

Los modelos obtenidos ajustanto por EyeFit, son:

``` text

cov.model sigmasq      phi tausq kappa kappa2 practicalRange
1 exponential 1056.47 126360.8 132.06    NA     NA       378543.2
```

##### Exponencial

```{r, message=FALSE, warning=FALSE, results='hide'}

variog_Pr <- data.frame(h = vg1_Pr$u, gamma_hat = vg1_Pr$v,
                       n = vg1_Pr$n)

nugget_0_ePr <- 132.06

par_ePr <- c(1056.47,126360.8)

fitvar1_exp_Pr <- variofit(vg1_Pr,
                    cov.model = "exponential",
                    par_ePr,
                    fix.nugget = F,
                    nugget = nugget_0_ePr,
                    wei = "equal")

fitvar2_exp_Pr <- variofit(vg1_Pr,
                    cov.model = "exponential",
                    par_ePr,
                    fix.nugget = F,
                    nugget = nugget_0_ePr,
                    wei = "npairs")

fitvar3_exp_Pr <- variofit(vg1_Pr,
                    cov.model = "exponential",
                    par_ePr,
                    fix.nugget = F,
                    nugget = nugget_0_ePr,
                    wei = "cressie")

fitvar4_exp_Pr <- likfit(presion,
                       coords = presion$coords,
                       data = presion$data,
                       trend = ~ Este+Norte,
                       ini.cov.pars = par_ePr,
                       fix.nugget = F,
                       nugget = nugget_0_ePr,
                       cov.model = "exponential",
                       lik.method = "ML")

plot(vg1_Pr,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Estimación teórica del modelo de semivariograma \n (GeoR, gstat)",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_exp_Pr, col="#FF4040", lwd=1.5)
lines(fitvar2_exp_Pr, col="#4169E1", lwd=1.5)
lines(fitvar3_exp_Pr, col="#008B00", lwd=1.5)
lines(fitvar4_exp_Pr, col="#FFA500", lwd=1.5)
legend("topleft",
       c("MCO", "1/n", "Cressie", "MLE"),#, "REML"),
       lwd = 1,
       lty = 3,
       col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       box.col = 9,
       text.col = c("#FF4040", "#4169E1", "#008B00","#FFA500"),
       cex=1,
       seg.len = .5)

```

```{r}
par1Prexp <- c(fitvar1_exp_Pr$nugget, fitvar1_exp_Pr$cov.pars[1], fitvar1_exp_Pr$cov.pars[2])
par2Prexp <- c(fitvar2_exp_Pr$nugget, fitvar2_exp_Pr$cov.pars[1], fitvar2_exp_Pr$cov.pars[2])
par3Prexp <- c(fitvar3_exp_Pr$nugget, fitvar3_exp_Pr$cov.pars[1], fitvar3_exp_Pr$cov.pars[2])
par4Prexp <- c(fitvar4_exp_Pr$nugget, fitvar4_exp_Pr$cov.pars[1], fitvar4_exp_Pr$cov.pars[2])

resumen_exp_Pr <- cbind(
  c("MCO", "1/n", "Cressie","MLE"),
  rbind(
    par1Prexp,
    par2Prexp,
    par3Prexp,
    par4Prexp
  ),
  MSE = c(
    MSE_sv(variog_Pr$gamma_hat, par1Prexp, NA, model = "exponencial", variog_Pr$h),
    MSE_sv(variog_Pr$gamma_hat, par2Prexp, NA, model = "exponencial", variog_Pr$h),
    MSE_sv(variog_Pr$gamma_hat, par3Prexp, NA, model = "exponencial", variog_Pr$h),
    MSE_sv(variog_Pr$gamma_hat, par4Prexp, NA, model = "exponencial", variog_Pr$h)
  )
)

resumen_exp_Pr <- as.data.frame(resumen_exp_Pr)
resumen_exp_Pr[ , -1] <- lapply(resumen_exp_Pr[ , -1], function(x) round(as.numeric(x), 3))
kable(resumen_exp_Pr, digits = 3,
      col.names = c("Método", "Nugget", "Sigma", "Phi", "MSE"),
      escape = F, row.names = F)
```

#### Kriging

Usando el modelo exponencial:

```{r}
plot(vg1_Pr,
     xlab = "h",
     ylab = "Semivarianza",
     cex.lab = 1.3,
     cex.axis = 1.2,
     main = "Modelo exponencial para Presión",
     col.main = "#36648B", cex.main =1.3)
lines(fitvar1_exp_Pr, col="#FF4040", lwd=1.5)


```


```{r, message=F, warning=F, results='hide'}

#Se ajusta el mejor modelo -------------------------------

best_model_Pr <- gstat::vgm(psill = fitvar1_exp_Pr$cov.pars[1],
                           model = "Exp",
                           range = fitvar1_exp_Pr$cov.pars[2],
                           nugget = fitvar1_exp_Pr$nugget
                           
)

# Se crea un objeto en gstat ------------------------------

coordinates(datosPr) <- ~Este + Norte
proj4string(datosPr) <- CRS("EPSG:3310")

g_obj<-gstat::gstat(id="Presion",
             formula = Presion ~ Norte + Este,
             model = best_model_Pr,
             data = datosPr)

#Kriging ------------------------------------------------

invisible(predic <- predict(g_obj, newdata = new))


#Mapas de predicción -------------------------------------

gridded(predic) <- TRUE

#1. Mapa de Kriging --------------------------------------

predic_raster_utm <- raster(predic, layer = "Presion.pred")

crs(predic_raster_utm) <- "+init=epsg:3310"

predic_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        predic_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

min_pred <- raster::cellStats(predic_raster_wgs84, stat='min')
max_pred <- raster::cellStats(predic_raster_wgs84, stat='max')

pred_range <- c(minValue(predic_raster_wgs84), maxValue(predic_raster_wgs84))

step_pred <- (max_pred-min_pred)/ 6

bins <- round(seq(min_pred, max_pred, by=step_pred),0)

pal_pred <- colorBin(
  palette = "viridis", # La paleta de colores
  domain = pred_range,
  bins = bins,
  na.color = "transparent"
)

mapa_kriging_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    predic_raster_wgs84, 
    colors = pal_pred, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
    addCircleMarkers(data = datosPr_sf_wgs84,
                   fillColor = ~palPr(Presion),
                   fillOpacity = 0.8,
                   color = "black",
                   weight = 1,
                   radius = 3,
                   popup = ~paste("Presión:", Presion, "mb")) %>% 
  
  addLegend(
    pal = pal_pred, 
    values = pred_range,
    title = "Predicción Presión mb",
    position = "topright"
  ) %>%
  
  addLegend(pal = palPr,
            values = datosPr_sf_wgs84$Presion,
            title = "Presión Observada",
    position = "topleft"
  ) 

#2 Mapa Varianza------------------------------------------

var_raster_utm <- raster(predic, layer = "Presion.var")

crs(var_raster_utm) <- "+init=epsg:3310"

var_raster_wgs84 <- raster::projectRaster(
    raster::mask(
        var_raster_utm, 
        sh_mundos_sp_utm_simple
    ),
    crs = "+init=epsg:4326", 
    method = "bilinear"
)

max_var <- raster::cellStats(var_raster_wgs84, stat='max')
step_var <- max_var / 6

binsv <- round(seq(0, max_var, by=step_var),2)

var_range <- c(minValue(var_raster_wgs84), maxValue(var_raster_wgs84))
pal_var <- colorBin(
  palette = "Spectral", # La paleta de colores
  domain = var_range,
  bins = binsv,
  na.color = "transparent"
)

mapa_var_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    var_raster_wgs84,
    colors = pal_var, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_var, 
    values = var_range,
    title = "Varianza",
    position = "topright"
  ) 

#3. Mapa Cv ----------------------------------------------

cv_raster_utm <- sqrt(var_raster_utm) / abs(predic_raster_utm)

mapa_mayor_a_uno <- cv_raster_utm > 1
cv_raster_utm[mapa_mayor_a_uno] <- 1

crs(cv_raster_utm) <- "+init=epsg:3310"

cv_terra <- terra::rast(cv_raster_utm)
sh_terra <- terra::vect(sh_mundos_sp_utm_simple)

masked_cv_terra <- terra::mask(cv_terra, sh_terra)

cv_raster_wgs84_terra <- terra::project(
    masked_cv_terra, 
    y = "epsg:4326", 
    method = "bilinear" # Similar a projectRaster
)

cv_raster_wgs84 <- raster::raster(cv_raster_wgs84_terra)

max_cv <- raster::cellStats(cv_raster_wgs84, stat='max')
step_cv <- max_cv / 10

bincv <- seq(0,max_cv, by=step_cv)

cv_range <- c(minValue(cv_raster_wgs84), maxValue(cv_raster_wgs84))

pal_cv <- colorBin(
  palette = "RdYlGn", # Rojo-Amarillo-Verde
  domain = cv_range,
  na.color = "transparent",
  bins = bincv,
  reverse = TRUE
)

mapa_cv_leaflet <- leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addRasterImage(
    cv_raster_wgs84,
    colors = pal_cv, 
    opacity = 0.7,
    group = "Predicción Kriging"
  ) %>%
  addLegend(
    pal = pal_cv, 
    values = cv_range,
    title = "Coeficiente de Variación",
    position = "topright"
  )

```

::: panel-tabset
##### Predicción

```{r}
mapa_kriging_leaflet
```

##### Varianza

```{r}
mapa_var_leaflet
```

##### Coeficiente de variación

```{r}
mapa_cv_leaflet
```

:::

## Conclusiones

# Referencias {-}